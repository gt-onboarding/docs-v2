---
description: Découvrez comment appliquer une contrainte d’émetteur aux jetons à l’aide de Demonstrating Proof-of-Possession
  (DPoP) dans Auth0.
'og:image': https://cdn2.auth0.com/docs/1.14553.0/img/share-image.png
'og:title': Demonstrating Proof-of-Possession (DPoP)
'og:url': https://auth0.com/docs/
permalink: demonstrating-proof-of-possession-dpop
title: Demonstrating Proof-of-Possession (DPoP)
'twitter:description': Découvrez comment appliquer une contrainte d’émetteur aux jetons à l’aide de Demonstrating Proof-of-Possession
  (DPoP) dans Auth0.
'twitter:title': Demonstrating Proof-of-Possession (DPoP)
---

<Callout icon="file-lines" color="#0EA5E9" iconType="regular">
  L’application d’une contrainte d’émetteur aux jetons à l’aide de Demonstrating Proof-of-Possession (DPoP) est actuellement en accès anticipé. Pour demander l’accès à cette fonctionnalité, communiquez avec votre représentant Auth0.
</Callout>

Demonstrating Proof-of-Possession (DPoP) est une [extension du framework OAuth 2.0](https://datatracker.ietf.org/doc/draft-ietf-oauth-dpop/) qui associe ou [contraint par émetteur](/docs/fr-CA/secure/sender-constraining) les <Tooltip tip="Access Token : justificatif d’autorisation, sous la forme d’une chaîne opaque ou d’un JWT, utilisé pour accéder à une API." cta="Afficher le glossaire" href="/docs/fr-CA/glossary?term=access+tokens">jetons d’accès</Tooltip> au moyen de la cryptographie asymétrique et de <Tooltip tip="Access Token : justificatif d’autorisation, sous la forme d’une chaîne opaque ou d’un JWT, utilisé pour accéder à une API." cta="Afficher le glossaire" href="/docs/fr-CA/glossary?term=JSON+Web+Tokens">JSON Web Tokens</Tooltip> (JWT) à la couche applicative. DPoP garantit que seule l’application cliente qui a demandé le jeton d’accès, et qui possède la clé privée, peut l’utiliser. Cela empêche l’utilisation abusive de jetons volés.

DPoP utilise une paire de clés publique/privée pour créer une preuve DPoP (DPoP Proof) sous forme de JSON Web Token (JWT) signé. La preuve DPoP contient :

* La clé publique (`jwk`) du client.
* La charge utile se rapportant à la requête de jeton d’accès, incluant la méthode (`htm`) et l’URI (`htu`).
* Une signature créée à l’aide de la clé privée du client.
* Un id unique (`jti`) pour prévenir les attaques par rejeu.
* Pour chaque requête à une API, un hachage SHA-256 encodé en base64url (`ath`) du jeton d’accès.
* Facultatif : pour les <Tooltip tip="Public Client : client (application) qui ne peut pas conserver des informations d’identification de façon sécuritaire. Par exemple, une application native de bureau ou mobile, ainsi qu’une application Web côté client basée sur JavaScript (comme une application monopage (SPA))." cta="Afficher le glossaire" href="/docs/fr-CA/glossary?term=public+clients">clients publics</Tooltip>, une revendication `nonce` pour garantir que l’application cliente a généré récemment le JWT de preuve DPoP.

L’application cliente envoie le JWT de preuve DPoP dans une requête de jeton d’accès au <Tooltip tip="Authorization Server : serveur centralisé qui contribue à définir les limites de l’accès d’un utilisateur. Par exemple, votre serveur d’autorisation peut contrôler les données, les tâches et les fonctionnalités auxquelles un utilisateur a accès." cta="Afficher le glossaire" href="/docs/fr-CA/glossary?term=Authorization+Server">serveur d’autorisation</Tooltip> Auth0. Une fois que le serveur d’autorisation Auth0 valide le JWT de preuve DPoP, il associe le jeton d’accès émis à la clé publique du client.

<div id="common-use-cases">
  ## Cas d’utilisation courants
</div>

Découvrez quelques cas d’utilisation courants de DPoP :

* **Applications monopages (SPA) et applications mobiles :** En tant que clients publics, les SPA et les applications mobiles n’ont pas d’environnement fiable et confidentiel, comme un serveur backend, pour stocker de façon sécuritaire les <Tooltip tip="Client Secret : Secret utilisé par un client (Application) pour s’authentifier auprès du Serveur d’autorisation; il ne doit être connu que du client et du Serveur d’autorisation et doit être suffisamment aléatoire pour ne pas pouvoir être deviné." cta="Afficher le glossaire" href="/docs/fr-CA/glossary?term=client+secrets">Secrets client</Tooltip>, ce qui les rend vulnérables au vol de jetons. DPoP atténue cette vulnérabilité de sécurité en liant les jetons d’accès à la clé publique de l’application cliente, ce qui crée un JWT de preuve DPoP. L’application cliente signe le JWT de preuve DPoP avec sa clé privée et l’envoie dans une requête d’autorisation. Le Serveur d’autorisation Auth0 valide le JWT de preuve DPoP et, s’il est valide, lie le jeton d’accès émis à la clé publique du client.
* **Intégrations d’API tierces :** Si un agent d’IA intégré à votre application cliente appelle une API tierce pour le compte de l’utilisateur en utilisant un JWT de preuve DPoP, alors le <Tooltip tip="Resource Server : Serveur hébergeant des ressources protégées. Les serveurs de ressources acceptent et répondent aux requêtes visant des ressources protégées." cta="Afficher le glossaire" href="/docs/fr-CA/glossary?term=resource+server">serveur de ressources</Tooltip> peut vérifier cryptographiquement que la requête provient de l’agent d’IA et non d’un tiers non autorisé.

<div id="supported-application-grant-types">
  ## Types d’octroi d’autorisation d’application pris en charge
</div>

Auth0 prend en charge les [types d’octroi d’autorisation d’application](/docs/fr-CA/get-started/applications/application-grant-types) suivants pour la restriction de l’émetteur avec DPoP :

<table class="table">
  <thead>
    <tr>
      <th><strong>Type d’octroi</strong></th>
      <th><strong>Description</strong></th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td><code>authorization&#95;code</code></td>
      <td>Octroi par code d’autorisation</td>
    </tr>

    <tr>
      <td><code>client&#95;credentials</code></td>
      <td>Octroi par identifiants de Client</td>
    </tr>

    <tr>
      <td><code>password</code></td>
      <td>Octroi par mot de passe du propriétaire des ressources</td>
    </tr>

    <tr>
      <td><code>refresh&#95;token</code></td>
      <td>Octroi par Jeton d’actualisation</td>
    </tr>

    <tr>
      <td><code>urn:ietf:params:oauth:grant-type:device&#95;code</code></td>
      <td>Octroi d’autorisation de dispositif</td>
    </tr>

    <tr>
      <td><code>http://auth0.com/oauth/grant-type/password-realm</code></td>
      <td>Utiliser un octroi d’extension semblable à l’octroi par mot de passe du propriétaire des ressources, qui permet d’indiquer un realm spécifique</td>
    </tr>

    <tr>
      <td><code>http://auth0.com/oauth/grant-type/passwordless/otp</code></td>
      <td>Requête d’octroi pour l’authentification sans mot de passe</td>
    </tr>

    <tr>
      <td><code>http://auth0.com/oauth/grant-type/mfa-oob</code></td>
      <td>Requête d’octroi d’authentification multifacteur (AMF (MFA)) hors bande (OOB)</td>
    </tr>

    <tr>
      <td><code>http://auth0.com/oauth/grant-type/mfa-otp</code></td>
      <td>Requête d’octroi d’authentification multifacteur (AMF (MFA)) par OTP</td>
    </tr>

    <tr>
      <td><code>http://auth0.com/oauth/grant-type/mfa-recovery-code</code></td>
      <td>Requête d’octroi d’authentification multifacteur (AMF (MFA)) par code de récupération</td>
    </tr>

    <tr>
      <td><code>urn:ietf:params:oauth:grant-type:token-exchange</code></td>
      <td>Requête d’octroi d’échange de jeton personnalisé</td>
    </tr>

    <tr>
      <td><code>urn:okta:params:oauth:grant-type:webauthn</code></td>
      <td>Requête d’octroi WebAuthn</td>
    </tr>
  </tbody>
</table>

<div id="how-it-works">
  ## Fonctionnement
</div>

Le diagramme de séquence suivant illustre les grandes étapes du flux DPoP d&#39;Auth0 :

<Frame>![](/docs/images/cdy7uua7fh8z/XoEV4y12QtnGwBPCiFbep/6744ab830ab2119664463f8c52fe6b02/Screenshot_2025-07-28_at_11.15.42_AM.png)</Frame>

1. Lors de la demande d’un jeton d’accès auprès du Serveur d’autorisation Auth0, l’application cliente génère une paire de clés cryptographiques unique et utilise la clé publique pour prouver qu’elle possède la clé privée.
2. L’application cliente génère le DPoP Proof JWT et l’envoie au point de terminaison /token du Serveur d’autorisation Auth0.
3. Le Serveur d’autorisation Auth0 vérifie le DPoP Proof JWT et, s’il est valide, émet le jeton d’accès et le lie à la clé publique du client.
4. Avant d’appeler l’API Customer, l’application cliente génère un nouveau DPoP Proof JWT pour prouver qu’elle possède la clé privée associée au jeton. L’application cliente envoie le DPoP Proof JWT et le jeton d’accès restreint à l’émetteur au serveur de ressources.
5. Le serveur de ressources vérifie le DPoP Proof JWT afin de s’assurer que seul le propriétaire légitime du jeton, ou l’application cliente d’origine, peut l’utiliser pour accéder aux ressources protégées. Pour obtenir un jeton d’accès à partir d’un jeton d’actualisation, l’application cliente génère un nouveau DPoP Proof JWT, ce qui garantit que le jeton d’actualisation est lié à la clé publique du client.

<div id="sender-constrain-tokens-using-dpop-in-auth0">
  ## Restreindre les jetons à l’expéditeur à l’aide de DPoP dans Auth0
</div>

Le diagramme suivant illustre le flux de bout en bout pour restreindre les jetons à l’expéditeur à l’aide de DPoP dans Auth0 :

<Frame>![](/docs/images/cdy7uua7fh8z/7sonusMpvBMP0fDS6OkXSA/7cd0d50ffc44167f52f7e29d7f723d4a/Screenshot_2025-07-28_at_11.17.43_AM.png)</Frame>

Les sections suivantes vous guident étape par étape dans le flux DPoP dans Auth0 avec des exemples de code pour l’implémentation :

* [Prérequis](#prerequisites)
* [Étape 1 : l’application cliente génère une paire de clés DPoP](#step-1-client-application-generates-a-dpop-key-pair)
* [Étape 2 : l’application cliente crée un JWT de preuve DPoP](#step-2-client-application-creates-a-dpop-proof-jwt)
* [Étape 3 : l’application cliente demande un jeton lié à DPoP](#step-3-client-application-requests-a-dpop-bound-token)
* [Étape 4 : le Serveur d’autorisation Auth0 valide le JWT de preuve DPoP](#step-4-auth0-authorization-server-validates-the-dpop-proof-jwt)
* [Étape 5 : l’application cliente appelle l’API avec le jeton lié à DPoP et le JWT de preuve DPoP](#step-5-client-application-calls-api-with-the-dpop-bound-token-and-dpop-proof-jwt)
* [Étape 6 : gérer l’actualisation du jeton avec DPoP](#step-6-handle-token-refresh-with-dpop)

<div id="prerequisites">
  ## Prérequis
</div>

Avant de commencer, assurez-vous de :

* [Configurer la contrainte d’expéditeur](/docs/fr-CA/secure/sender-constraining/configure-sender-constraining) pour votre application cliente et votre serveur de ressources.

<div id="step-1-client-application-generates-a-dpop-key-pair">
  ## Step 1: Client application generates a DPoP key pair
</div>

For DPoP, the client application must generate an asymmetric cryptographic key pair. Auth0 supports the use of Elliptic Curve, such as in ES256 keys. This key pair is unique to your client application and should be securely stored, for example, in a hardware-backed keystore.

The client application keeps the private key secret while including the public key in the DPoP Proof JSON Web Token (JWT) that serves as the “proof of possession” in [Step 2](#step-2-client-application-creates-a-dpop-proof-jwt).

<div id="step-2-client-application-creates-a-dpop-proof-jwt">
  ## Étape 2 : L’application cliente crée un JWT de preuve DPoP
</div>

Avant de demander un jeton d’accès lié à DPoP au point de terminaison `/token` du Serveur d’autorisation Auth0, votre application cliente doit créer un JWT de preuve DPoP. Un JWT de preuve DPoP est un JSON Web Token (JWT) signé avec la clé privée de votre client qui sert de « preuve de possession ».

Le JWT de preuve DPoP se compose d’un en-tête JWT et d’une charge utile JWT qui contiennent des [revendications](/docs/fr-CA/secure/tokens/json-web-tokens/json-web-token-claims) liées à la requête de jeton :

<div id="jwt-header-claims">
  ### Revendications d’en-tête JWT
</div>

<table class="table">
  <thead>
    <tr>
      <th><strong>Revendication JWT de preuve DPoP</strong></th>
      <th><strong>Description</strong></th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td><code>typ</code></td>
      <td>Doit être défini sur <code>dpop+jwt</code>.</td>
    </tr>

    <tr>
      <td><code>alg</code></td>
      <td>L’algorithme de signature asymétrique utilisé, comme <code>RS256</code> ou <code>ES256</code>.</td>
    </tr>

    <tr>
      <td><code>jwk</code></td>
      <td>Une représentation JSON Web Key (JWK) de la clé publique de votre client.</td>
    </tr>
  </tbody>
</table>

<div id="jwt-payload-claims">
  ### Déclarations (claims) du payload JWT
</div>

<table class="table">
  <thead>
    <tr>
      <th><strong>Déclaration JWT de preuve DPoP</strong></th>
      <th><strong>Description</strong></th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td><code>jti</code></td>
      <td>Identifiant unique du JWT pour empêcher les attaques par rejeu.</td>
    </tr>

    <tr>
      <td><code>htm</code></td>
      <td>Méthode HTTP de la requête pour laquelle la preuve DPoP est utilisée, par exemple <code>POST</code> pour les requêtes de jeton et <code>GET</code> pour les appels d’API.</td>
    </tr>

    <tr>
      <td><code>htu</code></td>
      <td>URI HTTP de la requête pour laquelle le JWT de preuve DPoP est utilisé, sans le fragment ni les paramètres de requête. Par exemple : `https://api.example.com/data?param=1#section1` devient `https://api.example.com/data`.</td>
    </tr>

    <tr>
      <td><code>iat</code></td>
      <td>Horodatage de création du JWT.</td>
    </tr>

    <tr>
      <td><code>ath</code></td>
      <td>Pour les appels d’API avec un jeton d’accès, un hachage SHA-256 encodé en base64url du jeton d’accès.</td>
    </tr>

    <tr>
      <td><code>nonce</code></td>
      <td>Pour les clients publics nécessitant un <code>nonce</code>, une valeur de <code>nonce</code> fournie par le serveur.</td>
    </tr>
  </tbody>
</table>

Une fois que l’application cliente a créé le JWT de preuve DPoP, elle le signe avec la clé privée générée à l’[étape 1](#step-1-client-application-generates-a-dpop-key-pair).

L’exemple de code suivant montre comment créer et signer un JWT de preuve DPoP dans votre application cliente :

```jsx lines
import { generateKeyPairSync, randomBytes } from 'node:crypto';
import jwt from 'jsonwebtoken';

// Générer une paire de clés DPoP
const keyPair = generateKeyPairSync('ec', {
  namedCurve: 'P-256',
});

// Construire le JWT de preuve DPoP pour la requête de jeton
const jti = randomBytes(16).toString('base64url');
const jwk = keyPair.publicKey.export({ format: 'jwk' });
const dpopHeader = jwt.sign({
    jti,
    htm: 'POST',
    htu: 'https://[TENANT]/oauth/token',
    iat: Date.now() / 1000,
  },
  keyPair.privateKey,
  {
    algorithm: 'ES256',
    header: {
      typ: 'dpop+jwt',
      jwk,
    },
  });
```

<div id="step-3-client-application-requests-a-dpop-bound-token">
  ## Step 3: Client application requests a DPoP-bound token
</div>

When your client application requests an access token from the Auth0 Authorization Server’s `/token` endpoint, it includes the DPoP Proof JWT in the HTTP header of the request:

```http lines
DPoP: {DPoP_proof_JWT_value}
```

The following is an example access token request that includes the DPoP HTTP header populated with a DPoP Proof JWT:

```http lines
POST /oauth/token HTTP/1.1
Host: auth.example.com
Content-Type: application/x-www-form-urlencoded
DPoP: {DPoP Proof JWT}
Authorization: Basic Y2xpZW50MTIzOm15c2VjcmV0
Cache-Control: no-cache
grant_type=client_credentials&client_id=client123
```

To implement how to request a DPoP-bound access token in your client application, use the following code sample, which does the following:

1. Populates the DPoP HTTP header with a signed DPoP Proof JWT.
2. Sends the DPoP HTTP header with a signed DPoP Proof JWT in an access token request to the `/token` endpoint.
3. Processes the response from the Auth0 Authorization Server.

```javascript lines
// Make the request to the /oauth/token endpoint
// Replace [...] with your actual grant_type, client_id, and tenant URL
const response = await fetch('https://[TENANT]/oauth/token', {
    method: 'POST',
    body: new URLSearchParams({
      grant_type: '...',
      client_id: '...',
      // Other body parameters here
    }),
    headers: {
      "Content-Type": "application/x-www-form-urlencoded",
      // Add the DPoP header
      dpop: dpopHeader
    }
  });

// Process the response from the Auth0 Authorization Server
const result = await response.json();
console.log('Initial token request result:', result);
```

<div id="public-clients">
  ### Clients publics
</div>

Si un client public, comme une application monopage (SPA) ou une application mobile, demande un jeton d’accès lié à DPoP, vous n’aurez pas de Secret client ni d’autres paramètres d’authentification de client. Dans ce cas, Auth0 exige que votre en-tête HTTP DPoP contienne une valeur de <Tooltip tip="Nonce : nombre arbitraire émis une seule fois dans un protocole d’authentification pour détecter et empêcher les attaques par rejeu." cta="Voir le glossaire" href="/docs/fr-CA/glossary?term=nonce">nonce</Tooltip> afin de s’assurer que l’application cliente a généré récemment le JWT de preuve DPoP.

Si un client public effectue une requête `/token` et n’inclut pas de valeur `nonce` dans l’en-tête HTTP DPoP, Auth0 répond avec un code `HTTP 400` et un message d’erreur semblable au suivant :

```js lines
{
  error: 'use_dpop_nonce',
  error_description: 'Le serveur d'autorisation exige un nonce dans la preuve DPoP'
}
```

Auth0 inclut un en-tête `DPoP-Nonce` dans les en-têtes de réponse. Vous devez utiliser la valeur de l’en-tête `DPoP-Nonce`, régénérer la preuve DPoP (comme à l’[étape 2](#step-2-client-application-creates-a-dpop-proof-jwt)), inclure une revendication `nonce` avec cette valeur, puis soumettre de nouveau la requête au point de terminaison `/token`.

L’exemple de code suivant montre le flux de bout en bout lors de l’envoi, puis de la nouvelle tentative d’exécution d’une requête `/token` avec une revendication `nonce` à partir d’un client public :

```jsx lines expandable
import { generateKeyPairSync, randomBytes } from 'node:crypto';
import jwt from 'jsonwebtoken';

// Generate a DPoP Key Pair
const keyPair = generateKeyPairSync('ec', {
  namedCurve: 'P-256',
});

/**
 * Fonction auxiliaire pour générer un JWT de preuve DPoP.
 * @param {string} method - Méthode HTTP (p. ex. 'POST', 'GET').
 * @param {string} url - URL complète de la requête.
 * @param {string} [nonce] - Valeur DPoP-Nonce optionnelle provenant du serveur.
 * @param {string} [accessToken] - Jeton d'accès optionnel à hacher pour la revendication 'ath'.
 * @returns {string} Le JWT de preuve DPoP signé.
 */
function generateDPoPHeader(method, url, nonce) {
  const jti = randomBytes(16).toString('base64url');
  const jwk = keyPair.publicKey.export({ format: 'jwk' });
  return jwt.sign({
      jti,
      htm: method,
      htu: url,
      iat: Date.now() / 1000,
      nonce
    },
    keyPair.privateKey,
    {
      algorithm: 'ES256',
      header: {
        typ: 'dpop+jwt',
        jwk,
      },
    });
  }

// Request access token the first time without nonce 
async function getTokens(nonce) {
  const response = await fetch('https://[TENANT]/oauth/token', {
      method: 'POST',
      body: new URLSearchParams({
        grant_type: '...',
        client_id: '...',
        // Other body parameters here
      }),
      headers: {
        "Content-Type": "application/x-www-form-urlencoded",
        dpop: generateDPoPHeader('POST', 'https://[TENANT]/oauth/token', nonce),
      }
    });

  const result = await response.json();
  return { response, result };
}

// The first time we request tokens, we won't have a nonce
let { response, result } = await getTokens(); 
console.log('Initial token request result:', result);

if (response.status === 400 && result.error === 'use_dpop_nonce') {
  const nonce = response.headers.get('dpop-nonce');

  console.log('Received nonce:', nonce);

  // Retry with the nonce
  ({ response, result } = await getTokens(nonce)); 

  console.log('Tokens received:', result);
}
```

<div id="step-4-auth0-authorization-server-validates-the-dpop-proof-jwt">
  ## Step 4: Auth0 Authorization Server validates the DPoP Proof JWT
</div>

When the Auth0 Authorization Server receives the token request, it does the following:

* Extracts the DPoP Proof JWT, its public key, and signature.
* Verifies the signature using the provided public key.
* Validates the `htm`, `htu`, `jti,` and `iat` claims.
* If valid, it issues an access token. The Auth0 Authorization Server includes a confirmation claim, `cnf`, in the access token. The `cnf` claim contains the thumbprint (hash) of the public key taken from the DPoP Proof JWT. By including it in the access token, the Auth0 Authorization Server binds the access token to that specific public key, or “sender-constrains” the access token.
* Sets the `token_type` in the `Authorization` header to `DPoP` instead of `Bearer` in the token response. Traditionally, when the access token is passed in the `Authorization` header, it is set to `Bearer`. However, because we’re passing an access token bound to a public key using DPoP, it is set to `DPoP` instead.
* The Auth0 Authorization Server then issues the DPoP sender-constrained access token to your client application.

<div id="step-5-client-application-calls-api-with-the-dpop-bound-token-and-dpop-proof-jwt">
  ## Step 5: Client application calls API with the DPoP-bound token and DPoP Proof JWT
</div>

For every API call to a resource server that enforces DPoP, your client application must present both the DPoP-bound access token and a new DPoP Proof JWT.

By requiring a DPoP Proof JWT with every API request, DPoP ensures that only the client application that possesses the private key can use the access token.

For a new API request, the client application:

1. Generates a new DPoP Proof JWT with the following claims:

* The `htm` claim is the API request&#39;s `HTTP` method, such as `GET` or `POST`.
* The `htu` claim is the API request&#39;s URI.
* The `ath` claim is the base64url-encoded SHA-256 hash of the DPoP-bound access token you received in [Step 3](#step-3-client-application-requests-a-dpop-bound-token).

2. Cryptographically signs the new DPoP Proof JWT with the client&#39;s private key.

3. Includes the DPoP-bound access token in the `Authorization` header using the `DPoP` authentication scheme:

```javascript lines
// The DPoP scheme aligns with the token_type received from the Authorization Server
Authorization: DPoP {access_token}
```

4. Includes the newly generated DPoP Proof JWT in the `DPoP` HTTP header:

```http lines
DPoP: {new_dpop_proof_jwt}
```

The `DPoP` HTTP header must include an additional `ath` claim. The `ath` claim is a base64url encoded SHA256 hash of the issued access token.

The resource server:

* Receives the API request and extracts the access token, DPoP JWT proof, public key, and signature.
* Verifies the DPoP Proof JWT&#39;s signature using the public key from its `jwk` header.
* Validates the `htm`, `htu`, `jti`, `iat`, and `ath` claims.
* Verifies that the public key indicated in the DPoP Proof JWT via its `jwk` header matches the public key bound to the access token via the `cnf.jkt` claim in the access token.

If all checks pass, the resource server authorizes the request. If not, it rejects the request, and access is denied.

The following code sample requests an access token from Auth0 using DPoP and then calls the `/userinfo` endpoint using a DPoP-bound access token:

```jsx lines expandable
import { generateKeyPairSync, randomBytes, createHash } from 'node:crypto';
import jwt from 'jsonwebtoken';

const keyPair = generateKeyPairSync('ec', {
  namedCurve: 'P-256',
});

function hashToken(token) {
  return createHash('sha256').update(token).digest('base64url');
}

function generateDPoPHeader(method, url, nonce, accessToken) {
  const jti = randomBytes(16).toString('base64url');
  const jwk = keyPair.publicKey.export({ format: 'jwk' });
  return jwt.sign({
      jti,
      htm: method,
      htu: url,
      iat: Date.now() / 1000,
      nonce,

      // Optionally include an `ath` claim containing an access token hash
      ...(accessToken ? { ath: hashToken(accessToken) } : {}),
    },
    keyPair.privateKey,
    {
      algorithm: 'ES256',
      header: {
        typ: 'dpop+jwt',
        jwk,
      },
    });
  }

async function getTokens(nonce) {
  const response = await fetch('https://[TENANT]/oauth/token', {
      method: 'POST',
      body: new URLSearchParams({
        grant_type: '...',
        client_id: '...',
        // Other body parameters here
      }),
      headers: {
        "Content-Type": "application/x-www-form-urlencoded",
        dpop: generateDPoPHeader('POST', 'https://test1.local.dev.auth0.com/oauth/token', nonce),
      }
    });

  const result = await response.json();
  return { response, result };
}

// The first time we do this, we won't have a nonce
let { response, result } = await getTokens(); 
console.log('Initial token request result:', result);

if (response.status === 400 && result.error === 'use_dpop_nonce') {
  const nonce = response.headers.get('dpop-nonce');
  console.log('Received nonce:', nonce);
  ({ response, result } = await getTokens(nonce)); // Retry with the nonce
  console.log('Tokens received:', result);
}

// Now call /userinfo with DPoP
const userInfoResponse = await fetch('https://[TENANT]/userinfo', {
  method: 'GET',
  headers: {
    // Pass our access token using the DPoP authorization scheme
    Authorization: `DPoP ${result.access_token}`,

    // Include a DPoP header, this time with access token hash
    dpop: generateDPoPHeader('GET', 'https://[TENANT]/userinfo', nonce, result.access_token),
  },
});

console.log('User info response status:', userInfoResponse.status);
console.log('User info result:', await userInfoResponse.json());
```

<div id="step-6-handle-token-refresh-with-dpop">
  ## Étape 6 : Gérer l’actualisation des jetons avec DPoP
</div>

Lorsque votre jeton d’accès lié à DPoP expire, vous pouvez utiliser un <Tooltip tip="Jeton d’actualisation : jeton utilisé pour obtenir un jeton d’accès renouvelé sans obliger les utilisateurs à se connecter de nouveau." cta="Voir le glossaire" href="/docs/fr-CA/glossary?term=refresh+token">jeton d’actualisation</Tooltip> pour en obtenir un nouveau. Une requête de jeton d’actualisation nécessite un JWT de preuve DPoP généré à l’aide de la même paire de clés que celle utilisée dans la requête de jeton initiale.

Voici comment se déroule le flux de jeton d’actualisation avec DPoP dans Auth0 :

L’application cliente :

* Envoie une requête de jeton d’actualisation au point de terminaison `/token` du Serveur d’autorisation Auth0.
* Génère un JWT de preuve DPoP pour la requête de jeton d’actualisation (semblable à l’[étape 2](#step-2-client-application-creates-a-dpop-proof-jwt), avec `htm` comme `POST` et `htu` comme URI du <Tooltip tip="Point de terminaison de jeton : point de terminaison sur le Serveur d’autorisation utilisé pour demander des jetons de façon programmatique." cta="Voir le glossaire" href="/docs/fr-CA/glossary?term=token+endpoint">point de terminaison de jeton</Tooltip>).
* Inclut le JWT de preuve DPoP dans l’en-tête HTTP `DPoP`.

Le Serveur d’autorisation Auth0 :

* Valide le JWT de preuve DPoP (comme à l’[étape 4](#step-4-auth0-authorization-server-validates-the-dpop-proof-jwt)) et émet un nouveau jeton d’accès lié à DPoP.

<div id="important-considerations">
  ## Important considerations
</div>

When implementing DPoP in your client applications, consider the following:

* **Private key security:** The security of your DPoP implementation depends on the security of your client&#39;s private key, so you must protect it from unauthorized access. Private keys should be generated and stored in a hardware-backed medium and marked as non-exportable.
* **Replay protection (**`jti`** and **`dpop-nonce`**):** The `jti` claim in the DPoP Proof JWT helps prevent replay attacks for protected resources, such as the [`/userinfo`](https://auth0.com/docs/api/authentication/user-profile/get-user-info) endpoint. The Auth0 Authorization Server currently does not check `jti` reuse on the `/userinfo` endpoint. The Auth0 Authorization Server issues a `DPoP-Nonce` HTTP header in its response, which public clients must include as a `nonce` claim in subsequent DPoP Proof JWTs for enhanced replay protection.
* **Error handling:** You are responsible for implementing logic to handle DPoP-specific errors from the Auth0 Authorization Server or resource server, such as `invalid_dpop_proof` or `use_dpop_nonce`.
* **Client types:** Use DPoP for public clients, such as Single Page Applications (SPAs) or mobile apps that cannot securely store a client secret. For <Tooltip tip="Client confidentiel
  Un client (application) qui peut conserver des identifiants en toute sécurité en utilisant un serveur dorsal de confiance. Les exemples incluent une application web avec un système dorsal sécurisé et une application machine-machine (M-M)." cta="Voir le glossaire" href="/docs/fr-CA/glossary?term=confidential+clients">confidential clients</Tooltip>, such as backend services with client secrets, DPoP adds a layer of security, but they already have other sender-constraining mechanisms.
* **Performance:** Because generating and signing DPoP Proof JWTs for every API call adds a small overhead, ensure your client application’s cryptographic operations are efficient.
* **Key rotation:** Implement a strategy for rotating your DPoP key pairs for enhanced security. Make sure you use the same key pair for the same session.
* **Persistence:** For client applications that need to maintain a session and reuse DPoP-bound access tokens, such as long-lived SPAs, securely persist and retrieve the original generated key pair across application reloads. If a new key pair is generated or a different key pair is used, the DPoP-bound access token becomes invalid, as it is cryptographically tied to the public key of the original pair. You can persist the key pair, for example, in a browser&#39;s `IndexedDB` or a mobile app&#39;s secure storage.

<div id="learn-more">
  ## En savoir plus
</div>

* [Configurer Sender Constraining](/docs/fr-CA/secure/sender-constraining/configure-sender-constraining)