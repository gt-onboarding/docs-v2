---
description: Le package **Actions NPM (`@auth0/actions`)** permet d’utiliser TypeScript dans des projets externes, ce qui aide les développeurs à appliquer les meilleures pratiques et à améliorer leurs **tests unitaires** en s’appuyant sur les définitions TypeScript.
'og:image': https://cdn2.auth0.com/docs/1.14553.0/img/share-image.png
'og:title': Tests unitaires pour Actions
'og:url': https://auth0.com/docs/
permalink: actions-unit-test
title: Tests unitaires pour Actions
'twitter:description': Le package **Actions NPM (`@auth0/actions`)** permet d’utiliser TypeScript dans des projets externes, ce qui aide les développeurs à appliquer les meilleures pratiques et à améliorer leurs **tests unitaires** en s’appuyant sur les définitions TypeScript.
'twitter:title': Tests unitaires pour Actions
---

<div id="auth0-actions-unit-test">
  # Test unitaire pour les Actions Auth0
</div>

Le package **Actions NPM (`@auth0/actions`)** permet d&#39;utiliser TypeScript dans des projets externes, afin que les développeurs puissent suivre les meilleures pratiques et améliorer leurs tests unitaires à partir des définitions TypeScript.

***

<div id="how-it-works">
  ## Fonctionnement
</div>

Suivez les directives d&#39;installation et d&#39;importation décrites ici : [Fonctionnement d&#39;Actions NPM](/docs/fr-CA/customize/actions/actions-npm#how-it-works).

Pour effectuer un test unitaire d&#39;une Action, vous devez simuler (mock) les objets `event` et `api` que votre fonction Action reçoit. Vous pouvez créer ces mocks à l&#39;aide des définitions TypeScript incluses dans `auth0/actions`, ce qui garantit que vos tests reflètent fidèlement l&#39;environnement de production. Des frameworks de tests comme Jest sont idéaux pour gérer le mocking et la fonctionnalité.

Les tests unitaires peuvent être exécutés dans un environnement local, un système de contrôle de version ou un processus CI/CD, ce qui améliore l&#39;assurance qualité globale et les validations avant que les changements n&#39;aient une incidence sur vos tenants Auth0.

***

<div id="examples">
  ## Exemples
</div>

Les exemples suivants permettent de valider une série de scénarios en simulant les objets nécessaires.

<Note>
  Les exemples utilisent **Jest** (`https://www.npmjs.com/package/jest`), mais n&#39;importe quelle bibliothèque de tests peut être utilisée.
</Note>

<div id="configuration">
  ### Configuration
</div>

Dans votre `package.json`, définissez vos dépendances de développement afin de profiter d’IntelliSense lorsque vous écrivez votre Action.

<Tabs>
  <Tab title="JavaScript">
    ```javascript
    {
      "name": "actions-js",
      "version": "1.0.0",
      "description": "Actions JS",
      "main": "example.js",
      "scripts": {
        "test": "jest"
      },
      "author": "John Doe",
      "license": "ISC",
      "devDependencies": {
        "@auth0/actions": "^0.7.1",
        "jest": "^29.7.0"
      }
    }
    ```
  </Tab>

  <Tab title="TypeScript">
    ```typescript
    {
      "name": "actions-ts",
      "version": "1.0.0",
      "description": "Actions TS",
      "main": "example.ts",
      "scripts": {
        "test": "jest"
      },
      "author": "John Doe",
      "license": "ISC",
      "devDependencies": {
        "@auth0/actions": "^0.7.1",
        "@types/jest": "^29.5.12",
        "@types/node": "22.14.0",
        "jest": "^29.7.0",
        "ts-jest": "^29.1.2",
        "typescript": "^5.9.2"
      }
    }
    ```

    Dans votre fichier `tsconfig.json`, définissez la manière dont le compilateur TypeScript doit fonctionner :

    ```typescript
    {
      "compilerOptions": {
        "target": "ES2020",
        "module": "NodeNext",
        "moduleResolution": "nodenext",
        "esModuleInterop": true,
        "allowSyntheticDefaultImports": true,
        "strict": true,
        "outDir": "dist",
        "declaration": true,
        "sourceMap": true,
        "allowJs": true,
        "checkJs": false,
        "resolveJsonModule": true,
        "skipLibCheck": true,
        "forceConsistentCasingInFileNames": true,
        "isolatedModules": true
      },
      "include": [
        "**/*.ts"
      ],
      "exclude": [
        "node_modules",
        "dist"
      ]
    }
    ```

    Dans votre fichier `jest.config.js`, définissez les préréglages d’environnement pour `Jest` :

    ```typescript
    module.exports = {
      preset: 'ts-jest',
      testEnvironment: 'node',
    };
    ```
  </Tab>
</Tabs>

<div id="pre-user-registration-access-control-and-user-metadata-setup">
  ## Contrôle d’accès avant l’inscription de l’utilisateur et configuration de user&#95;metadata
</div>

L’Action d’exemple suivante vérifie si le courriel de l’utilisateur contient un domaine de courriel interdit et appelle `api.access.deny()` en cas de correspondance. Sinon, elle vérifie si le nom complet a été fourni au moyen des champs supplémentaires de Custom Prompts et procède à la définition du nom complet dans le `user_metadata` du profil de l’utilisateur; autrement, elle envoie une erreur de validation à Universal Login.

<Tabs>
  <Tab title="JavaScript">
    ```javascript
    /** @import {Event, PreUserRegistrationAPI} from "@auth0/actions/pre-user-registration/v2" */

    /**
    * Gestionnaire qui sera appelé pendant l’exécution d’un flux PreUserRegistration.
    *
    * @param {Event} event - Détails sur le contexte et l’utilisateur qui tente de s’inscrire.
    * @param {PreUserRegistrationAPI} api - Interface dont les méthodes peuvent être utilisées pour modifier le comportement de l’inscription.
    */
    exports.onExecutePreUserRegistration = async (event, api) => {
      const user = event.user;

      if (user.email?.endsWith('@example.com')) {
        api.access.deny('forbidden', 'Domaine de courriel interdit')
        return;
      }

      const fullName = event.request.body['ulp-fullName'];

      if (fullName === undefined) {
        api.validation.error('invalid_payload', 'Nom complet manquant');
        return;
      }

      api.user.setUserMetadata('full_name', fullName);
    }
    ```
  </Tab>

  <Tab title="TypeScript">
    ```typescript
    import type { Event, PreUserRegistrationAPI } from '@auth0/actions/pre-user-registration/v2';

    /**
    * Gestionnaire qui sera appelé pendant l’exécution d’un flux PreUserRegistration.
    *
    * @param {Event} event - Détails sur le contexte et l’utilisateur qui tente de s’inscrire.
    * @param {PreUserRegistrationAPI} api - Interface dont les méthodes peuvent être utilisées pour modifier le comportement de l’inscription.
    */
    exports.onExecutePreUserRegistration = async (event: Event, api: PreUserRegistrationAPI) => {
      const user = event.user;

      if (user.email?.endsWith('@example.com')) {
        api.access.deny('forbidden', 'Domaine de courriel interdit')
        return;
      }

      const fullName = event.request.body['ulp-fullName'];

      if (fullName === undefined) {
        api.validation.error('invalid_payload', 'Nom complet manquant');
        return;
      }

      api.user.setUserMetadata('full_name', fullName);
    };
    ```
  </Tab>
</Tabs>

Le test unitaire effectue certaines validations pour maximiser la couverture du code, en simulant les objets `event` et `api`.

<Tabs>
  <Tab title="Javascript">
    ```javascript
    const { onExecutePreUserRegistration } = require('./preUserRegistration');

    describe('onExecutePreUserRegistration', () => {
      const mockApi = {
        access: {
          deny: jest.fn(),
        },
        user: {
          setUserMetadata: jest.fn(),
        },
        validation: {
          error: jest.fn(),
        },
      };

      beforeEach(() => {
        jest.resetAllMocks();
      });

      afterEach(() => {
        jest.resetAllMocks();
      });

      it('interdit le domaine de courriel', async () => {
        const mockEvent = {
          user: {
            email: 'johndoe@example.com',
          }
        };

        await onExecutePreUserRegistration(mockEvent, mockApi);

        expect(mockApi.access.deny).toHaveBeenCalledWith('forbidden', 'Domaine de courriel interdit');
        expect(mockApi.validation.error).not.toHaveBeenCalled();
        expect(mockApi.user.setUserMetadata).not.toHaveBeenCalled();
      });

      it('autorise le domaine de courriel sans nom complet', async () => {
        const mockEvent = {
          request: {
            body: {},
          },
          user: {
            email: 'johndoe@test.com',
          },
        };

        await onExecutePreUserRegistration(mockEvent, mockApi);

        expect(mockApi.access.deny).not.toHaveBeenCalled();
        expect(mockApi.validation.error).toHaveBeenCalledWith('invalid_payload', 'Nom complet manquant');
        expect(mockApi.user.setUserMetadata).not.toHaveBeenCalled();
      });

      it('autorise le domaine de courriel avec nom complet', async () => {
        const mockEvent = {
          request: {
            body: {
              'ulp-fullName': 'John Doe'
            },
          },
          user: {
            email: 'johndoe@test.com',
          },
        };

        await onExecutePreUserRegistration(mockEvent, mockApi);

        expect(mockApi.access.deny).not.toHaveBeenCalled();
        expect(mockApi.validation.error).not.toHaveBeenCalled();
        expect(mockApi.user.setUserMetadata).toHaveBeenCalledWith('full_name', 'John Doe');
      });
    });
    ```
  </Tab>

  <Tab title="TypeScript">
    ```typescript
    const { onExecutePreUserRegistration } = require('./preUserRegistration');

    describe('onExecutePreUserRegistration', () => {
      const mockApi = {
        access: {
          deny: jest.fn(),
        },
        user: {
          setUserMetadata: jest.fn(),
        },
        validation: {
          error: jest.fn(),
        },
      };

      beforeEach(() => {
        jest.resetAllMocks();
      });

      afterEach(() => {
        jest.resetAllMocks();
      });

      it('interdit le domaine de courriel', async () => {
        const mockEvent = {
          user: {
            email: 'johndoe@example.com',
          }
        };

        await onExecutePreUserRegistration(mockEvent, mockApi);

        expect(mockApi.access.deny).toHaveBeenCalledWith('forbidden', 'Domaine de courriel interdit');
        expect(mockApi.validation.error).not.toHaveBeenCalled();
        expect(mockApi.user.setUserMetadata).not.toHaveBeenCalled();
      });

      it('autorise le domaine de courriel sans nom complet', async () => {
        const mockEvent = {
          request: {
            body: {},
          },
          user: {
            email: 'johndoe@test.com',
          },
        };

        await onExecutePreUserRegistration(mockEvent, mockApi);

        expect(mockApi.access.deny).not.toHaveBeenCalled();
        expect(mockApi.validation.error).toHaveBeenCalledWith('invalid_payload', 'Nom complet manquant');
        expect(mockApi.user.setUserMetadata).not.toHaveBeenCalled();
      });

      it('autorise le domaine de courriel avec nom complet', async () => {
        const mockEvent = {
          request: {
            body: {
              'ulp-fullName': 'John Doe'
            },
          },
          user: {
            email: 'johndoe@test.com',
          },
        };

        await onExecutePreUserRegistration(mockEvent, mockApi);

        expect(mockApi.access.deny).not.toHaveBeenCalled();
        expect(mockApi.validation.error).not.toHaveBeenCalled();
        expect(mockApi.user.setUserMetadata).toHaveBeenCalledWith('full_name', 'John Doe');
      });
    });
    ```
  </Tab>
</Tabs>

<div id="custom-email-provider-and-http-request">
  ## Fournisseur de courriel personnalisé et requête HTTP
</div>

L’exemple d’Action suivant tente d’envoyer un message au moyen d’une requête HTTP à un service externe, en gérant l’erreur de requête potentielle pour abandonner la notification. Il utilise des secrets pour l’URL du service externe et la clé d’API d’autorisation.

<Tabs>
  <Tab title="JavaScript">
    ```javascript
    /** @import {Event, CustomEmailProviderAPI} from "@auth0/actions/custom-email-provider/v1" */

    /**
    * Gestionnaire à exécuter lors de l’envoi d’une notification par courriel
    *
    * @param {Event} event - Détails concernant l’utilisateur et le contexte dans lequel il se connecte.
    * @param {CustomEmailProviderAPI} api - Méthodes et utilitaires pour aider à modifier le comportement d’envoi d’une notification par courriel.
    */
    exports.onExecuteCustomEmailProvider = async (event, api) => {
      const notification = event.notification;
      const message = {
        body: notification.html
      };

      try {
        await fetch(event.secrets.URL, {
          method: 'POST',
          headers: {
            'X-API-Key': event.secrets.API_KEY,
          },
          body: JSON.stringify(message),
        });
      } catch (err) {
        api.notification.drop('External service failure');
      }
    }

    ```
  </Tab>

  <Tab title="TypeScript">
    ```typescript
    /** @import {Event, CustomEmailProviderAPI} from "@auth0/actions/custom-email-provider/v1" */

    /**
    * Gestionnaire à exécuter lors de l’envoi d’une notification par courriel
    *
    * @param {Event} event - Détails concernant l’utilisateur et le contexte dans lequel il se connecte.
    * @param {CustomEmailProviderAPI} api - Méthodes et utilitaires pour aider à modifier le comportement d’envoi d’une notification par courriel.
    */
    exports.onExecuteCustomEmailProvider = async (event, api) => {
      const notification = event.notification;
      const message = {
        body: notification.html
      };

      try {
        await fetch(event.secrets.URL, {
          method: 'POST',
          headers: {
            'X-API-Key': event.secrets.API_KEY,
          },
          body: JSON.stringify(message),
        });
      } catch (err) {
        api.notification.drop('External service failure');
      }
    }

    ```
  </Tab>
</Tabs>

Le test unitaire effectue des validations pour maximiser la couverture du code, en simulant les objets event et api ainsi que la fonction fetch.

<Tabs>
  <Tab title="Javascript">
    ```javascript
    const { onExecuteCustomEmailProvider } = require('./customEmailProvider');

    describe('onExecuteCustomEmailProvider', () => {
      const mockApi = {
        notification: {
          drop: jest.fn(),
        },
      };

      const mockEvent = {
        notification: {
          html: '<h1>Hello world</h1>',
        },
        secrets: {
          URL: 'https://example.com/service',
          API_KEY: 'ApiKeySecret1234.',
        },
        user: {
          email: 'johndoe@example.com',
        },
      };

      beforeEach(() => {
        jest.resetAllMocks();
      });

      afterEach(() => {
        jest.resetAllMocks();
      });

      it('succeeds on external service request', async () => {
        jest.spyOn(global, 'fetch').mockImplementationOnce(() => Promise.resolve({
          ok: true,
          status: 200,
          json: async () => ({ message: 'Success!' }),
        }));

        await onExecuteCustomEmailProvider(mockEvent, mockApi);

        expect(global.fetch).toHaveBeenCalled();
        expect(mockApi.notification.drop).not.toHaveBeenCalled();
      });

      it('fails on external service request', async () => {
        jest.spyOn(global, 'fetch').mockImplementationOnce(() => Promise.reject({
          ok: false,
          status: 500,
          json: async () => ({ error: 'Server Error' }),
        }));

        await onExecuteCustomEmailProvider(mockEvent, mockApi);

        expect(mockApi.notification.drop).toHaveBeenCalledWith('External service failure');
      });
    });

    ```
  </Tab>

  <Tab title="TypeScript">
    ```typescript
    const { onExecuteCustomEmailProvider } = require('./customEmailProvider');

    describe('onExecuteCustomEmailProvider', () => {
      const mockApi = {
        notification: {
          drop: jest.fn(),
        },
      };

      const mockEvent = {
        notification: {
          html: '<h1>Hello world</h1>',
        },
        secrets: {
          URL: 'https://example.com/service',
          API_KEY: 'ApiKeySecret1234.',
        },
        user: {
          email: 'johndoe@example.com',
        },
      };

      beforeEach(() => {
        jest.resetAllMocks();
      });

      afterEach(() => {
        jest.resetAllMocks();
      });

      it('succeeds on external service request', async () => {
        jest.spyOn(global, 'fetch').mockImplementationOnce(() => Promise.resolve({
          ok: true,
          status: 200,
          json: async () => ({ message: 'Success!' }),
        } as Response));

        await onExecuteCustomEmailProvider(mockEvent, mockApi);

        expect(global.fetch).toHaveBeenCalled();
        expect(mockApi.notification.drop).not.toHaveBeenCalled();
      });

      it('fails on external service request', async () => {
        jest.spyOn(global, 'fetch').mockImplementationOnce(() => Promise.reject({
          ok: false,
          status: 500,
          json: async () => ({ error: 'Server Error' }),
        } as Response));

        await onExecuteCustomEmailProvider(mockEvent, mockApi);

        expect(mockApi.notification.drop).toHaveBeenCalledWith('External service failure');
      });
    });

    ```
  </Tab>
</Tabs>

Pour en savoir plus sur `@auth0/actions`, consultez https://www.npmjs.com/package/@auth0/actions.

Pour en savoir plus sur l’écriture d’Actions, consultez [Écrire votre première Action](/customize/actions/write-your-first-action).