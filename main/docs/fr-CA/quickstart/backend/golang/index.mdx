---
title: "API Go : autorisation"
permalink: "01-authorization"
---

import {AuthCodeBlock} from "/snippets/fr-CA/AuthCodeBlock.jsx";

<div id="by-sergiu-ghitea">
  ##### Par Sergiu Ghitea
</div>

Ce tutoriel montre comment ajouter l‚Äôautorisation √† une API Go. Nous vous recommandons d‚Äôouvrir une session pour suivre ce d√©marrage rapide avec des exemples configur√©s pour votre compte.

{/* <Card title="Voir sur GitHub" href="https://github.com/auth0-samples/auth0-golang-api-samples/tree/master/01-Authorization-RS256" icon="github">
  Exigences syst√®me : Go 1.21+
  </Card> */}

<Info>
  **Vous d√©butez avec Auth0?** D√©couvrez [comment fonctionne Auth0](/docs/fr-CA/get-started/auth0-overview) et informez-vous sur [l‚Äôimpl√©mentation de l‚Äôauthentification et de l‚Äôautorisation d‚ÄôAPI](/docs/fr-CA/get-started/authentication-and-authorization-flow) √† l‚Äôaide du cadre OAuth 2.0.
</Info>

<div id="configure-auth0-apis">
  ## Configurer les API d&#39;Auth0
</div>

<div id="create-an-api">
  ### Cr√©er une API
</div>

Dans la section [APIs](https://manage.auth0.com/#/apis) de l‚ÄôAuth0 Dashboard, cliquez sur **Create API**. Indiquez un nom et un identifiant pour votre API, par exemple `https://quickstarts/api`. Vous utiliserez cet identifiant comme `audience` plus tard, lorsque vous configurerez la v√©rification du jeton d‚Äôacc√®s. Laissez **Signing Algorithm** sur **RS256**.

<Frame>![Create API](https://cdn2.auth0.com/docs/1.14550.0/media/articles/server-apis/create-api.png)</Frame>

Par d√©faut, votre API utilise RS256 comme algorithme de signature des jetons. Comme RS256 repose sur une paire de cl√©s publique/priv√©e, il v√©rifie les jetons √† l‚Äôaide de la cl√© publique de votre compte Auth0. La cl√© publique est au format [JSON Web Key Set (JWKS)](/docs/fr-CA/secure/tokens/json-web-tokens/json-web-key-sets) et est accessible [ici](https://\{yourDomain}/.well-known/jwks.json).

<div id="define-permissions">
  ### D√©finir des permissions
</div>

Les permissions vous permettent de d√©finir comment les ressources peuvent √™tre consult√©es au nom de l‚Äôutilisateur avec un jeton d‚Äôacc√®s donn√©. Par exemple, vous pouvez choisir d‚Äôaccorder un acc√®s en lecture √† la ressource `messages` si les utilisateurs disposent du niveau d‚Äôacc√®s gestionnaire, et un acc√®s en √©criture √† cette ressource s‚Äôils disposent du niveau d‚Äôacc√®s administrateur.

Vous pouvez d√©finir les permissions autoris√©es dans la vue **Permissions** de la section [APIs](https://manage.auth0.com/#/apis) de l‚ÄôAuth0 Dashboard.

<Frame>![Configurer les permissions](https://cdn2.auth0.com/docs/1.14550.0/media/articles/server-apis/configure-permissions.png)</Frame>

<Info>
  Cet exemple utilise la port√©e `read:messages`.
</Info>

Cet exemple montre¬†:

* Comment v√©rifier la pr√©sence d‚Äôun JSON Web Token (JWT) dans l‚Äôen-t√™te `Authorization` d‚Äôune requ√™te HTTP entrante.
* Comment v√©rifier si le jeton est valide √† l‚Äôaide de l‚Äôensemble de cl√©s JSON Web (JWKS) ([JSON Web Key Set (JWKS)](/docs/fr-CA/secure/tokens/json-web-tokens/json-web-key-sets)) pour votre compte Auth0. Pour en savoir plus sur la validation des jetons d‚Äôacc√®s, consultez [Valider les jetons d‚Äôacc√®s](/docs/fr-CA/secure/tokens/access-tokens/validate-access-tokens).

<div id="validate-access-tokens">
  ## Valider les jetons d&#39;acc√®s
</div>

<div id="download-dependencies">
  ### T√©l√©charger les d√©pendances
</div>

Ajoutez un fichier `go.mod` pour lister toutes les d√©pendances requises.

```go Go lines
// go.mod

module 01-Authorization-RS256

go 1.21

require (
	github.com/auth0/go-jwt-middleware/v2 v2.2.0
	github.com/joho/godotenv v1.5.1
)
```

Installez les d√©pendances en ex√©cutant la commande suivante dans votre terminal¬†:

```bash lines
go mod download
```

<div id="configure-your-application">
  ### Configurer votre application
</div>

Cr√©ez un fichier `.env` √† la racine du r√©pertoire de votre projet pour stocker la configuration de l&#39;application, puis d√©finissez les variables d&#39;environnement¬†:

export const codeExample = `# L'URL du domaine de notre tenant Auth0.
# Si vous utilisez un Domaine personnalis√©, assurez-vous plut√¥t de d√©finir cette variable avec ce domaine.
AUTH0_DOMAIN='{yourDomain}'

# L'identifiant de notre API Auth0.
AUTH0_AUDIENCE='YOUR_API_IDENTIFIER'`;

<AuthCodeBlock children={codeExample} language="bash" />

<div id="create-a-middleware-to-validate-access-tokens">
  ### Cr√©er un middleware pour valider les jetons d&#39;acc√®s
</div>

La validation des jetons d&#39;acc√®s sera effectu√©e dans la fonction middleware `EnsureValidToken`, qui peut √™tre appliqu√©e aux endpoints que vous souhaitez prot√©ger. Si le jeton est valide, les ressources servies par l&#39;endpoint peuvent √™tre renvoy√©es, sinon une erreur `401 Authorization` sera retourn√©e.

Configurez le middleware **go-jwt-middleware** pour v√©rifier les jetons d&#39;acc√®s des requ√™tes entrantes.

```go Go lines
// middleware/jwt.go

package middleware

import (
	"context"
	"log"
	"net/http"
	"net/url"
	"os"
	"time"

	jwtmiddleware "github.com/auth0/go-jwt-middleware/v2"
	"github.com/auth0/go-jwt-middleware/v2/jwks"
	"github.com/auth0/go-jwt-middleware/v2/validator"
)

// CustomClaims contient les donn√©es personnalis√©es que nous souhaitons obtenir du jeton.
type CustomClaims struct {
	Scope string `json:"scope"`
}

// Validate ne fait rien dans cet exemple, mais nous en avons besoin
// pour satisfaire l'interface validator.CustomClaims.
func (c CustomClaims) Validate(ctx context.Context) error {
	return nil
}

// EnsureValidToken est un intergiciel qui v√©rifie la validit√© de notre JWT.
func EnsureValidToken() func(next http.Handler) http.Handler {
	issuerURL, err := url.Parse("https://" + os.Getenv("AUTH0_DOMAIN") + "/")
	if err != nil {
		log.Fatalf("√âchec de l'analyse de l'URL de l'√©metteur : %v", err)
	}

	provider := jwks.NewCachingProvider(issuerURL, 5*time.Minute)

	jwtValidator, err := validator.New(
		provider.KeyFunc,
		validator.RS256,
		issuerURL.String(),
		[]string{os.Getenv("AUTH0_AUDIENCE")},
		validator.WithCustomClaims(
			func() validator.CustomClaims {
				return &CustomClaims{}
			},
		),
		validator.WithAllowedClockSkew(time.Minute),
	)
	if err != nil {
		log.Fatalf("√âchec de la configuration du validateur JWT")
	}

	errorHandler := func(w http.ResponseWriter, r *http.Request, err error) {
		log.Printf("Erreur rencontr√©e lors de la validation du JWT : %v", err)

		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(http.StatusUnauthorized)
		w.Write([]byte(`{"message":"√âchec de la validation du JWT."}`))
	}

	middleware := jwtmiddleware.New(
		jwtValidator.ValidateToken,
		jwtmiddleware.WithErrorHandler(errorHandler),
	)

	return func(next http.Handler) http.Handler {
		return middleware.CheckJWT(next)
	}
}
```

Par d√©faut, votre API utilise RS256 comme algorithme de signature des jetons. √âtant donn√© que RS256 repose sur une paire de cl√©s priv√©e/publique, les jetons sont v√©rifi√©s √† l&#39;aide de la cl√© publique de votre compte Auth0. La cl√© publique est au format [JSON Web Key Set (JWKS)](/docs/fr-CA/secure/tokens/json-web-tokens/json-web-key-sets) et peut √™tre consult√©e [ici](https://\{yourDomain}/.well-known/jwks.json).

<div id="protect-api-endpoints">
  ## Prot√©ger les points de terminaison de l‚ÄôAPI
</div>

Pour prot√©ger des routes individuelles, passez le `middleware` (d√©fini ci-dessus) √† la route HTTP.

```go Go lines
// main.go

package main

import (
	"log"
	"net/http"

	"github.com/joho/godotenv"

	"01-Authorization-RS256/middleware"
)

func main() {
	if err := godotenv.Load(); err != nil {
		log.Fatalf("Erreur lors du chargement du fichier .env : %v", err)
	}

	router := http.NewServeMux()

	// Cette route est toujours accessible.
	router.Handle("/api/public", http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(http.StatusOK)
		w.Write([]byte(`{"message":"Bonjour d'un point de terminaison public! Vous n'avez pas besoin d'√™tre authentifi√© pour voir ceci."}`))
	}))

	// Cette route est accessible uniquement si l'utilisateur poss√®de un access_token valide.
	router.Handle("/api/private", middleware.EnsureValidToken()(
		http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			// En-t√™tes CORS.
			w.Header().Set("Access-Control-Allow-Credentials", "true")
			w.Header().Set("Access-Control-Allow-Origin", "http://localhost:3000")
			w.Header().Set("Access-Control-Allow-Headers", "Authorization")

			w.Header().Set("Content-Type", "application/json")
			w.WriteHeader(http.StatusOK)
			w.Write([]byte(`{"message":"Bonjour d'un point de terminaison priv√©! Vous devez √™tre authentifi√© pour voir ceci."}`))
		}),
	))

	log.Print("Serveur en √©coute sur http://localhost:3010")
	if err := http.ListenAndServe("0.0.0.0:3010", router); err != nil {
		log.Fatalf("Une erreur s'est produite avec le serveur http : %v", err)
	}
}
```

<div id="validate-scopes">
  ### Valider les scopes
</div>

Le `middleware` ci-dessus v√©rifie que le jeton d‚Äôacc√®s inclus dans la requ√™te est valide ; cependant, il n‚Äôinclut pas encore
de m√©canisme pour v√©rifier que le jeton poss√®de la **port√©e** suffisante pour acc√©der aux ressources demand√©es.

Cr√©ez une fonction pour v√©rifier et vous assurer que le jeton d‚Äôacc√®s a la port√©e appropri√©e avant de renvoyer une r√©ponse r√©ussie.

```go Go lines
// üëÜ Nous poursuivons √† partir des √©tapes ci-dessus. Ajoutez ceci √† votre fichier middleware/jwt.go.

// HasScope v√©rifie si nos revendications contiennent une port√©e sp√©cifique.
func (c CustomClaims) HasScope(expectedScope string) bool {
    result := strings.Split(c.Scope, " ")
    for i := range result {
        if result[i] == expectedScope {
            return true
        }
    }

    return false
}
```

Utilisez cette fonction dans le point de terminaison d‚ÄôAPI qui requiert la port√©e `read:messages`.

```go Go lines
// üëÜ Nous poursuivons √† partir des √©tapes ci-dessus. Ajoutez ceci √† votre fichier main.go.

func main() {
    // ...
    
    // Cette route n'est accessible que si l'utilisateur poss√®de un
    // access_token valide avec la port√©e read:messages.
	router.Handle("/api/private-scoped", middleware.EnsureValidToken()(
		http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			// En-t√™tes CORS.
			w.Header().Set("Access-Control-Allow-Credentials", "true")
			w.Header().Set("Access-Control-Allow-Origin", "http://localhost:3000")
			w.Header().Set("Access-Control-Allow-Headers", "Authorization")

			w.Header().Set("Content-Type", "application/json")

			token := r.Context().Value(jwtmiddleware.ContextKey{}).(*validator.ValidatedClaims)

			claims := token.CustomClaims.(*middleware.CustomClaims)
			if !claims.HasScope("read:messages") {
				w.WriteHeader(http.StatusForbidden)
				w.Write([]byte(`{"message":"Insufficient scope."}`))
				return
			}

			w.WriteHeader(http.StatusOK)
			w.Write([]byte(`{"message":"Hello from a private endpoint! You need to be authenticated to see this."}`))
		}),
	))
    
    // ...
}
```

Dans cet exemple, seule la port√©e `read:messages` est v√©rifi√©e. Vous pouvez choisir d&#39;√©tendre la fonction `HasScope` ou d&#39;en faire un middleware autonome qui accepte plusieurs scopes afin qu&#39;elle s&#39;adapte √† votre cas d&#39;utilisation.

<Info>
  ##### Que pouvez-vous faire ensuite ?

  <table>
    <tr>
      <td><a href="/docs/fr-CA/authenticate/identity-providers">Configurer d&#39;autres fournisseurs d&#39;identit√©</a></td>
      <td><a href="/docs/fr-CA/secure/multi-factor-authentication">Activer l&#39;authentification multifactorielle</a></td>
    </tr>

    <tr>
      <td><a href="/docs/fr-CA/secure/attack-protection">En savoir plus sur la protection contre les attaques</a></td>
      <td><a href="/docs/fr-CA/customize/rules">En savoir plus sur Rules</a></td>
    </tr>
  </table>

  [Modifier sur GitHub](https://github.com/auth0/docs/edit/master/articles/quickstart/backend/aspnet-core-webapi/01-authorization.md)
</Info>

***
