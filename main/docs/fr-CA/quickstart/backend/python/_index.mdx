---
title: Ajouter l’autorisation à votre Application API Flask
sidebarTitle: API Python

---

import { Recipe, Content, Section, SideMenu, SideMenuSectionItem, SignUpForm } from "/snippets/fr-CA/recipe.jsx";
import { LoggedInForm } from "/snippets/fr-CA/Login.jsx";
import Validator from "/snippets/fr-CA/quickstart/backend/python/validator.py.mdx";
import Server from "/snippets/fr-CA/quickstart/backend/python/server.py.mdx";

import {AuthCodeGroup} from "/snippets/fr-CA/AuthCodeGroup.jsx";

export const sections = [
  { id: "define-permissions", title: "Définir les autorisations" },
  { id: "install-dependencies", title: "Installer les dépendances" },
  { id: "create-the-jwt-validator", title: "Créer le validateur JWT" },
  { id: "create-a-flask-application", title: "Créer une application Flask" }
]


<Recipe isSingleColumn>
  <Content>
    Ce guide montre comment intégrer Auth0 avec toute API Python nouvelle ou existante construite avec [Flask](https://flask.palletsprojects.com/).

    Si vous n&#39;avez pas encore créé d&#39;API dans votre Auth0 Dashboard, vous pouvez utiliser le sélecteur interactif pour créer une nouvelle API Auth0 ou sélectionner une API existante qui représente le projet que vous souhaitez intégrer.

    Vous pouvez également consulter [notre guide de démarrage](https://auth0.com/docs/get-started/auth0-overview/set-up-apis) qui vous aide à configurer votre première API à partir du Auth0 Dashboard.

    Chaque API dans Auth0 est configurée à l&#39;aide d&#39;un identifiant d&#39;API que le code de votre application utilisera comme audience pour valider le jeton d&#39;accès.

    <Info>
      **Nouveau chez Auth0?** Découvrez [comment fonctionne Auth0](https://auth0.com/docs/overview)
      et comment [implémenter l’authentification
      et l’autorisation d’API](https://auth0.com/docs/api-auth) à l’aide du cadre OAuth 2.0.
    </Info>

    <Section id={sections[0].id} title={sections[0].title} stepNumber="1" isSingleColumn>
      Les autorisations vous permettent de définir comment les ressources peuvent être consultées au nom de l’utilisateur avec un jeton d’accès donné. Par
      exemple, vous pourriez choisir d’accorder un accès en lecture à la ressource `messages` si les utilisateurs ont le niveau d’accès gestionnaire
      et un accès en écriture à cette ressource s’ils ont le niveau d’accès administrateur.

      Vous pouvez définir les autorisations possibles dans la vue **Permissions** de la section [APIs](https://manage.auth0.com/#/apis) de l’Auth0 Dashboard.

      <Frame>
        <img src="/docs/images/cdy7uua7fh8z/1s3Yp5zqJiKiSWqbPSezNO/e61793a2822d095666002c3f65c71ac2/configure-permissions.png" />
      </Frame>

      <Info>
        Cet exemple utilise la portée `read:messages`.
      </Info>

      <LoggedInForm />
    </Section>

    <Section id={sections[1].id} title={sections[1].title} stepNumber="2" isSingleColumn>
      Ajoutez les dépendances suivantes dans votre fichier `requirements.txt` :

      ```txt lines
      # /requirements.txt
      flask

      Authlib
      ```

      <LoggedInForm />
    </Section>

    <Section id={sections[2].id} title={sections[2].title} stepNumber="3" isSingleColumn>
      Nous allons utiliser une bibliothèque appelée [Authlib](https://github.com/lepture/authlib) pour créer un [ResourceProtector](https://docs.authlib.org/en/latest/flask/1/resource-server.html), qui est un type de [décorateur Flask](https://flask.palletsprojects.com/patterns/viewdecorators/) qui protège nos ressources (routes d’API) à l’aide d’un validateur donné.

      Le validateur validera le jeton d’accès que nous transmettons à la ressource en vérifiant qu’il possède une signature et des claims valides.

      Nous pouvons utiliser le validateur `JWTBearerTokenValidator` d’Authlib avec quelques ajustements pour nous assurer qu’il est conforme à nos exigences de [validation des jetons d’accès](https://auth0.com/docs/secure/tokens/access-tokens/validate-access-tokens).

      Pour créer notre `Auth0JWTBearerTokenValidator`, nous devons lui transmettre notre `domain` et notre
      `audience` (identifiant d’API). Il récupérera ensuite la clé publique requise pour vérifier la signature du jeton
      et la transmettra à la classe `JWTBearerTokenValidator`.

      Nous allons ensuite surcharger la propriété `claims_options` de la classe pour nous assurer que les claims d’expiration, d’audience et d’émetteur du jeton sont validés selon nos exigences.

      <AuthCodeGroup>
        <Validator />

        <Server />
      </AuthCodeGroup>
    </Section>

    <Section id={sections[3].id} title={sections[3].title} stepNumber="4" isSingleColumn>
      Ensuite, nous allons créer une application Flask avec 3 routes API :

      * `/api/public` Un point d&#39;accès public qui ne nécessite aucune authentification.
      * `/api/private`Un point de terminaison privé qui nécessite un jeton d’accès JWT valide.
      * `/api/private-scoped` Un point de terminaison privé qui exige un JWT de jeton d’accès valide contenant la
        portée `scope` indiquée.

      Les routes protégées comporteront un décorateur `require_auth` qui est un `ResourceProtector`
      utilisant le `Auth0JWTBearerTokenValidator` créé précédemment.

      Pour créer le `Auth0JWTBearerTokenValidator`, nous lui passerons le domaine de notre tenant et l&#39;identifiant de l&#39;API
      que nous avons créée précédemment.

      Le décorateur `require_auth` sur la route `private_scoped` accepte un argument supplémentaire
      `"read:messages"`, qui vérifie dans le jeton d&#39;accès la présence de la permission (portée) que nous avons créée précédemment.

      ### Effectuer un appel à votre API

      Pour effectuer des appels à votre API, vous avez besoin d&#39;un jeton d&#39;accès. Vous pouvez obtenir un jeton d&#39;accès à des fins de test dans la vue
      **Test** de vos [paramètres
      d&#39;API](https://manage.auth0.com/#/apis).

      <Frame>
        <img src="/docs/images/cdy7uua7fh8z/6jeVBuypOGX5qMRXeJn5ow/5e79037f6c852d2043789d622bdb9562/Quickstart_Example_App_-_English.png" />
      </Frame>

      Fournissez le jeton d&#39;accès comme en-tête `Authorization` dans vos requêtes.

      <AuthCodeGroup>
        ```bash cURL lines
        curl --request get \
        --url 'http:///%7ByourDomain%7D/api_path' \
        --header 'authorization: Bearer YOUR_ACCESS_TOKEN_HERE'
        ```

        ```csharp C# lines
        var client = new RestClient("http:///%7ByourDomain%7D/api_path");
        var request = new RestRequest(Method.GET);
        request.AddHeader("authorization", "Bearer YOUR_ACCESS_TOKEN_HERE");
        IRestResponse response = client.Execute(request);
        ```

        ```go Go lines
        package main
        import (
        "fmt"
        "net/http"
        "io/ioutil"
        )
        func main() {
        url := "http:///%7ByourDomain%7D/api_path"
        req, _ := http.NewRequest("get", url, nil)
        req.Header.Add("authorization", "Bearer VOTRE_JETON_ACCES_ICI")
        res, _ := http.DefaultClient.Do(req)
        defer res.Body.Close()
        body, _ := ioutil.ReadAll(res.Body)
        fmt.Println(res)
        fmt.Println(string(body))
        }
        ```

        ```java Java lines
        HttpResponse<String> response = Unirest.get("http:///%7ByourDomain%7D/api_path")
        .header("authorization", "Bearer YOUR_ACCESS_TOKEN_HERE")
        .asString();
        ```

        ```javascript Node.JS lines
        var axios = require("axios").default;
        var options = {
        method: 'get',
        url: 'http:///%7ByourDomain%7D/api_path',
        headers: {authorization: 'Bearer VOTRE_JETON_ACCES_ICI'}
        };
        axios.request(options).then(function (response) {
        console.log(response.data);
        }).catch(function (error) {
        console.error(error);
        });
        ```

        ```objc Obj-C lines
        #import <Foundation/Foundation.h>
        NSDictionary *headers = @{ @"authorization": @"Bearer VOTRE_JETON_D_ACCES_ICI" };
        NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@"http:///%7ByourDomain%7D/api_path"]
                                                        cachePolicy:NSURLRequestUseProtocolCachePolicy

                                                    timeoutInterval:10.0];

        [request setHTTPMethod:@"get"];
        [request setAllHTTPHeaderFields:headers];
        NSURLSession *session = [NSURLSession sharedSession];
        NSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request
                                                completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {

                                                    if (error) {

                                                        NSLog(@&quot;%@&quot;, error);

                                                    } else {

                                                        NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;

                                                        NSLog(@&quot;%@&quot;, httpResponse);

                                                    }

                                                }];

        [dataTask resume];
        ```

        ```php PHP lines
        #import <Foundation/Foundation.h>
        NSDictionary *headers = @{ @"authorization": @"Bearer VOTRE_JETON_D_ACCES_ICI" };
        NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@"http:///%7ByourDomain%7D/api_path"]
                                                        cachePolicy:NSURLRequestUseProtocolCachePolicy

                                                    timeoutInterval:10.0];

        [request setHTTPMethod:@"get"];
        [request setAllHTTPHeaderFields:headers];
        NSURLSession *session = [NSURLSession sharedSession];
        NSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request
                                                completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {

                                                    if (error) {

                                                        NSLog(@&quot;%@&quot;, error);

                                                    } else {

                                                        NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;

                                                        NSLog(@&quot;%@&quot;, httpResponse);

                                                    }

                                                }];

        [dataTask resume];
        ```

        ```python Python lines
        import http.client
        conn = http.client.HTTPConnection("")
        headers = { 'authorization': "Bearer VOTRE_JETON_ACCES_ICI" }
        conn.request("get", "/%7ByourDomain%7D/api_path", headers=headers)
        res = conn.getresponse()
        data = res.read()
        print(data.decode("utf-8"))
        ```

        ```ruby Ruby lines
        require 'uri'
        require 'net/http'
        url = URI("http:///%7ByourDomain%7D/api_path")
        http = Net::HTTP.new(url.host, url.port)
        request = Net::HTTP::Get.new(url)
        request["authorization"] = 'Bearer YOUR_ACCESS_TOKEN_HERE'
        response = http.request(request)
        puts response.read_body
        ```

        ```swift Swift lines
        import Foundation
        let headers = ["authorization": "Bearer VOTRE_JETON_ACCES_ICI"]
        let request = NSMutableURLRequest(url: NSURL(string: "http:///%7ByourDomain%7D/api_path")! as URL,
                                            cachePolicy: .useProtocolCachePolicy,

                                        timeoutInterval: 10.0)

        request.httpMethod = "get"
        request.allHTTPHeaderFields = headers
        let session = URLSession.shared
        let dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in
        if (error != nil) {
        print(error)

        } else {
        let httpResponse = response as? HTTPURLResponse

        print(httpResponse)

        }
        })
        dataTask.resume()
        ```
      </AuthCodeGroup>

      <AuthCodeGroup>
        <Server />

        <Validator />
      </AuthCodeGroup>
    </Section>

    ## Prochaines étapes

    Excellent travail! Si vous vous êtes rendu jusqu&#39;ici, vous devriez maintenant avoir la connexion, la déconnexion et les informations de profil utilisateur qui fonctionnent dans votre application.

    Ce tutoriel de démarrage rapide est maintenant terminé, mais il reste encore beaucoup à découvrir. Pour en savoir plus sur ce que vous pouvez faire avec Auth0, consultez :

    * [Auth0 Dashboard](https://manage.auth0.com/dashboard/us/dev-gja8kxz4ndtex3rq) - Découvrez comment configurer et gérer votre tenant Auth0 et vos Applications Auth0
    * [Trousse de développement logiciel (SDK) auth0-python](https://github.com/auth0/auth0-python) - Explorez plus en détail la trousse de développement logiciel (SDK) utilisée dans ce tutoriel
    * [Auth0 Marketplace](https://marketplace.auth0.com/) - Découvrez les intégrations à activer pour étendre les fonctionnalités d’Auth0
  </Content>
</Recipe>