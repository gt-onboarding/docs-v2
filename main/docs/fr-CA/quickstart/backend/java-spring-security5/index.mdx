---
title: "API Spring Boot : autorisation"
permalink: "01-authorization"
---

import {AuthCodeBlock} from "/snippets/fr-CA/AuthCodeBlock.jsx";

<div id="by-jim-anderson">
  ##### Par Jim Anderson
</div>

Ce tutoriel explique comment ajouter une autorisation à une API à l&#39;aide d&#39;Okta Spring Boot Starter. Nous vous recommandons de vous connecter pour suivre ce démarrage rapide avec des exemples configurés pour votre compte.

{/* <Card title="Voir sur GitHub" href="https://github.com/auth0-samples/auth0-spring-security5-api-sample/tree/master/01-Authorization-MVC" icon="github">
  Configuration système requise : Java 17
  </Card> */}

Cet exemple illustre :

* Comment vérifier la présence d’un JSON Web Token (JWT) dans l’en-tête `Authorization` d’une requête HTTP entrante.
* Comment vérifier si le jeton est valide, en utilisant le [JSON Web Key Set (JWKS)](/docs/fr-CA/secure/tokens/json-web-tokens/json-web-key-sets) de votre compte Auth0. Pour en savoir plus sur la validation des jetons d’accès, consultez [Validate Access Tokens](/docs/fr-CA/secure/tokens/access-tokens/validate-access-tokens).

<Info>
  **Nouveau sur Auth0 ?** Découvrez [le fonctionnement d’Auth0](/docs/fr-CA/get-started/auth0-overview) et lisez la documentation sur [la mise en œuvre de l’authentification et de l’autorisation d’API](/docs/fr-CA/get-started/authentication-and-authorization-flow) à l’aide du cadre OAuth 2.0.
</Info>

<Info>
  Ce Démarrage rapide utilise Spring MVC. Si vous utilisez Spring WebFlux, les étapes pour sécuriser une API sont similaires, mais certains détails d’implémentation diffèrent. Consultez l’[exemple de code Spring Security WebFlux](https://github.com/auth0-samples/auth0-spring-security5-api-sample/tree/master/01-Authorization-WebFlux) pour voir comment intégrer Auth0 à votre API Spring WebFlux.
</Info>

<div id="configure-auth0-apis">
  ## Configurer les API d&#39;Auth0
</div>

<div id="create-an-api">
  ### Créer une API
</div>

Dans la section [APIs](https://manage.auth0.com/#/apis) du Auth0 Dashboard, cliquez sur **Create API**. Indiquez un nom et un identifiant pour votre API, par exemple `https://quickstarts/api`. Vous utiliserez cet identifiant comme `audience` plus tard, lors de la configuration de la vérification du jeton d&#39;accès. Laissez **Signing Algorithm** sur **RS256**.

<Frame>![Créer une API](https://cdn2.auth0.com/docs/1.14550.0/media/articles/server-apis/create-api.png)</Frame>

Par défaut, votre API utilise RS256 comme algorithme pour signer les jetons. Comme RS256 utilise une paire de clés privée/publique, les jetons sont vérifiés à l&#39;aide de la clé publique de votre compte Auth0. La clé publique est au format [JSON Web Key Set (JWKS)](/docs/fr-CA/secure/tokens/json-web-tokens/json-web-key-sets) et est accessible [ici](https://\{yourDomain}/.well-known/jwks.json).

<div id="define-permissions">
  ### Définir des permissions
</div>

Les permissions vous permettent de définir comment les ressources peuvent être consultées ou modifiées au nom de l’utilisateur à l’aide d’un jeton d’accès donné. Par exemple, vous pourriez choisir d’accorder un accès en lecture à la ressource `messages` si les utilisateurs ont le niveau d’accès gestionnaire, et un accès en écriture à cette ressource s’ils ont le niveau d’accès administrateur.

Vous pouvez définir les permissions autorisées dans la vue **Permissions** de la section [APIs](https://manage.auth0.com/#/apis) de l’Auth0 Dashboard.

<Frame>![Configure Permissions](https://cdn2.auth0.com/docs/1.14550.0/media/articles/server-apis/configure-permissions.png)</Frame>

<Info>
  Cet exemple utilise la portée `read:messages`.
</Info>

<div id="configure-the-sample-project">
  ## Configurer le projet d’exemple
</div>

Le projet d’exemple utilise un fichier `/src/main/resources/application.yml`, dans lequel sont configurés le **Domaine** Auth0 et l’**identifiant d’API** appropriés pour votre API. Si vous téléchargez le code à partir de cette page, il sera configuré automatiquement. Si vous clonez l’exemple à partir de GitHub, vous devrez renseigner ces valeurs vous-même.

export const codeExample = `okta:
  oauth2:
    # Remplacez par le domaine de votre tenant Auth0.
    issuer: https://{yourDomain}/
    # Remplacez par l'identificateur (API Identifier) de votre API Auth0.
    audience: {yourApiIdentifier}`;

<AuthCodeBlock children={codeExample} language="yml" />

<table class="table">
  <thead>
    <tr>
      <th>Attribut</th>
      <th>Description</th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td><code>okta.oauth2.audience</code></td>
      <td>L&#39;identifiant unique de votre API. Si vous suivez les étapes de ce tutoriel, il correspondrait à <code>[https://quickstarts/api](https://quickstarts/api)</code>.</td>
    </tr>

    <tr>
      <td><code>okta.oauth2.issuer</code></td>
      <td>L&#39;URI d&#39;émetteur du serveur de ressources, qui sera la valeur de la revendication <code>iss</code> dans le JWT émis par Auth0. Spring Security utilisera cette propriété pour découvrir les clés publiques du serveur d&#39;autorisation et valider la signature du JWT. La valeur sera votre domaine Auth0 avec un préfixe <code>https://</code> et un suffixe <code>/</code> (la barre oblique finale est importante).</td>
    </tr>
  </tbody>
</table>

<div id="install-dependencies">
  ## Installer les dépendances
</div>

Si vous utilisez Gradle, vous pouvez ajouter les dépendances requises à l&#39;aide du [Spring Boot Gradle Plugin](https://docs.spring.io/spring-boot/docs/current/gradle-plugin/reference/html/) et du [Dependency Management Plugin](https://docs.spring.io/dependency-management-plugin/docs/current/reference/html/) afin de gérer les versions des dépendances :

```gradle lines
// build.gradle

plugins {
    id 'java'
    id 'org.springframework.boot' version '3.1.5'
    id 'io.spring.dependency-management' version '1.1.3'
}

dependencies {
    implementation 'org.springframework.boot:spring-boot-starter-web'
    implementation 'com.okta.spring:okta-spring-boot-starter:3.0.5'
}
```

Si vous utilisez Maven, ajoutez les dépendances Spring à votre fichier `pom.xml` :

```xml lines
// pom.xml

<parent>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-parent</artifactId>
    <version>3.1.5</version>
    <relativePath/>
</parent>

<dependencies>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-web</artifactId>
    </dependency>
    <dependency>
        <groupId>com.okta</groupId>
        <artifactId>okta-spring-boot-starter</artifactId>
        <version>3.0.5</version>
    </dependency>
</dependencies>
```

<div id="protect-api-endpoints">
  ## Protéger les points de terminaison d’API
</div>

Les routes ci-dessous sont accessibles pour les requêtes suivantes :

* `GET /api/public` : disponible pour les requêtes non authentifiées
* `GET /api/private` : disponible pour les requêtes authentifiées contenant un jeton d’accès sans scopes supplémentaires
* `GET /api/private-scoped` : disponible pour les requêtes authentifiées contenant un jeton d’accès auquel la portée `read:messages` a été accordée

Pour configurer l’application comme serveur de ressources (Resource Server) et valider les JWT, créez une classe qui va enregistrer un [SecurityFilterChain](https://docs.spring.io/spring-security/site/docs/current/api/org/springframework/security/web/SecurityFilterChain.html), une instance de `SecurityFilterChain`, et ajoutez l’annotation `@Configuration`.

L’exemple ci-dessous montre comment sécuriser les méthodes d’API à l’aide de l’objet `HttpSecurity` fourni dans la méthode `filterChain()` de la classe `SecurityConfig`. Les route matchers sont utilisés pour restreindre l’accès selon le niveau d’autorisation requis :

```java Java lines
// src/main/java/com/auth0/example/security/SecurityConfig.java

import org.springframework.context.annotation.Bean;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.web.SecurityFilterChain;

@EnableWebSecurity
public class SecurityConfig {

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http.authorizeRequests()
                .mvcMatchers("/api/public").permitAll()
                .mvcMatchers("/api/private").authenticated()
                .mvcMatchers("/api/private-scoped").hasAuthority("SCOPE_read:messages")
                .and().cors()
                .and().oauth2ResourceServer().jwt();
        return http.build();
    }
}
```

<Info>
  Par défaut, Spring Security crée un `GrantedAuthority` pour chaque portée présente dans la revendication `scope` du JWT. C’est ce qui permet d’utiliser la méthode `hasAuthority("SCOPE_read:messages")` pour restreindre l’accès à un JWT valide qui inclut la portée `read:messages`.
</Info>

<div id="create-the-api-controller">
  ### Créer le contrôleur d’API
</div>

Créez un nouvel enregistrement nommé `Message`, qui sera l’objet de domaine que l’API renverra :

```java Java lines
// src/main/java/com/auth0/example/model/Message.java

public record Message(String message) {}
```

Créez une nouvelle classe nommée `APIController` pour gérer les requêtes adressées aux points de terminaison :

```java Java lines
// src/main/java/com/auth0/example/web/APIController.java

import com.auth0.example.model.Message;
import org.springframework.http.MediaType;
import org.springframework.web.bind.annotation.CrossOrigin;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

/**
 * Gère les requêtes vers les points de terminaison « /api ».
 * @see com.auth0.example.security.SecurityConfig pour voir comment ces points de terminaison sont protégés.
 */
@RestController
@RequestMapping(path = "api", produces = MediaType.APPLICATION_JSON_VALUE)
// Par souci de simplicité pour cet exemple, toutes les origines sont autorisées. Les applications réelles doivent configurer CORS selon leur cas d'utilisation.
@CrossOrigin(origins = "*")
public class APIController {

    @GetMapping(value = "/public")
    public Message publicEndpoint() {
        return new Message("Tout va bien. Vous N'AVEZ PAS besoin d'être authentifié pour appeler /api/public.");
    }

    @GetMapping(value = "/private")
    public Message privateEndpoint() {
        return new Message("Tout va bien. Vous pouvez voir ceci car vous êtes authentifié.");
    }

    @GetMapping(value = "/private-scoped")
    public Message privateScopedEndpoint() {
        return new Message("Tout va bien. Vous pouvez voir ceci car vous êtes authentifié avec un jeton ayant la portée « read:messages »");
    }
}
```

<div id="run-the-application">
  ## Exécuter l’application
</div>

Pour compiler et exécuter le projet d’exemple, exécutez la tâche Gradle `bootRun`.

Linux ou macOS :

```bash lines
./gradlew bootRun
```

Windows :

```bash lines
gradlew.bat bootRun
```

Si vous configurez votre propre application à l&#39;aide de Maven et du [Spring Boot Maven Plugin](https://docs.spring.io/spring-boot/docs/current/reference/html/build-tool-plugins-maven-plugin.html), vous pouvez exécuter l&#39;objectif `spring-boot:run`.

Linux ou macOS :

```bash lines
mvn spring-boot:run
```

Windows :

```bash lines
mvn.cmd spring-boot:run
```

L’application d’exemple sera accessible à l’adresse `http://localhost:3010/`. Pour savoir comment tester et utiliser votre API, consultez l’article [Utiliser votre API](/docs/fr-CA/quickstart/backend/java-spring-security5/02-using).

<Info>
  ##### Que pouvez-vous faire ensuite ?

  [Partie 2 : Utiliser votre API](/docs/fr-CA/quickstart/backend/java-spring-security5/02-using)

  [Modifier sur GitHub](https://github.com/auth0/docs/edit/master/articles/quickstart/backend/java-spring-security5/01-authorization.md)
</Info>

***
