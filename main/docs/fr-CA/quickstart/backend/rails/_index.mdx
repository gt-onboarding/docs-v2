---
title: Ajouter l’autorisation à votre API Ruby on Rails
sidebarTitle: API Ruby on Rails

---

import { Recipe, Content, Section, SideMenu, SideMenuSectionItem, SignUpForm } from "/snippets/fr-CA/recipe.jsx";
import { LoggedInForm } from "/snippets/fr-CA/Login.jsx";
import ApplicationController from "/snippets/fr-CA/quickstart/backend/rails/application_controller.rb.mdx";
import Auth0Client from "/snippets/fr-CA/quickstart/backend/rails/auth0_client.rb.mdx";
import Secured from "/snippets/fr-CA/quickstart/backend/rails/secured.rb.mdx";
import PublicController from "/snippets/fr-CA/quickstart/backend/rails/public_controller.rb.mdx";
import PrivateController from "/snippets/fr-CA/quickstart/backend/rails/private_controller.rb.mdx";

import {AuthCodeGroup} from "/snippets/fr-CA/AuthCodeGroup.jsx";

export const sections = [
  { id: "define-permissions", title: "Définir les autorisations" },
  { id: "install-dependencies", title: "Installer les dépendances" },
  { id: "create-an-auth0client-class", title: "Créer une classe Auth0Client" },
  { id: "define-a-secured-concern", title: "Définir un concern Secured" },
  { id: "include-the-secure-concern-in-your-applicationcontroller", title: "Inclure le concern Secure dans votre ApplicationController" },
  { id: "create-the-public-endpoint", title: "Créer le point de terminaison public" },
  { id: "create-the-private-endpoints", title: "Créer les points de terminaison privés" }
]


<Recipe isSingleColumn>
  <Content>
    Ce tutoriel effectue la validation du jeton d&#39;accès à l&#39;aide du Gem [jwt](https://github.com/jwt/ruby-jwt) dans une classe personnalisée `Auth0Client`. Un Concern appelé
    `Secured` est utilisé pour autoriser les points de terminaison qui nécessitent une authentification par jeton d&#39;accès entrant.

    Si vous n&#39;avez pas encore créé d&#39;API dans votre Auth0 Dashboard, utilisez le sélecteur interactif pour créer une nouvelle API Auth0 ou sélectionner une API existante pour votre projet.

    Pour configurer votre première API via le tableau de bord Auth0, consultez [notre guide de démarrage](https://auth0.com/docs/get-started/auth0-overview/set-up-apis).

    Chaque API Auth0 utilise l&#39;identifiant d&#39;API, que votre application doit utiliser pour valider le jeton d&#39;accès.

    <Info>
      **Vous débutez avec Auth0?** Découvrez [le fonctionnement d’Auth0](https://auth0.com/docs/overview)
      et apprenez comment [mettre en œuvre l’authentification et l’autorisation d’API](https://auth0.com/docs/api-auth) en utilisant le cadre OAuth 2.0.
    </Info>

    <Section id={sections[0].id} title={sections[0].title} stepNumber="1" isSingleColumn>
      Les permissions vous permettent de définir comment on peut accéder aux ressources au nom de l’utilisateur au moyen d’un jeton d’accès donné. Par
      exemple, vous pouvez choisir d’accorder un accès en lecture à la ressource `messages` si les utilisateurs ont le niveau d’accès gestionnaire
      et un accès en écriture à cette ressource s’ils ont le niveau d’accès administrateur.

      Vous pouvez définir les permissions autorisées dans la vue **Permissions** de la section [APIs](https://manage.auth0.com/#/apis) de l’Auth0 Dashboard.

      <Frame>
        <img src="/docs/images/cdy7uua7fh8z/1s3Yp5zqJiKiSWqbPSezNO/e61793a2822d095666002c3f65c71ac2/configure-permissions.png" />
      </Frame>

      <Info>
        Cet exemple utilise la portée `read:messages`.
      </Info>

      <LoggedInForm />
    </Section>

    <Section id={sections[1].id} title={sections[1].title} stepNumber="2" isSingleColumn>
      Installez la gem **jwt**.

      ```bash lines
      gem 'jwt'
      bundle install
      ```

      <LoggedInForm />
    </Section>

    <Section id={sections[2].id} title={sections[2].title} stepNumber="3" isSingleColumn>
      Créez une classe appelée `Auth0Client`. Cette classe décode et vérifie le jeton d’accès entrant récupéré à partir de l’en‑tête `Authorization` de la requête.

      La classe `Auth0Client` récupère la clé publique de votre locataire Auth0, puis l’utilise pour vérifier la signature du jeton d’accès. La structure `Token` définit une méthode `validate_permissions` pour rechercher une portée particulière dans un jeton d’accès en fournissant un tableau de scopes requis et en vérifiant s’ils sont présents dans la charge utile du jeton.

      <AuthCodeGroup>
        <Secured />

        <ApplicationController />

        <Auth0Client />

        <PublicController />

        <PrivateController />
      </AuthCodeGroup>
    </Section>

    <Section id={sections[3].id} title={sections[3].title} stepNumber="4" isSingleColumn>
      Créez un Concern appelé `Secured` qui recherche le jeton d’accès dans l’en-tête `Authorization`
      d’une requête entrante.

      Si le jeton est présent, `Auth0Client.validate_token` utilisera la gem `jwt` pour vérifier
      la signature du jeton et valider les revendications (claims) du jeton.

      En plus de vérifier que le jeton d’accès est valide, le Concern inclut également un mécanisme permettant de confirmer que le
      jeton possède une **portée** suffisante pour accéder aux ressources demandées. Dans cet exemple, nous définissons une
      méthode `validate_permissions` qui reçoit un bloc et vérifie les permissions en appelant la méthode
      `Token.validate_permissions` de la classe `Auth0Client`.

      Pour la route `/private-scoped`, les scopes définis seront mis en intersection avec les scopes présents dans la
      charge utile (payload), afin de déterminer si celle-ci contient un ou plusieurs éléments de l’autre tableau.

      <AuthCodeGroup>
        <Secured />

        <ApplicationController />

        <Auth0Client />

        <PublicController />

        <PrivateController />
      </AuthCodeGroup>
    </Section>

    <Section id={sections[4].id} title={sections[4].title} stepNumber="5" isSingleColumn>
      En ajoutant le concern `Secure` à votre contrôleur d’application, vous n’aurez plus qu’à utiliser un filtre `before_action` dans le contrôleur qui exige une autorisation.

      <AuthCodeGroup>
        <ApplicationController />

        <Auth0Client />

        <Secured />

        <PublicController />

        <PrivateController />
      </AuthCodeGroup>
    </Section>

    <Section id={sections[5].id} title={sections[5].title} stepNumber="6" isSingleColumn>
      Créez un contrôleur pour gérer le point de terminaison public `/api/public`.

      Le point de terminaison `/public` ne nécessite aucune autorisation, il n’est donc pas nécessaire de définir de `before_action`.

      <AuthCodeGroup>
        <PublicController />

        <ApplicationController />

        <Auth0Client />

        <Secured />

        <PrivateController />
      </AuthCodeGroup>
    </Section>

    <Section id={sections[6].id} title={sections[6].title} stepNumber="7" isSingleColumn>
      Créez un contrôleur pour gérer les points de terminaison privés : `/api/private` et `/api/private-scoped`.

      `/api/private` est disponible pour les requêtes authentifiées contenant un jeton d&#39;accès sans scopes supplémentaires.

      `/api/private-scoped` est disponible pour les requêtes authentifiées contenant un jeton d&#39;accès auquel la portée `read:messages` a été accordée

      Les points de terminaison protégés doivent appeler la méthode `authorize` du concern `Secured`. Pour
      ce faire, vous utilisez `before_action :authorize`, ce qui garantit que la méthode `Secured.authorize` est
      appelée avant chaque action dans le `PrivateController`.

      ### Effectuer un appel à votre API

      Pour effectuer des appels à votre API, vous avez besoin d&#39;un jeton d&#39;accès. Vous pouvez obtenir un jeton d&#39;accès à des fins de test dans la vue
      **Test** de vos [paramètres
      d&#39;API](https://manage.auth0.com/#/apis).

      <Frame>
        <img src="/docs/images/cdy7uua7fh8z/6jeVBuypOGX5qMRXeJn5ow/5e79037f6c852d2043789d622bdb9562/Quickstart_Example_App_-_English.png" />
      </Frame>

      Fournissez le jeton d&#39;accès comme en-tête `Authorization` dans vos requêtes.

      <AuthCodeGroup>
        ```bash cURL lines
        curl --request get \
        --url 'http:///%7ByourDomain%7D/api_path' \
        --header 'authorization: Bearer YOUR_ACCESS_TOKEN_HERE'
        ```

        ```csharp C# lines
        var client = new RestClient("http:///%7ByourDomain%7D/api_path");
        var request = new RestRequest(Method.GET);
        request.AddHeader("authorization", "Bearer YOUR_ACCESS_TOKEN_HERE");
        IRestResponse response = client.Execute(request);
        ```

        ```go Go lines
        package main
        import (
        "fmt"
        "net/http"
        "io/ioutil"
        )
        func main() {
        url := "http:///%7ByourDomain%7D/api_path"
        req, _ := http.NewRequest("get", url, nil)
        req.Header.Add("authorization", "Bearer VOTRE_JETON_ACCES_ICI")
        res, _ := http.DefaultClient.Do(req)
        defer res.Body.Close()
        body, _ := ioutil.ReadAll(res.Body)
        fmt.Println(res)
        fmt.Println(string(body))
        }
        ```

        ```java Java lines
        HttpResponse<String> response = Unirest.get("http:///%7ByourDomain%7D/api_path")
        .header("authorization", "Bearer YOUR_ACCESS_TOKEN_HERE")
        .asString();
        ```

        ```javascript Node.JS lines
        var axios = require("axios").default;
        var options = {
        method: 'get',
        url: 'http:///%7ByourDomain%7D/api_path',
        headers: {authorization: 'Bearer VOTRE_JETON_ACCES_ICI'}
        };
        axios.request(options).then(function (response) {
        console.log(response.data);
        }).catch(function (error) {
        console.error(error);
        });
        ```

        ```objc Obj-C lines
        #import <Foundation/Foundation.h>
        NSDictionary *headers = @{ @"authorization": @"Bearer VOTRE_JETON_D_ACCES_ICI" };
        NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@"http:///%7ByourDomain%7D/api_path"]
                                                        cachePolicy:NSURLRequestUseProtocolCachePolicy

                                                    timeoutInterval:10.0];

        [request setHTTPMethod:@"get"];
        [request setAllHTTPHeaderFields:headers];
        NSURLSession *session = [NSURLSession sharedSession];
        NSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request
                                                completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {

                                                    if (error) {

                                                        NSLog(@&quot;%@&quot;, error);

                                                    } else {

                                                        NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;

                                                        NSLog(@&quot;%@&quot;, httpResponse);

                                                    }

                                                }];

        [dataTask resume];
        ```

        ```php PHP lines
        #import <Foundation/Foundation.h>
        NSDictionary *headers = @{ @"authorization": @"Bearer VOTRE_JETON_D_ACCES_ICI" };
        NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@"http:///%7ByourDomain%7D/api_path"]
                                                        cachePolicy:NSURLRequestUseProtocolCachePolicy

                                                    timeoutInterval:10.0];

        [request setHTTPMethod:@"get"];
        [request setAllHTTPHeaderFields:headers];
        NSURLSession *session = [NSURLSession sharedSession];
        NSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request
                                                completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {

                                                    if (error) {

                                                        NSLog(@&quot;%@&quot;, error);

                                                    } else {

                                                        NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;

                                                        NSLog(@&quot;%@&quot;, httpResponse);

                                                    }

                                                }];

        [dataTask resume];
        ```

        ```python Python lines
        import http.client
        conn = http.client.HTTPConnection("")
        headers = { 'authorization': "Bearer VOTRE_JETON_ACCES_ICI" }
        conn.request("get", "/%7ByourDomain%7D/api_path", headers=headers)
        res = conn.getresponse()
        data = res.read()
        print(data.decode("utf-8"))
        ```

        ```ruby Ruby lines
        require 'uri'
        require 'net/http'
        url = URI("http:///%7ByourDomain%7D/api_path")
        http = Net::HTTP.new(url.host, url.port)
        request = Net::HTTP::Get.new(url)
        request["authorization"] = 'Bearer YOUR_ACCESS_TOKEN_HERE'
        response = http.request(request)
        puts response.read_body
        ```

        ```swift Swift lines
        import Foundation
        let headers = ["authorization": "Bearer VOTRE_JETON_ACCES_ICI"]
        let request = NSMutableURLRequest(url: NSURL(string: "http:///%7ByourDomain%7D/api_path")! as URL,
                                            cachePolicy: .useProtocolCachePolicy,

                                        timeoutInterval: 10.0)

        request.httpMethod = "get"
        request.allHTTPHeaderFields = headers
        let session = URLSession.shared
        let dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in
        if (error != nil) {
        print(error)

        } else {
        let httpResponse = response as? HTTPURLResponse

        print(httpResponse)

        }
        })
        dataTask.resume()
        ```
      </AuthCodeGroup>

      <Note>
        ##### Point de contrôle

        Maintenant que vous avez configuré votre application, exécutez votre application pour vérifier que :

        * `GET /api/public` est accessible pour les requêtes non authentifiées.
        * `GET /api/private` est accessible pour les requêtes authentifiées.
        * `GET /api/private-scoped` est accessible pour les requêtes authentifiées contenant un jeton d&#39;accès (Access Token) avec la portée `read:messages`.
      </Note>

      <AuthCodeGroup>
        <PrivateController />

        <ApplicationController />

        <Auth0Client />

        <Secured />

        <PublicController />
      </AuthCodeGroup>
    </Section>

    ## Prochaines étapes

    Excellent travail! Si vous vous êtes rendu jusqu&#39;ici, vous devriez maintenant avoir la connexion, la déconnexion et les informations de profil utilisateur qui fonctionnent dans votre application.

    Ce tutoriel de démarrage rapide est maintenant terminé, mais il reste encore beaucoup à découvrir. Pour en savoir plus sur ce que vous pouvez faire avec Auth0, consultez :

    * [Auth0 Dashboard](https://manage.auth0.com/dashboard/us/dev-gja8kxz4ndtex3rq) - Découvrez comment configurer et gérer votre tenant Auth0 et vos applications
    * [Trousse de développement logiciel (SDK) omniauth-auth0](https://github.com/auth0/omniauth-auth0) - Explorez plus en détail la trousse de développement logiciel (SDK) utilisée dans ce tutoriel
    * [Auth0 Marketplace](https://marketplace.auth0.com/) - Découvrez des intégrations que vous pouvez activer pour étendre les fonctionnalités d’Auth0
  </Content>
</Recipe>