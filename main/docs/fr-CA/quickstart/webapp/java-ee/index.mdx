---
title: "Java EE"
permalink: "01-login"
---

import {AuthCodeBlock} from "/snippets/fr-CA/AuthCodeBlock.jsx";

<div id="by-jim-anderson">
  ##### Par Jim Anderson
</div>

Ce tutoriel montre comment ajouter une fonctionnalité de connexion pour les utilisateurs à une application web Java EE. Nous vous recommandons de vous connecter pour suivre ce démarrage rapide avec des exemples configurés pour votre compte.

{/* <Card title="Afficher sur GitHub" href="https://github.com/auth0-samples/auth0-java-ee-sample/tree/master/01-Login" icon="github">
  Configuration requise : Java 11
  </Card> */}

<Info>
  **Nouveau avec Auth0 ?** Découvrez [comment Auth0 fonctionne](/docs/fr-CA/get-started/auth0-overview), comment il [s’intègre aux applications Web classiques](/docs/fr-CA/get-started/architecture-scenarios/sso-for-regular-web-apps) et quel [protocole](/docs/fr-CA/get-started/authentication-and-authorization-flow) il utilise.
</Info>

<div id="configure-auth0">
  ## Configurer Auth0
</div>

<div id="get-your-application-keys">
  ### Obtenir les clés de votre application
</div>

Lorsque vous vous êtes inscrit à Auth0, une nouvelle application a été créée pour vous, ou vous avez pu en créer une nouvelle. Vous aurez besoin de certaines informations concernant cette application pour communiquer avec Auth0. Vous pouvez obtenir ces informations dans la section [Application Settings](https://manage.auth0.com/#/applications) d’Auth0 Dashboard.

<Frame>![Tableau de bord de l'application](https://cdn2.auth0.com/docs/1.14550.0/media/articles/dashboard/client_settings.png)</Frame>

Vous avez besoin des informations suivantes :

* **Domaine**
* **ID client**
* **Secret client**

<Info>
  Si vous téléchargez l’exemple en haut de cette page, ces informations sont déjà renseignées pour vous.
</Info>

<div id="configure-callback-urls">
  ### Configurer les URL de redirection
</div>

Une URL de redirection est une URL dans votre application où Auth0 redirige l&#39;utilisateur après son authentification. L&#39;URL de redirection de votre application doit être ajoutée au champ **Allowed Callback URLs** dans vos [paramètres de l&#39;Application](https://manage.auth0.com/#/applications). Si ce champ n&#39;est pas configuré, les utilisateurs ne pourront pas se connecter à l&#39;application et recevront une erreur.

<Info>
  Si vous suivez le projet d&#39;exemple que vous avez téléchargé en haut de cette page, l&#39;URL de redirection que vous devez ajouter au champ **Allowed Callback URLs** est `http://localhost:3000/callback`.
</Info>

<div id="configure-logout-urls">
  ### Configurer les URL de déconnexion
</div>

Une URL de déconnexion est une URL dans votre application vers laquelle Auth0 peut rediriger l’utilisateur après qu’il a été déconnecté du serveur d’autorisation. Celle-ci est spécifiée dans le paramètre de requête `returnTo`. L’URL de déconnexion de votre application doit être ajoutée au champ **URL de déconnexion autorisées** dans vos [paramètres d’Application](https://manage.auth0.com/#/applications). Si ce champ n’est pas défini, les utilisateurs ne pourront pas se déconnecter de l’application et recevront un message d’erreur.

<Info>
  Si vous suivez le projet d’exemple que vous avez téléchargé en haut de cette page, l’URL de déconnexion que vous devez ajouter au champ **URL de déconnexion autorisées** est `http://localhost:3000/`.
</Info>

<div id="configure-java-ee-to-use-auth0">
  ## Configurer Java EE pour utiliser Auth0
</div>

<div id="set-up-dependencies">
  ### Configurer les dépendances
</div>

Pour intégrer votre application Java EE à Auth0, ajoutez les dépendances suivantes :

* **javax.javaee-api** : l’API Java EE 8 nécessaire pour écrire des applications utilisant Java EE 8. L’implémentation proprement dite est fournie par le conteneur d’applications, elle n’a donc pas besoin d’être incluse dans le fichier WAR.
* **javax.security.enterprise** : l’API de sécurité Java EE 8 qui permet de gérer les aspects de sécurité dans une application EE. Comme pour la dépendance `javax.javaee-api`, l’implémentation est fournie par le conteneur d’applications, elle n’est donc pas incluse dans le fichier WAR.
* **auth0-java-mvc-commons** : le [SDK Auth0 Java MVC](https://github.com/auth0/auth0-java-mvc-common) vous permet d’utiliser Auth0 avec Java pour des applications web MVC côté serveur. Il génère l’URL Authorize que votre application doit appeler pour authentifier un utilisateur à l’aide d’Auth0.

Si vous utilisez Maven, ajoutez ces dépendances à votre `pom.xml` :

```xml lines
<!-- pom.xml -->

<dependency>
    <groupId>com.auth0</groupId>
    <artifactId>mvc-auth-commons</artifactId>
    <version>[1.0, 2.0)</version>
</dependency>
<dependency>
    <groupId>javax</groupId>
    <artifactId>javaee-api</artifactId>
    <version>8.0.1</version>
    <scope>provided</scope>
</dependency>
<dependency>
    <groupId>javax.security.enterprise</groupId>
    <artifactId>javax.security.enterprise-api</artifactId>
    <version>1.0</version>
    <scope>provided</scope>
</dependency>
```

Si vous utilisez Gradle, ajoutez-les à votre fichier `build.gradle` :

```gradle lines
// build.gradle

providedCompile 'javax:javaee-api:8.0.1'
providedCompile 'javax.security.enterprise:javax.security.enterprise-api:1.0'
implementation 'com.auth0:mvc-auth-commons:1.+'
```

<div id="configure-your-java-ee-application">
  ### Configurer votre application Java EE
</div>

<Info>
  L&#39;exemple fourni avec ce tutoriel est écrit en JSP et a été testé avec le serveur d&#39;applications [WildFly](https://wildfly.org/). Vous devrez peut-être adapter certaines étapes si vous travaillez avec un autre conteneur d&#39;applications ou d&#39;autres technologies.
</Info>

Votre application Java EE a besoin de certaines informations pour pouvoir authentifier les utilisateurs auprès de votre Application Auth0. Le descripteur de déploiement `web.xml` peut être utilisé pour stocker ces informations, bien que vous puissiez aussi les stocker dans un autre emplacement sécurisé. Les informations requises sont :

export const codeExample = `<!-- \`src/main/webapp/WEB-INF/web.xml\`-->

<env-entry>
    <env-entry-name>auth0.domain</env-entry-name>
    <env-entry-type>java.lang.String</env-entry-type>
    <env-entry-value>{yourDomain}</env-entry-value>
</env-entry>
<env-entry>
    <env-entry-name>auth0.clientId</env-entry-name>
    <env-entry-type>java.lang.String</env-entry-type>
    <env-entry-value>{yourClientId}</env-entry-value>
</env-entry>
<env-entry>
    <env-entry-name>auth0.clientSecret</env-entry-name>
    <env-entry-type>java.lang.String</env-entry-type>
    <env-entry-value>{yourClientSecret}</env-entry-value>
</env-entry>
<env-entry>
    <env-entry-name>auth0.scope</env-entry-name>
    <env-entry-type>java.lang.String</env-entry-type>
    <env-entry-value>openid profile email</env-entry-value>
</env-entry>`;

<AuthCodeBlock children={codeExample} language="xml" />

Ces informations seront utilisées pour configurer la bibliothèque **auth0-java-mvc-commons** afin de permettre aux utilisateurs de se connecter à votre application. Pour en savoir plus sur la bibliothèque, y compris ses différentes options de configuration, consultez le [README](https://github.com/auth0/auth0-java-mvc-common/blob/master/README.md) de la bibliothèque.

<Note>
  ### Vérifiez les attributs renseignés

  Si vous avez téléchargé cet exemple à l’aide du bouton **Download Sample**, les attributs `domain`, `clientId` et `clientSecret` seront déjà renseignés pour vous. Assurez-vous que les valeurs sont correctes, en particulier si vous avez plusieurs applications Auth0 dans votre compte.
</Note>

<div id="configure-java-ee-security">
  ## Configurer Java EE Security
</div>

L’API de sécurité Java EE 8 a introduit l’interface `HttpAuthenticationMechanism` pour permettre aux applications d’obtenir les identifiants d’un utilisateur. Des implémentations par défaut existent pour l’authentification de base (Basic) et l’authentification basée sur des formulaires, et elle offre un moyen simple de configurer une stratégie d’authentification personnalisée.

Pour vous authentifier avec Auth0, fournissez des implémentations personnalisées des interfaces suivantes :

* `HttpAuthenticationMechanism` : responsable de l’obtention des identifiants d’un utilisateur et de la notification au conteneur de l’état de la connexion (réussie ou non) ([JavaDoc](https://javaee.github.io/javaee-spec/javadocs/javax/security/enterprise/authentication/mechanism/http/HttpAuthenticationMechanism.html)).
* `IdentityStore` : responsable de la validation des identifiants de l’utilisateur ([JavaDoc](https://javaee.github.io/javaee-spec/javadocs/javax/security/enterprise/identitystore/IdentityStore.html)).
* `CallerPrincipal` : représente le principal appelant de la requête HTTP en cours ([JavaDoc](https://javaee.github.io/javaee-spec/javadocs/javax/security/enterprise/CallerPrincipal.html)).
* `Credential` : représente l’identifiant que l’appelant utilisera pour s’authentifier ([JavaDoc](https://javaee.github.io/javaee-spec/javadocs/javax/security/enterprise/credential/Credential.html)).

Dans un premier temps, rendez vos paramètres Auth0 accessibles à l’application en créant un bean `@ApplicationScoped` pour récupérer les valeurs à partir du contexte web et les rendre disponibles via des getters :

```java lines
// src/main/java/com/auth0/example/security/Auth0AuthenticationConfig.java

@ApplicationScoped
public class Auth0AuthenticationConfig {

    private String domain;
    private String clientId;
    private String clientSecret;
    private String scope;

    @PostConstruct
    public void init() {
        // Obtenir les valeurs de configuration d'authentification des entrées env dans web.xml
        try {
            Context env = (Context)new InitialContext().lookup("java:comp/env");

            this.domain = (String) env.lookup("auth0.domain");
            this.clientId = (String) env.lookup("auth0.clientId");
            this.clientSecret = (String) env.lookup("auth0.clientSecret");
            this.scope = (String) env.lookup("auth0.scope");
        } catch (NamingException ne) {
            throw new IllegalArgumentException("Unable to lookup auth0 configuration properties from web.xml", ne);
        }

        if (this.domain == null || this.clientId == null || this.clientSecret == null || this.scope == null) {
            throw new IllegalArgumentException("domain, clientId, clientSecret, and scope must be set in web.xml");
        }
    }

    public String getDomain() {
         return domain;
    }

    public String getClientId() {
         return clientId;
    }

    public String getClientSecret() {
         return clientSecret;
    }

    public String getScope() {
        return scope;
    }
}
```

Ensuite, crée un `CallerPrincipal` personnalisé qui représente l’appelant de la requête en cours :

```java lines
// src/main/java/com/auth0/example/security/Auth0JwtPrincipal.java

public class Auth0JwtPrincipal extends CallerPrincipal {
    private final DecodedJWT idToken;

    Auth0JwtPrincipal(DecodedJWT idToken) {
        super(idToken.getClaim("name").asString());
        this.idToken = idToken;
    }

    public DecodedJWT getIdToken() {
        return this.idToken;
    }
}
```

Vous pouvez maintenant implémenter un `Credential` personnalisé qui servira à représenter les informations d’identification de l&#39;utilisateur. Il contiendra des informations sur le principal :

```java lines
// src/main/java/com/auth0/example/security/Auth0JwtCredential.java

class Auth0JwtCredential implements Credential {
    private Auth0JwtPrincipal auth0JwtPrincipal;

    Auth0JwtCredential(String token) {
        DecodedJWT decodedJWT = JWT.decode(token);
        this.auth0JwtPrincipal = new Auth0JwtPrincipal(decodedJWT);
    }

    Auth0JwtPrincipal getAuth0JwtPrincipal() {
        return auth0JwtPrincipal;
    }
}
```

Vous avez maintenant défini les classes qui représentent un principal appelant et des informations d’authentification. Ensuite, créez une implémentation personnalisée de `IdentityStore`. Cette classe sera chargée de valider les informations d’authentification de l&#39;utilisateur :

```java lines
// src/main/java/com/auth0/example/security/Auth0JwtIdentityStore.java

@ApplicationScoped
public class Auth0JwtIdentityStore implements IdentityStore {

    @Override
    public CredentialValidationResult validate(final Credential credential) {
        CredentialValidationResult result = CredentialValidationResult.NOT_VALIDATED_RESULT;
        if (credential instanceof Auth0JwtCredential) {
            Auth0JwtCredential auth0JwtCredential = (Auth0JwtCredential) credential;
            result = new CredentialValidationResult(auth0JwtCredential.getAuth0JwtPrincipal());
        }
        return result;
    }
}
```

Si `credential` est un `Auth0Credential`, l’utilisateur appelant est authentifié et valide, donc un `CredentialValidationResult` créé avec ces informations d’identification est renvoyé pour indiquer la réussite. Si ce n’est pas un `Auth0Credential`, renvoyez `CredentialValidationResult.NOT_VALIDATED_RESULT`.

Avant d’implémenter l’interface `HttpAuthenticationMechanism` qui utilisera tous ces collaborateurs, créez un bean qui fournira une instance configurée de `AuthenticationController` à partir de la Trousse de développement logiciel (SDK) Auth0 Java MVC. `AuthenticationController` est utilisé pour construire l’URL d’autorisation où les utilisateurs se connecteront et pour gérer l’échange de jetons afin d’authentifier les utilisateurs.

* Si votre Application Auth0 est configurée pour utiliser **l’algorithme de signature RS256** (la valeur par défaut lors de la création d’une nouvelle Application Auth0), vous devez configurer un `JwkProvider` pour récupérer la clé publique utilisée pour vérifier la signature du jeton. Consultez le [dépôt jwks-rsa-java](https://github.com/auth0/jwks-rsa-java) pour en savoir plus sur les options de configuration supplémentaires.
* Si votre Application Auth0 est configurée pour utiliser **l’algorithme de signature HS256**, il n’est pas nécessaire de configurer le `JwkProvider`.

<Info>
  Pour en savoir plus sur les algorithmes de signature disponibles, consultez la [documentation](https://auth0.com/docs/tokens/concepts/signing-algorithms).
</Info>

L’exemple ci-dessous montre comment configurer `AuthenticationController` pour l’utiliser avec **l’algorithme de signature RS256** :

```java lines
// src/main/java/com/auth0/example/security/Auth0AuthenticationProvider.java

@ApplicationScoped
public class Auth0AuthenticationProvider {

    @Produces
    public AuthenticationController authenticationController(Auth0AuthenticationConfig config) {
        JwkProvider jwkProvider = new JwkProviderBuilder(config.getDomain()).build();
        return AuthenticationController.newBuilder(config.getDomain(), config.getClientId(), config.getClientSecret())
                .withJwkProvider(jwkProvider)
                .build();
    }
}
```

Enfin, implémentez un `HttpAuthenticationMechanism` personnalisé

```java lines
// src/main/java/com/auth0/example/security/Auth0AuthenticationMechanism.java

@ApplicationScoped
@AutoApplySession
public class Auth0AuthenticationMechanism implements HttpAuthenticationMechanism {
    private final AuthenticationController authenticationController;
    private final IdentityStoreHandler identityStoreHandler;

    @Inject
    Auth0AuthenticationMechanism(AuthenticationController authenticationController, IdentityStoreHandler identityStoreHandler) {
        this.authenticationController = authenticationController;
        this.identityStoreHandler = identityStoreHandler;
    }

    @Override
    public AuthenticationStatus validateRequest(HttpServletRequest httpServletRequest,
                                                HttpServletResponse httpServletResponse,
                                                HttpMessageContext httpMessageContext) throws AuthenticationException {

        // Échanger le code contre le jeton ID et notifier le conteneur du résultat.
        if (isCallbackRequest(httpServletRequest)) {
            try {
                Tokens tokens = authenticationController.handle(httpServletRequest, httpServletResponse);
                Auth0JwtCredential auth0JwtCredential = new Auth0JwtCredential(tokens.getIdToken());
                CredentialValidationResult result = identityStoreHandler.validate(auth0JwtCredential);
                return httpMessageContext.notifyContainerAboutLogin(result);
            } catch (IdentityVerificationException e) {
                return httpMessageContext.responseUnauthorized();
            }
        }
        return httpMessageContext.doNothing();
    }

    private boolean isCallbackRequest(HttpServletRequest request) {
        return request.getRequestURI().equals("/callback") && request.getParameter("code") != null;
    }
}
```

La classe surcharge la méthode `validateRequest`, qui est appelée à chaque requête vers notre application et qui est responsable d’informer le conteneur de l’état de l’authentification.

Cet exemple utilise le [flux de code d’autorisation](https://auth0.com/docs/get-started/authentication-and-authorization-flow/concepts/auth-code) pour échanger un code d’autorisation contre un jeton au cours du flux d’authentification. Si cette requête est destinée au point de terminaison `/callback` et contient le paramètre de requête `code`, elle effectue quelques opérations importantes :

* Appelle la méthode `handle` de `AuthenticationController` pour échanger le code d’autorisation contre un jeton ID et un jeton d’accès.
* Utilise le jeton ID pour créer un nouveau `Auth0Credential`.
* Appelle la méthode `validate` de l’implémentation personnalisée `IdentityStore` pour obtenir le résultat de validation.
* Informe le conteneur d’application de l’état de connexion.

Si la ressource demandée n’est pas `/callback`, retournez `httpMessageContext.doNothing()` pour permettre au traitement de la requête de se poursuivre. Vous verrez bientôt comment utiliser les informations d’authentification pour déclencher l’authentification et afficher des vues web.

Enfin, notez que l’annotation `@AutoApplySession` a été ajoutée pour permettre au conteneur de créer une session pour l’utilisateur authentifié.

<div id="trigger-authentication">
  ## Déclencher l’authentification
</div>

Pour permettre à un utilisateur de se connecter, créez un servlet qui gérera les requêtes adressées au chemin `/login` :

```java lines
// src/main/java/com/auth0/example/web/LoginServlet.java

@WebServlet(urlPatterns = "/login")
public class LoginServlet extends HttpServlet {
    private final Auth0AuthenticationConfig config;
    private final AuthenticationController authenticationController;

    @Inject
    LoginServlet(Auth0AuthenticationConfig config, AuthenticationController authenticationController) {
        this.config = config;
        this.authenticationController = authenticationController;
    }

    @Override
    public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        // URL où l'Application recevra le code d'autorisation (p. ex., http://localhost:3000/callback)
        String callbackUrl = String.format(
                "%s://%s:%s/callback",
                request.getScheme(),
                request.getServerName(),
                request.getServerPort()
        );

        // Créer l'URL d'autorisation vers laquelle rediriger l'utilisateur pour commencer le flux d'authentification.
        String authURL = authenticationController.buildAuthorizeUrl(request, response, callbackUrl)
                .withScope(config.getScope())
                .build();

        response.sendRedirect(authURL);
    }
}
```

Le `LoginController` est responsable de rediriger la requête vers la bonne URL d’autorisation, où l’utilisateur peut s’authentifier auprès d’Auth0. Il utilise le `AuthenticationController` de la Trousse de développement logiciel (SDK) Auth0 Java MVC pour construire l’URL d’autorisation appropriée, en utilisant les valeurs de configuration injectées via `Auth0AuthenticationConfig`. Par défaut, cet exemple demande les scopes `"openid profile email"` afin de permettre à l’application de récupérer les renseignements de base du profil de l’utilisateur authentifié. Vous pouvez en apprendre davantage sur ces scopes dans la documentation [OpenID Connect Scopes](https://auth0.com/docs/scopes/current/oidc-scopes).

Une fois que l’utilisateur a saisi ses informations d’identification et a autorisé les autorisations demandées, Auth0 enverra une requête à `callbackUrl` et inclura un paramètre de requête `code` qui pourra être échangé contre un jeton ID et un jeton d’accès. Rappelez-vous que le `Auth0HttpAuthenticationMechanism` créé ci-dessus prend en charge cet échange afin de pouvoir informer le conteneur d’applications de l’état de l’authentification. Cela permet au Servlet qui gère les requêtes vers le chemin `/callback` de simplement transmettre la requête à la ressource initialement demandée avant la connexion, ou de simplement rediriger vers la page d’accueil :

```java lines
// src/main/com/auth0/example/web/CallbackServlet.java

@WebServlet(urlPatterns = {"/callback"})
public class CallbackServlet extends HttpServlet {

    @Override
    public void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {
        String referer = (String) request.getSession().getAttribute("Referer");
        String redirectTo = referer != null ? referer : "/";

        response.sendRedirect(redirectTo);
    }
}
```

<div id="display-user-information">
  ## Afficher les informations de l’utilisateur
</div>

Vous pouvez utiliser `Auth0JwtPrincipal` pour récupérer les informations de profil de l’utilisateur authentifié. L’exemple de code suivant montre comment utiliser les revendications du [jeton ID](https://auth0.com/docs/tokens/id-token) pour définir les données de profil en tant qu’attribut de requête :

```java lines
// src/main/java/com/auth0/example/web/HomeServlet.java

@WebServlet(urlPatterns = "")
public class HomeServlet extends HttpServlet {

    @Override
    public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        Principal principal = request.getUserPrincipal();

        if (principal instanceof Auth0JwtPrincipal) {
            Auth0JwtPrincipal auth0JwtPrincipal = (Auth0JwtPrincipal) principal;
            request.setAttribute("profile", auth0JwtPrincipal.getIdToken().getClaims());
        }
        request.getRequestDispatcher("/WEB-INF/jsp/home.jsp").forward(request, response);
    }
}
```

Vous pouvez ensuite utiliser ces renseignements de profil dans votre vue pour afficher des renseignements sur l’utilisateur :

```jspf lines
<!-- src/main/webapp/WEB-INF/jsp/fragments/navbar.jspf -->

<c:choose>
    <c:when test="${empty profile}">
        <li>
            <form action="/login" method="GET">
                <input type="submit" value="Connexion"/>
            </form>
        </li>
    </c:when>
    <c:otherwise>
        <li>
            <a href="#">
                <!-- L'image de profil doit être définie sur la photo de profil provenant du jeton ID -->
                <Frame><img src="${profile.get('picture').asString()}" alt="Photo de profil"/></Frame>
            </a>
            <div>
                <!-- Afficher ici le nom complet de l'utilisateur provenant du jeton ID -->
                <div>"${profile.get('name').asString()}"</div>
                <a href="/docs/profile">Profil</a>
                <a href="/docs/logout">Se déconnecter</a>
            </div>
        </li>
    </c:otherwise>
</c:choose>
```

<div id="handle-logout">
  ## Gérer la déconnexion
</div>

Pour déconnecter un utilisateur, vous devez effacer la session de l’application et déconnecter l’utilisateur d’Auth0. Cette opération est gérée dans le `LogoutServlet`.

Commencez par invalider la session en appelant `request.getSession().invalidate()`. Ensuite, construisez l’URL de déconnexion en vous assurant d’inclure le paramètre de requête `returnTo`, qui indique l’URL vers laquelle l’utilisateur sera redirigé après la déconnexion. Enfin, redirigez la réponse vers l’URL de déconnexion de l’application :

```java lines
// src/main/java/com/auth0/example/web/LogoutServlet.java

@WebServlet(urlPatterns = "/logout")
public class LogoutServlet extends HttpServlet {
    private final Auth0AuthenticationConfig config;

    @Inject
    LogoutServlet(Auth0AuthenticationConfig config) {
        this.config = config;
    }

    @Override
    protected void doGet(final HttpServletRequest request, final HttpServletResponse response) throws ServletException, IOException {
        clearSession(request);
        response.sendRedirect(getLogoutUrl(request));
    }

    private void clearSession(HttpServletRequest request) {
        if (request.getSession() != null) {
            request.getSession().invalidate();
        }
    }

    private String getLogoutUrl(HttpServletRequest request) {
        String returnUrl = String.format("%s://%s", request.getScheme(), request.getServerName());
        int port = request.getServerPort();
        String scheme = request.getScheme();

        if (("http".equals(scheme) && port != 80) ||
                ("https".equals(scheme) && port != 443)) {
            returnUrl += ":" + port;
        }

        returnUrl += "/";

        // Construire l'URL de déconnexion comme suit :
        // https://{VOTRE-DOMAINE}/v2/logout?client_id={VOTRE-CLIENT-ID}&returnTo=http://localhost:3000/
        String logoutUrl = String.format(
                "https://%s/v2/logout?client_id=%s&returnTo=%s",
                config.getDomain(),
                config.getClientId(),
                returnUrl
        );

        return logoutUrl;
    }
}
```

<div id="run-the-sample">
  ## Exécuter l’exemple
</div>

Pour compiler et exécuter l’exemple, exécutez l’objectif Maven `wildfly:run` afin de démarrer un serveur d’applications WildFly embarqué avec cette application qui y est déployée. Consultez la documentation du [WildFly Maven Plugin](https://docs.jboss.org/wildfly/plugins/maven/latest/) pour plus d’informations.

Si vous utilisez Linux ou macOS :

```bash lines
./mvnw clean wildfly:run
```

Windows :

```sh lines
mvnw.cmd clean wildfly:run
```

Ouvrez l’adresse `http://localhost:3000` dans votre navigateur. Suivez le lien **Se connecter** pour vous connecter ou vous inscrire à votre tenant Auth0.

<Frame>![Universal Login d'Auth0](https://cdn2.auth0.com/docs/1.14550.0/media/quickstarts/universal-login.png)</Frame>

Après une connexion réussie, vous verrez la photo de profil de l&#39;utilisateur et un menu déroulant à l&#39;emplacement de l&#39;ancien lien **Se connecter**. Vous pouvez ensuite afficher la page de profil de l&#39;utilisateur en cliquant sur le lien **Profil**. Vous pouvez vous déconnecter en cliquant sur le lien **Déconnexion** dans le menu déroulant.

<Note>
  ##### Que pouvez-vous faire ensuite ?

  <table>
    <tr>
      <td><a href="/docs/fr-CA/authenticate/identity-providers">Configurer d&#39;autres fournisseurs d&#39;identité</a></td>
      <td><a href="/docs/fr-CA/secure/multi-factor-authentication">Activer l&#39;authentification multifacteur</a></td>
    </tr>

    <tr>
      <td><a href="/docs/fr-CA/secure/attack-protection">En savoir plus sur la protection contre les attaques</a></td>
      <td><a href="/docs/fr-CA/customize/rules">En savoir plus sur Rules</a></td>
    </tr>
  </table>

  [Modifier sur GitHub](https://github.com/auth0/docs/edit/master/articles/quickstart/native/flutter/01-login.md)
</Note>
