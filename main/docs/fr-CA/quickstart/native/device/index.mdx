---
title: "Flux d’autorisation de l’appareil"
permalink: "01-login"
---

import {AuthCodeGroup} from "/snippets/fr-CA/AuthCodeGroup.jsx";

<div id="by-rachel-khoriander">
  ##### Par Rachel Khoriander
</div>

Ce tutoriel explique comment appeler votre API à partir d’un appareil à saisie limitée en utilisant le flux Device Authorization. Nous vous recommandons d’ouvrir une session pour suivre ce démarrage rapide avec des exemples configurés pour votre compte.

Ce tutoriel explique comment appeler votre API à partir d’un appareil à saisie limitée en utilisant le flux Device Authorization.

{/* [Suivre le Démarrage rapide](#prerequisites)

  [Voir sur GitHub](https://github.com/undefined/undefined/tree/master/01-Login) */}

<Info>
  Ce tutoriel vous aidera à appeler votre propre API à partir d’un appareil dont les capacités de saisie sont limitées en utilisant le flux d’autorisation pour appareil. Pour savoir comment ce flux fonctionne et pourquoi vous devriez l’utiliser, consultez la page [Flux d’autorisation pour appareil](/docs/fr-CA/get-started/authentication-and-authorization-flow/device-authorization-flow).
</Info>

Auth0 simplifie l’implémentation du flux d’autorisation pour appareil dans votre application, en utilisant :

* Authentication API : Lisez la suite pour apprendre à appeler notre API directement. Pour une expérience interactive, consultez notre [Device Flow Playground](https://auth0.github.io/device-flow-playground/).

<div id="prerequisites">
  ## Conditions préalables
</div>

**Avant de commencer ce tutoriel :**

* Vérifiez les [limitations](#limitations) pour vous assurer que le flux d’autorisation pour appareils est adapté à votre implémentation.
* [Enregistrez l’Application auprès d’Auth0](/docs/fr-CA/get-started/auth0-overview/create-applications/native-apps).

  * Sélectionnez un **Type d’Application** de **Native**.
  * Au besoin, définissez les **Allowed Web Origins**. Vous pouvez utiliser ce paramètre pour autoriser localhost comme origine pour le développement local ou pour définir une origine autorisée pour un logiciel TV particulier dont l’architecture est soumise à CORS (par exemple : HTML5 + JS). La plupart des applications n’utiliseront pas ce paramètre.
  * Assurez-vous que l’option **OIDC Conformant** est activée. Ce paramètre se trouve dans le [Dashboard](https://manage.auth0.com/#), sous **Application Settings &gt; Advanced &gt; OAuth**.
  * Assurez-vous que les [**Grant Types**](/docs/fr-CA/get-started/applications/update-grant-types) de l’Application incluent **Device Code**. Ce paramètre se trouve également dans le [Dashboard](https://manage.auth0.com/#), sous **Application Settings &gt; Advanced &gt; Grant Types**.
  * Si vous voulez que votre Application puisse utiliser des [Jetons d’actualisation](/docs/fr-CA/secure/tokens/refresh-tokens), assurez-vous que les [**Grant Types**](/docs/fr-CA/get-started/applications/update-grant-types) de l’Application incluent **Refresh Token**.
* Configurez et activez au moins une connexion pour l’Application : [connexions de base de données](/docs/fr-CA/get-started/applications/set-up-database-connections), [connexions sociales](https://marketplace.auth0.com/features/social-connections)
* [Enregistrez votre API auprès d’Auth0](/docs/fr-CA/get-started/architecture-scenarios/mobile-api/part-2#create-the-api)

  * Si vous voulez que votre API reçoive des [Jetons d’actualisation](/docs/fr-CA/secure/tokens/refresh-tokens) pour lui permettre d’obtenir de nouveaux jetons lorsque les précédents expirent, activez **Allow Offline Access**.
* [Configurez les paramètres Device User Code](/docs/fr-CA/get-started/tenant-settings/configure-device-user-code-settings) pour définir le jeu de caractères, le format et la longueur de votre code utilisateur généré aléatoirement.

<div id="steps">
  ## Étapes
</div>

1. [Demandez un code d’appareil](#request-device-code) (Device Flow) : Demandez un code d’appareil que l’utilisateur peut utiliser pour autoriser l’appareil.
2. [Demandez l’activation de l’appareil](#request-device-activation) (Device Flow) : Demandez à l’utilisateur d’autoriser l’appareil à l’aide de son ordinateur portable ou de son téléphone intelligent.
3. [Demandez des jetons](#request-tokens) (Device Flow) : Interrogez le point de terminaison des jetons pour demander un jeton.
4. [Autorisation de l’utilisateur](#user-authorization) (Browser Flow) : L’utilisateur autorise l’appareil afin que celui-ci puisse recevoir des jetons.
5. [Recevez des jetons](#receive-tokens) (Device Flow) : Après que l’utilisateur a autorisé l’appareil avec succès, recevez des jetons.
6. [Appelez votre API](#call-your-api) (Device Flow) : Utilisez le jeton d’accès obtenu pour appeler votre API.
7. [Actualisez les jetons](#refresh-tokens) (Device Flow) : Utilisez un Jeton d’actualisation pour demander de nouveaux jetons lorsque ceux existants expirent.

Facultatif : [Explorer des exemples de cas d’utilisation](#sample-use-cases)

Facultatif : [Dépannage](#troubleshooting)

<div id="request-device-code">
  ## Demander un code d’appareil
</div>

Une fois que l’utilisateur a démarré son application sur l’appareil et souhaite autoriser cet appareil, vous devez obtenir un code d’appareil. Lorsque l’utilisateur commence sa session sur son appareil via un navigateur, ce code sera associé à cette session.

Pour obtenir le code d’appareil, votre application doit demander un code à l’[URL de code d’appareil](https://auth0.com/docs/api/authentication#get-device-code), en incluant l’ID client.

<div id="example-post-to-device-code-url">
  ### Exemple de requête POST vers l’URL du code d’appareil
</div>

<AuthCodeGroup>
  ```bash cURL
  curl --request POST \
    --url 'https://{yourDomain}/oauth/device/code' \
    --header 'content-type: application/x-www-form-urlencoded' \
    --data 'client_id={yourClientId}' \
    --data 'scope=SCOPE' \
    --data 'audience=AUDIENCE'
  ```

  ```csharp C#
  var client = new RestClient("https://{yourDomain}/oauth/device/code");
  var request = new RestRequest(Method.POST);
  request.AddHeader("content-type", "application/x-www-form-urlencoded");
  request.AddParameter("application/x-www-form-urlencoded", "client_id={yourClientId}&scope=SCOPE&audience=AUDIENCE", ParameterType.RequestBody);
  IRestResponse response = client.Execute(request);
  ```

  ```go Go
  package main

  import (
  	"fmt"
  	"strings"
  	"net/http"
  	"io/ioutil"
  )

  func main() {

  	url := "https://{votreDomaine}/oauth/device/code"

  	payload := strings.NewReader("client_id=%24%7Baccount.clientId%7D&scope=SCOPE&audience=AUDIENCE")

  	req, _ := http.NewRequest("POST", url, payload)

  	req.Header.Add("content-type", "application/x-www-form-urlencoded")

  	res, _ := http.DefaultClient.Do(req)

  	defer res.Body.Close()
  	body, _ := ioutil.ReadAll(res.Body)

  	fmt.Println(res)
  	fmt.Println(string(body))

  }
  ```

  ```java Java
  HttpResponse<String> response = Unirest.post("https://{yourDomain}/oauth/device/code")
    .header("content-type", "application/x-www-form-urlencoded")
    .body("client_id=%24%7Baccount.clientId%7D&scope=SCOPE&audience=AUDIENCE")
    .asString();
  ```

  ```javascript Node.JS
  var axios = require("axios").default;

  var options = {
    method: 'POST',
    url: 'https://{yourDomain}/oauth/device/code',
    headers: {'content-type': 'application/x-www-form-urlencoded'},
    data: new URLSearchParams({
      client_id: '{yourClientId}',
      scope: 'SCOPE',
      audience: 'AUDIENCE'
    })
  };

  axios.request(options).then(function (response) {
    console.log(response.data);
  }).catch(function (error) {
    console.error(error);
  });
  ```

  ```objc Obj-C
  #import <Foundation/Foundation.h>

  NSDictionary *headers = @{ @"content-type": @"application/x-www-form-urlencoded" };

  NSMutableData *postData = [[NSMutableData alloc] initWithData:[@"client_id={yourClientId}" dataUsingEncoding:NSUTF8StringEncoding]];
  [postData appendData:[@"&scope=SCOPE" dataUsingEncoding:NSUTF8StringEncoding]];
  [postData appendData:[@"&audience=AUDIENCE" dataUsingEncoding:NSUTF8StringEncoding]];

  NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@"https://{yourDomain}/oauth/device/code"]
                                                         cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                     timeoutInterval:10.0];
  [request setHTTPMethod:@"POST"];
  [request setAllHTTPHeaderFields:headers];
  [request setHTTPBody:postData];

  NSURLSession *session = [NSURLSession sharedSession];
  NSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request
                                              completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                  if (error) {
                                                      NSLog(@"%@", error);
                                                  } else {
                                                      NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                      NSLog(@"%@", httpResponse);
                                                  }
                                              }];
  [dataTask resume];
  ```

  ```php PHP
  $curl = curl_init();

  curl_setopt_array($curl, [
    CURLOPT_URL => "https://{yourDomain}/oauth/device/code",
    CURLOPT_RETURNTRANSFER => true,
    CURLOPT_ENCODING => "",
    CURLOPT_MAXREDIRS => 10,
    CURLOPT_TIMEOUT => 30,
    CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
    CURLOPT_CUSTOMREQUEST => "POST",
    CURLOPT_POSTFIELDS => "client_id=%24%7Baccount.clientId%7D&scope=SCOPE&audience=AUDIENCE",
    CURLOPT_HTTPHEADER => [
      "content-type: application/x-www-form-urlencoded"
    ],
  ]);

  $response = curl_exec($curl);
  $err = curl_error($curl);

  curl_close($curl);

  if ($err) {
    echo "Erreur cURL no : " . $err;
  } else {
    echo $response;
  }
  ```

  ```python Python
  import http.client

  conn = http.client.HTTPSConnection("")

  payload = "client_id=%24%7Baccount.clientId%7D&scope=SCOPE&audience=AUDIENCE"

  headers = { 'content-type': "application/x-www-form-urlencoded" }

  conn.request("POST", "/{yourDomain}/oauth/device/code", payload, headers)

  res = conn.getresponse()
  data = res.read()

  print(data.decode("utf-8"))
  ```

  ```rb Ruby
  require 'uri'
  require 'net/http'
  require 'openssl'

  url = URI("https://{yourDomain}/oauth/device/code")

  http = Net::HTTP.new(url.host, url.port)
  http.use_ssl = true
  http.verify_mode = OpenSSL::SSL::VERIFY_NONE

  request = Net::HTTP::Post.new(url)
  request["content-type"] = 'application/x-www-form-urlencoded'
  request.body = "client_id=%24%7Baccount.clientId%7D&scope=SCOPE&audience=AUDIENCE"

  response = http.request(request)
  puts response.read_body
  ```

  ```swift Swift
  import Foundation

  let headers = ["content-type": "application/x-www-form-urlencoded"]

  let postData = NSMutableData(data: "client_id={yourClientId}".data(using: String.Encoding.utf8)!)
  postData.append("&scope=SCOPE".data(using: String.Encoding.utf8)!)
  postData.append("&audience=AUDIENCE".data(using: String.Encoding.utf8)!)

  let request = NSMutableURLRequest(url: NSURL(string: "https://{yourDomain}/oauth/device/code")! as URL,
                                          cachePolicy: .useProtocolCachePolicy,
                                      timeoutInterval: 10.0)
  request.httpMethod = "POST"
  request.allHTTPHeaderFields = headers
  request.httpBody = postData as Data

  let session = URLSession.shared
  let dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in
    if (error != nil) {
      print(error)
    } else {
      let httpResponse = response as? HTTPURLResponse
      print(httpResponse)
    }
  })

  dataTask.resume()
  ```
</AuthCodeGroup>

<div id="device-code-parameters">
  #### Paramètres du device code
</div>

Notez que lorsque vous demandez un device code pour appeler une API personnalisée, vous :

* devez inclure un paramètre audience
* pouvez inclure des scopes supplémentaires pris en charge par l’API cible

<Info>
  Si votre application souhaite obtenir un jeton d’accès uniquement pour récupérer des renseignements sur l’utilisateur authentifié, aucun paramètre audience n’est requis.
</Info>

<table class="table">
  <thead>
    <tr>
      <th>Nom du paramètre</th>
      <th>Description</th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td><code>client&#95;id</code></td>
      <td>L’ID client de votre application. Vous pouvez trouver cette valeur dans vos <a href="https://manage.auth0.com/#/Applications/{yourClientId}/settings">paramètres d’Application</a>.</td>
    </tr>

    <tr>
      <td><code>scope</code></td>
      <td>Les <a href="/docs/fr-CA/get-started/apis/scopes">scopes</a> pour lesquels vous voulez demander une autorisation. Ceux-ci doivent être séparés par un espace. Vous pouvez demander n’importe lequel des <a href="https://openid.net/specs/openid-connect-core-1_0.html#StandardClaims">scopes OIDC standard</a> à propos des utilisateurs, tels que <code>profile</code> et <code>email</code>, des <a href="/docs/fr-CA/secure/tokens/json-web-tokens/json-web-token-claims#custom-claims">revendications personnalisées</a> conformes à un <a href="/docs/fr-CA/secure/tokens/json-web-tokens/create-custom-claims">format avec espace de noms</a>, ou tout <a href="/docs/fr-CA/get-started/apis/scopes/api-scopes">scope pris en charge par l’API cible</a> (par exemple <code>read:contacts</code>). Incluez <code>openid</code> pour obtenir un jeton ID ou pour pouvoir utiliser le <a href="https://auth0.com/docs/api/authentication#user-profile">point de terminaison /userinfo</a> afin de récupérer les renseignements de profil de l’utilisateur. Incluez <code>offline&#95;access</code> pour obtenir un Jeton d’actualisation (assurez-vous que le champ <strong>Allow Offline Access</strong> est activé dans les <a href="https://manage.auth0.com/#/apis">paramètres d’API</a>). Notez que cela doit être encodé dans l’URL.</td>
    </tr>

    <tr>
      <td><code>audience</code></td>
      <td>L’identifiant unique de l’API à laquelle votre application veut accéder. Utilisez la valeur <strong>Identifier</strong> dans l’onglet <a href="https://manage.auth0.com/#/apis">Settings</a> de l’API que vous avez créée dans le cadre des prérequis pour ce tutoriel. Notez que cela doit être encodé dans l’URL.</td>
    </tr>
  </tbody>
</table>

<div id="device-code-response">
  ### Réponse de code de dispositif
</div>

Si tout se passe bien, vous recevrez une réponse HTTP 200 avec un corps contenant les champs `device_code`, `user_code`, `verification_uri`, `expires_in`, `interval` et `verification_uri_complete` :

```json lines
{
  "device_code": "Ag_EE...ko1p",
  "user_code": "QTZL-MCBW",
  "verification_uri": "https://accounts.acmetest.org/activate",
  "verification_uri_complete": "https://accounts.acmetest.org/activate?user_code=QTZL-MCBW",
  "expires_in": 900,
  "interval": 5
}
```

* `device_code` est le code unique de l’appareil. Lorsque l’utilisateur accède à la `verification_uri` à partir de son appareil utilisant un navigateur, ce code sera associé à sa session.
* `user_code` contient le code qui doit être saisi à la `verification_uri` pour autoriser l’appareil.
* `verification_uri` contient l’URL que l’utilisateur doit visiter pour autoriser l’appareil.
* `verification_uri_complete` contient l’URL complète que l’utilisateur doit visiter pour autoriser l’appareil. Cela permet à votre application d’intégrer le `user_code` dans l’URL, si vous le souhaitez.
* `expires_in` indique la durée de vie (en secondes) du `device_code` et du `user_code`.
* `interval` indique l’intervalle (en secondes) auquel l’application doit interroger l’URL du jeton pour demander un jeton.

<Info>
  Vous pouvez [configurer le jeu de caractères, le format et la longueur de votre code utilisateur généré aléatoirement](/docs/fr-CA/get-started/tenant-settings/configure-device-user-code-settings) dans les paramètres de votre tenant.

  Pour empêcher les attaques par force brute, nous appliquons les limites suivantes au `user_code` :

  **Longueur minimale** :

  * Lettres BASE20 : 8 caractères
  * Chiffres : 9 caractères

  **Longueur maximale** :

  * 20 caractères (y compris les traits d’union et les espaces, qui peuvent être ajoutés comme séparateurs pour améliorer la lisibilité)

  **Durée d’expiration** :

  * 15 minutes
</Info>

<div id="request-device-activation">
  ## Demander l’activation de l’appareil
</div>

Une fois que vous avez reçu un `device_code` et un `user_code`, vous devez demander à l’utilisateur de se rendre à `verification_uri` sur son ordinateur portable ou son téléphone intelligent et d’y saisir le `user_code` :

<Frame>![Demander l’activation de l’appareil](https://cdn2.auth0.com/docs/1.14550.0/media/articles/flows/guides/device-auth/request-device-activation.png)</Frame>

Le `device_code` n’est pas destiné à être utilisé directement par l’utilisateur et ne doit pas être affiché pendant l’interaction afin d’éviter toute confusion.

<Info>
  Lorsque vous créez un outil CLI, vous pouvez ignorer cette étape et ouvrir immédiatement le navigateur à l’aide de `verification_uri_complete`.
</Info>

<div id="request-tokens">
  ## Demander des jetons
</div>

Pendant que vous attendez que l&#39;utilisateur active l&#39;appareil, commencez à interroger l&#39;URL du jeton pour demander un jeton d&#39;accès. En utilisant l&#39;intervalle d&#39;interrogation (`interval`) extrait à l&#39;étape précédente, vous devrez envoyer une requête `POST` à l&#39;[URL du jeton](https://auth0.com/docs/api/authentication#device-auth) en incluant le `device_code`.

Pour éviter les erreurs dues à la latence du réseau, commencez à compter chaque intervalle à partir de la réception de la réponse à la dernière requête d&#39;interrogation.

<div id="example-request-token-post-to-token-url">
  ### Exemple de requête POST de jeton de requête vers l’URL de jeton
</div>

<AuthCodeGroup>
  ```bash cURL
  curl --request POST \
    --url 'https://{yourDomain}/oauth/token' \
    --header 'content-type: application/x-www-form-urlencoded' \
    --data 'grant_type=urn:ietf:params:oauth:grant-type:device_code' \
    --data 'device_code=YOUR_DEVICE_CODE' \
    --data 'client_id={yourClientId}'
  ```

  ```cs C#
  var client = new RestClient("https://{votreDomaine}/oauth/token");
  var request = new RestRequest(Method.POST);
  request.AddHeader("content-type", "application/x-www-form-urlencoded");
  request.AddParameter("application/x-www-form-urlencoded", "grant_type=urn%3Aietf%3Aparams%3Aoauth%3Agrant-type%3Adevice_code&device_code=YOUR_DEVICE_CODE&client_id=%24%7Baccount.clientId%7D", ParameterType.RequestBody);
  IRestResponse response = client.Execute(request);
  ```

  ```go Go
  package main

  import (
  	"fmt"
  	"strings"
  	"net/http"
  	"io/ioutil"
  )

  func main() {

  	url := "https://{yourDomain}/oauth/token"

  	payload := strings.NewReader("grant_type=urn%3Aietf%3Aparams%3Aoauth%3Agrant-type%3Adevice_code&device_code=YOUR_DEVICE_CODE&client_id=%24%7Baccount.clientId%7D")

  	req, _ := http.NewRequest("POST", url, payload)

  	req.Header.Add("content-type", "application/x-www-form-urlencoded")

  	res, _ := http.DefaultClient.Do(req)

  	defer res.Body.Close()
  	body, _ := ioutil.ReadAll(res.Body)

  	fmt.Println(res)
  	fmt.Println(string(body))

  }
  ```

  ```java Java
  HttpResponse<String> response = Unirest.post("https://{votreDomaine}/oauth/token")
    .header("content-type", "application/x-www-form-urlencoded")
    .body("grant_type=urn%3Aietf%3Aparams%3Aoauth%3Agrant-type%3Adevice_code&device_code=YOUR_DEVICE_CODE&client_id=%24%7Baccount.clientId%7D")
    .asString();
  ```

  ```javascript Node.js
  var axios = require("axios").default;

  var options = {
    method: 'POST',
    url: 'https://{yourDomain}/oauth/token',
    headers: {'content-type': 'application/x-www-form-urlencoded'},
    data: new URLSearchParams({
      grant_type: 'urn:ietf:params:oauth:grant-type:device_code',
      device_code: 'YOUR_DEVICE_CODE',
      client_id: '{yourClientId}'
    })
  };

  axios.request(options).then(function (response) {
    console.log(response.data);
  }).catch(function (error) {
    console.error(error);
  });
  ```

  ```objc Obj-C
  #import <Foundation/Foundation.h>

  NSDictionary *headers = @{ @"content-type": @"application/x-www-form-urlencoded" };

  NSMutableData *postData = [[NSMutableData alloc] initWithData:[@"grant_type=urn:ietf:params:oauth:grant-type:device_code" dataUsingEncoding:NSUTF8StringEncoding]];
  [postData appendData:[@"&device_code=YOUR_DEVICE_CODE" dataUsingEncoding:NSUTF8StringEncoding]];
  [postData appendData:[@"&client_id={yourClientId}" dataUsingEncoding:NSUTF8StringEncoding]];

  NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@"https://{yourDomain}/oauth/token"]
                                                         cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                     timeoutInterval:10.0];
  [request setHTTPMethod:@"POST"];
  [request setAllHTTPHeaderFields:headers];
  [request setHTTPBody:postData];

  NSURLSession *session = [NSURLSession sharedSession];
  NSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request
                                              completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                  if (error) {
                                                      NSLog(@"%@", error);
                                                  } else {
                                                      NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                      NSLog(@"%@", httpResponse);
                                                  }
                                              }];
  [dataTask resume];
  ```

  ```php PHP
  $curl = curl_init();

  curl_setopt_array($curl, [
    CURLOPT_URL => "https://{yourDomain}/oauth/token",
    CURLOPT_RETURNTRANSFER => true,
    CURLOPT_ENCODING => "",
    CURLOPT_MAXREDIRS => 10,
    CURLOPT_TIMEOUT => 30,
    CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
    CURLOPT_CUSTOMREQUEST => "POST",
    CURLOPT_POSTFIELDS => "grant_type=urn%3Aietf%3Aparams%3Aoauth%3Agrant-type%3Adevice_code&device_code=YOUR_DEVICE_CODE&client_id=%24%7Baccount.clientId%7D",
    CURLOPT_HTTPHEADER => [
      "content-type: application/x-www-form-urlencoded"
    ],
  ]);

  $response = curl_exec($curl);
  $err = curl_error($curl);

  curl_close($curl);

  if ($err) {
    echo "Erreur cURL no :" . $err;
  } else {
    echo $response;
  }
  ```

  ```py Python
  import http.client

  conn = http.client.HTTPSConnection("")

  payload = "grant_type=urn%3Aietf%3Aparams%3Aoauth%3Agrant-type%3Adevice_code&device_code=VOTRE_DEVICE_CODE&client_id=%24%7Baccount.clientId%7D"

  headers = { 'content-type': "application/x-www-form-urlencoded" }

  conn.request("POST", "/{yourDomain}/oauth/token", payload, headers)

  res = conn.getresponse()
  data = res.read()

  print(data.decode("utf-8"))
  ```

  ```rb Ruby
  require 'uri'
  require 'net/http'
  require 'openssl'

  url = URI("https://{yourDomain}/oauth/token")

  http = Net::HTTP.new(url.host, url.port)
  http.use_ssl = true
  http.verify_mode = OpenSSL::SSL::VERIFY_NONE

  request = Net::HTTP::Post.new(url)
  request["content-type"] = 'application/x-www-form-urlencoded'
  request.body = "grant_type=urn%3Aietf%3Aparams%3Aoauth%3Agrant-type%3Adevice_code&device_code=YOUR_DEVICE_CODE&client_id=%24%7Baccount.clientId%7D"

  response = http.request(request)
  puts response.read_body
  ```

  ```swift Swift
  import Foundation

  let headers = ["content-type": "application/x-www-form-urlencoded"]

  let postData = NSMutableData(data: "grant_type=urn:ietf:params:oauth:grant-type:device_code".data(using: String.Encoding.utf8)!)
  postData.append("&device_code=YOUR_DEVICE_CODE".data(using: String.Encoding.utf8)!)
  postData.append("&client_id={yourClientId}".data(using: String.Encoding.utf8)!)

  let request = NSMutableURLRequest(url: NSURL(string: "https://{yourDomain}/oauth/token")! as URL,
                                          cachePolicy: .useProtocolCachePolicy,
                                      timeoutInterval: 10.0)
  request.httpMethod = "POST"
  request.allHTTPHeaderFields = headers
  request.httpBody = postData as Data

  let session = URLSession.shared
  let dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in
    if (error != nil) {
      print(error)
    } else {
      let httpResponse = response as? HTTPURLResponse
      print(httpResponse)
    }
  })

  dataTask.resume()
  ```
</AuthCodeGroup>

<div id="token-request-parameters">
  #### Paramètres de requête de jeton
</div>

<table class="table">
  <thead>
    <tr>
      <th>Nom du paramètre</th>
      <th>Description</th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td><code>grant&#95;type</code></td>
      <td>Définissez ce paramètre sur « urn:ietf:params:oauth:grant-type:device&#95;code ». Il s’agit d’un type de « extension grant » (tel que défini à la section 4.5 de la <a href="https://tools.ietf.org/html/rfc6749#section-4.5">RFC 6749</a>). Notez que cette valeur doit être encodée en URL.</td>
    </tr>

    <tr>
      <td><code>device&#95;code</code></td>
      <td>Le <code>device&#95;code</code> récupéré à l’étape précédente de ce tutoriel.</td>
    </tr>

    <tr>
      <td><code>client&#95;id</code></td>
      <td>L’ID client de votre Application. Vous pouvez trouver cette valeur dans vos <a href="https://manage.auth0.com/#/Applications/{yourClientId}/settings">paramètres d’Application</a>.</td>
    </tr>
  </tbody>
</table>

<div id="token-responses">
  ### Réponses de jeton
</div>

Pendant que vous attendez que l&#39;utilisateur autorise l&#39;appareil, vous pourriez recevoir plusieurs types de réponses `HTTP 4xx` :

<div id="authorization-pending">
  #### Autorisation en attente
</div>

Vous verrez cette erreur pendant que vous attendez que l&#39;utilisateur effectue une action. Continuez l&#39;interrogation en utilisant l&#39;intervalle recommandé récupéré à l&#39;étape précédente de ce tutoriel.

```
`HTTP 403`

{
  "error": "authorization_pending",
  "error_description": "..."
}
```

<div id="slow-down">
  #### Ralentissez
</div>

Vous interrogez le serveur trop fréquemment. Ralentissez et utilisez l’intervalle suggéré récupéré à l’étape précédente de ce tutoriel. Pour éviter de recevoir cette erreur en raison de la latence du réseau, vous devriez commencer à compter chaque intervalle à partir de la réception de la réponse à la dernière requête d’interrogation.

```
`HTTP 429`

{
  "error": "slow_down",
  "error_description": "..."
}
```

<div id="expired-token">
  #### Jeton expiré
</div>

L’utilisateur n’a pas autorisé l’appareil assez rapidement, donc le `device_code` a expiré. Votre application doit informer l’utilisateur que le flux a expiré et l’inviter à relancer le flux.

<Info>
  L’erreur `expired_token` ne sera renvoyée qu’une seule fois ; ensuite, la redoutable `invalid_grant` sera renvoyée. Votre appareil *doit* arrêter le polling.
</Info>

```
`HTTP 403`

{ 
  "error": "expired_token",
  "error_description": "..."
}
```

<div id="access-denied">
  #### Accès refusé
</div>

Enfin, si l&#39;accès est refusé, vous recevrez :

```
`HTTP 403`

{
  "error": "access_denied",
  "error_description": "..."
}
```

Cela peut se produire pour diverses raisons, notamment :

* l&#39;utilisateur a refusé d&#39;autoriser l&#39;appareil
* le Serveur d’autorisation a refusé la transaction
* une [Rule](/docs/fr-CA/customize/rules) configurée a refusé l&#39;accès

<div id="user-authorization">
  ## Autorisation de l&#39;utilisateur
</div>

L&#39;utilisateur scannera le code QR ou ouvrira la page d&#39;activation et saisira le code utilisateur :

<Frame>![Enter User Code](https://cdn2.auth0.com/docs/1.14550.0/media/articles/flows/guides/device-auth/enter-user-code.png)</Frame>

Une page de confirmation s&#39;affichera pour permettre à l&#39;utilisateur de confirmer qu&#39;il s&#39;agit du bon appareil :

<Frame>![Confirm Device](https://cdn2.auth0.com/docs/1.14550.0/media/articles/flows/guides/device-auth/confirm-device.png)</Frame>

L&#39;utilisateur terminera la transaction en se connectant. Cette étape peut inclure un ou plusieurs des processus suivants :

* Authentifier l&#39;utilisateur ;
* Rediriger l&#39;utilisateur vers un fournisseur d&#39;identité pour gérer l&#39;authentification ;
* Vérifier la présence de sessions SSO actives ;
* Obtenir le consentement de l&#39;utilisateur pour l&#39;appareil, à moins que ce consentement n&#39;ait déjà été donné.

<Frame>![Authenticate User](https://cdn2.auth0.com/docs/1.14550.0/media/articles/flows/guides/device-auth/user-auth.png)</Frame>

Une fois l&#39;authentification et le consentement effectués, l&#39;invite de confirmation s&#39;affichera :

<Frame>![User Confirmation](https://cdn2.auth0.com/docs/1.14550.0/media/articles/flows/guides/device-auth/user-confirmation.png)</Frame>

À ce stade, l&#39;utilisateur est authentifié et l&#39;appareil est autorisé.

<div id="receive-tokens">
  ## Recevoir les jetons
</div>

Pendant que l’utilisateur authentifie et autorise l’appareil, l’application sur l’appareil continue d’interroger l’URL du jeton pour demander un jeton d’accès.

Une fois que l’utilisateur a autorisé l’appareil avec succès, vous recevrez une réponse `HTTP 200` dont le contenu contient les valeurs `access_token`, `refresh_token` (facultatif), `id_token` (facultatif), `token_type` et `expires_in` :

```json lines
{
  "access_token":"eyJz93a...k4laUWw",
  "refresh_token":"GEbRxBN...edjnXbL",
  "id_token": "eyJ0XAi...4faeEoQ",
  "token_type":"Bearer",
  "expires_in":86400
}
```

<Warning>
  Vous devez valider vos jetons avant de les enregistrer. Pour savoir comment procéder, consultez [Valider les jetons d’accès](/docs/fr-CA/secure/tokens/access-tokens/validate-access-tokens) et [Valider les jetons d’identité](/docs/fr-CA/secure/tokens/id-tokens/validate-id-tokens).
</Warning>

Les [jetons d’accès](/docs/fr-CA/secure/tokens/access-tokens) sont utilisés pour appeler le [point de terminaison `/userinfo` de l’Authentication API d’Auth0](https://auth0.com/docs/api/authentication#get-user-info) ou une autre API. Vous pourrez utiliser le jeton d’accès pour appeler `/userinfo` uniquement si vous avez inclus la portée `openid`. Si vous appelez votre propre API, la première chose que votre API devra faire consiste à [vérifier le jeton d’accès](/docs/fr-CA/secure/tokens/access-tokens/validate-access-tokens).

Les [jetons d’identité](/docs/fr-CA/secure/tokens/id-tokens) contiennent des renseignements sur l’utilisateur qui doivent être [décodés et extraits](/docs/fr-CA/secure/tokens/id-tokens#id-token-payload). L’`id_token` ne sera présent dans la réponse que si vous avez inclus la portée `openid`.

Les [Jetons d’actualisation](/docs/fr-CA/secure/tokens/refresh-tokens) sont utilisés pour obtenir un nouveau jeton d’accès ou un jeton d’identité après l’expiration du précédent. Le `refresh_token` ne sera présent dans la réponse que si vous avez inclus la portée `offline_access` et activé **Allow Offline Access** pour votre API dans le Dashboard.

<Warning>
  Les Jetons d’actualisation doivent être stockés de façon sécuritaire, car ils permettent à un utilisateur de rester authentifié pratiquement indéfiniment.
</Warning>

<div id="call-your-api">
  ## Appeler votre API
</div>

Pour appeler votre API, l&#39;application doit envoyer le jeton d’accès obtenu comme jeton Bearer dans l’en-tête Authorization de votre requête HTTP.

<AuthCodeGroup>
  ```bash cURL lines
  curl --request GET \
    --url https://myapi.com/api \
    --header 'authorization: Bearer ACCESS_TOKEN' \
    --header 'content-type: application/json'
  ```

  ```javascript Node.JS lines
  var client = new RestClient("https://myapi.com/api");
  var request = new RestRequest(Method.GET);
  request.AddHeader("content-type", "application/json");
  request.AddHeader("authorization", "Bearer ACCESS_TOKEN");
  IRestResponse response = client.Execute(request);
  ```

  ```go Go lines
  package main

  import (
  	"fmt"
  	"net/http"
  	"io/ioutil"
  )

  func main() {

  	url := "https://myapi.com/api"

  	req, _ := http.NewRequest("GET", url, nil)

  	req.Header.Add("content-type", "application/json")
  	req.Header.Add("authorization", "Bearer ACCESS_TOKEN")

  	res, _ := http.DefaultClient.Do(req)

  	defer res.Body.Close()
  	body, _ := ioutil.ReadAll(res.Body)

  	fmt.Println(res)
  	fmt.Println(string(body))

  }
  ```

  ```java Java lines
  HttpResponse<String> response = Unirest.get("https://myapi.com/api")
    .header("content-type", "application/json")
    .header("authorization", "Bearer ACCESS_TOKEN")
    .asString();
  ```

  ```javascript Node.JS lines
  var axios = require("axios").default;

  var options = {
    method: 'GET',
    url: 'https://myapi.com/api',
    headers: {'content-type': 'application/json', authorization: 'Bearer ACCESS_TOKEN'}
  };

  axios.request(options).then(function (response) {
    console.log(response.data);
  }).catch(function (error) {
    console.error(error);
  });
  ```

  ```objc Obj-C lines
  #import <Foundation/Foundation.h>

  NSDictionary *headers = @{ @"content-type": @"application/json",
                             @"authorization": @"Bearer ACCESS_TOKEN" };

  NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@"https://myapi.com/api"]
                                                         cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                     timeoutInterval:10.0];
  [request setHTTPMethod:@"GET"];
  [request setAllHTTPHeaderFields:headers];

  NSURLSession *session = [NSURLSession sharedSession];
  NSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request
                                              completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                  if (error) {
                                                      NSLog(@"%@", error);
                                                  } else {
                                                      NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                      NSLog(@"%@", httpResponse);
                                                  }
                                              }];
  [dataTask resume];
  ```

  ```php PHP lines
  $curl = curl_init();

  curl_setopt_array($curl, [
    CURLOPT_URL => "https://myapi.com/api",
    CURLOPT_RETURNTRANSFER => true,
    CURLOPT_ENCODING => "",
    CURLOPT_MAXREDIRS => 10,
    CURLOPT_TIMEOUT => 30,
    CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
    CURLOPT_CUSTOMREQUEST => "GET",
    CURLOPT_HTTPHEADER => [
      "authorization: Bearer ACCESS_TOKEN",
      "content-type: application/json"
    ],
  ]);

  $response = curl_exec($curl);
  $err = curl_error($curl);

  curl_close($curl);

  if ($err) {
    echo "Erreur cURL no :" . $err;
  } else {
    echo $response;
  }
  ```

  ```python Python lines
  import http.client

  conn = http.client.HTTPSConnection("myapi.com")

  headers = {
      'content-type': "application/json",
      'authorization': "Bearer ACCESS_TOKEN"
      }

  conn.request("GET", "/api", headers=headers)

  res = conn.getresponse()
  data = res.read()

  print(data.decode("utf-8"))
  ```

  ```rb Ruby lines
  require 'uri'
  require 'net/http'
  require 'openssl'

  url = URI("https://myapi.com/api")

  http = Net::HTTP.new(url.host, url.port)
  http.use_ssl = true
  http.verify_mode = OpenSSL::SSL::VERIFY_NONE

  request = Net::HTTP::Get.new(url)
  request["content-type"] = 'application/json'
  request["authorization"] = 'Bearer JETON_D_ACCÈS'

  response = http.request(request)
  puts response.read_body
  ```

  ```swift Swift lines
  import Foundation

  let headers = [
    "content-type": "application/json",
    "authorization": "Bearer ACCESS_TOKEN"
  ]

  let request = NSMutableURLRequest(url: NSURL(string: "https://myapi.com/api")! as URL,
                                          cachePolicy: .useProtocolCachePolicy,
                                      timeoutInterval: 10.0)
  request.httpMethod = "GET"
  request.allHTTPHeaderFields = headers

  let session = URLSession.shared
  let dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in
    if (error != nil) {
      print(error)
    } else {
      let httpResponse = response as? HTTPURLResponse
      print(httpResponse)
    }
  })

  dataTask.resume()
  ```
</AuthCodeGroup>

<div id="refresh-tokens">
  ## Jetons d’actualisation
</div>

Vous avez déjà reçu un [Jeton d’actualisation](/docs/fr-CA/secure/tokens/refresh-tokens) si vous avez suivi ce tutoriel et effectué les opérations suivantes :

* configuré votre API pour autoriser l’accès hors connexion
* inclus la portée `offline_access` lorsque vous avez lancé la requête d’authentification au moyen du point de terminaison [authorize](https://auth0.com/docs/api/authentication#authorize-application)

Vous pouvez utiliser le Jeton d’actualisation pour obtenir un nouveau jeton d’accès. En général, un utilisateur aura besoin d’un nouveau jeton d’accès seulement après l’expiration du précédent ou lorsqu’il accède à une nouvelle ressource pour la première fois. Ce n’est pas une bonne pratique d’appeler le point de terminaison pour obtenir un nouveau jeton d’accès chaque fois que vous appelez une API, et Auth0 applique des limites de débit qui limitent le nombre de requêtes vers ce point de terminaison pouvant être exécutées avec le même jeton à partir de la même adresse IP.

Pour actualiser votre jeton, faites une requête `POST` vers le point de terminaison `/oauth/token` dans l’Authentication API, en utilisant `grant_type=refresh_token`.

<div id="example-refresh-token-post-to-token-url">
  ### Exemple de requête POST de jeton d’actualisation vers l’URL du jeton
</div>

<AuthCodeGroup>
  ```bash cURL
  curl --request POST \
    --url 'https://{yourDomain}/oauth/token' \
    --header 'content-type: application/x-www-form-urlencoded' \
    --data grant_type=refresh_token \
    --data 'client_id={yourClientId}' \
    --data 'client_secret={yourClientSecret}' \
    --data refresh_token=YOUR_REFRESH_TOKEN
  ```

  ```javascript C#
  var client = new RestClient("https://{yourDomain}/oauth/token");
  var request = new RestRequest(Method.POST);
  request.AddHeader("content-type", "application/x-www-form-urlencoded");
  request.AddParameter("application/x-www-form-urlencoded", "grant_type=refresh_token&client_id=%24%7Baccount.clientId%7D&client_secret=%24%7Baccount.clientSecret%7D&refresh_token=YOUR_REFRESH_TOKEN", ParameterType.RequestBody);
  IRestResponse response = client.Execute(request);
  ```

  ```go Go
  package main

  import (
  	"fmt"
  	"strings"
  	"net/http"
  	"io/ioutil"
  )

  func main() {

  	url := "https://{votreDomaine}/oauth/token"

  	payload := strings.NewReader("grant_type=refresh_token&client_id=%24%7Baccount.clientId%7D&client_secret=%24%7Baccount.clientSecret%7D&refresh_token=YOUR_REFRESH_TOKEN")

  	req, _ := http.NewRequest("POST", url, payload)

  	req.Header.Add("content-type", "application/x-www-form-urlencoded")

  	res, _ := http.DefaultClient.Do(req)

  	defer res.Body.Close()
  	body, _ := ioutil.ReadAll(res.Body)

  	fmt.Println(res)
  	fmt.Println(string(body))

  }
  ```

  ```java Java
  HttpResponse<String> response = Unirest.post("https://{yourDomain}/oauth/token")
    .header("content-type", "application/x-www-form-urlencoded")
    .body("grant_type=refresh_token&client_id=%24%7Baccount.clientId%7D&client_secret=%24%7Baccount.clientSecret%7D&refresh_token=YOUR_REFRESH_TOKEN")
    .asString();
  ```

  ```javascript Node.JS
  var axios = require("axios").default;

  var options = {
    method: 'POST',
    url: 'https://{yourDomain}/oauth/token',
    headers: {'content-type': 'application/x-www-form-urlencoded'},
    data: new URLSearchParams({
      grant_type: 'refresh_token',
      client_id: '{yourClientId}',
      client_secret: '{yourClientSecret}',
      refresh_token: 'YOUR_REFRESH_TOKEN'
    })
  };

  axios.request(options).then(function (response) {
    console.log(response.data);
  }).catch(function (error) {
    console.error(error);
  });
  ```

  ```objc Obj-C
  #import <Foundation/Foundation.h>

  NSDictionary *headers = @{ @"content-type": @"application/x-www-form-urlencoded" };

  NSMutableData *postData = [[NSMutableData alloc] initWithData:[@"grant_type=refresh_token" dataUsingEncoding:NSUTF8StringEncoding]];
  [postData appendData:[@"&client_id={yourClientId}" dataUsingEncoding:NSUTF8StringEncoding]];
  [postData appendData:[@"&client_secret={yourClientSecret}" dataUsingEncoding:NSUTF8StringEncoding]];
  [postData appendData:[@"&refresh_token=YOUR_REFRESH_TOKEN" dataUsingEncoding:NSUTF8StringEncoding]];

  NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@"https://{yourDomain}/oauth/token"]
                                                         cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                     timeoutInterval:10.0];
  [request setHTTPMethod:@"POST"];
  [request setAllHTTPHeaderFields:headers];
  [request setHTTPBody:postData];

  NSURLSession *session = [NSURLSession sharedSession];
  NSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request
                                              completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                  if (error) {
                                                      NSLog(@"%@", error);
                                                  } else {
                                                      NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                      NSLog(@"%@", httpResponse);
                                                  }
                                              }];
  [dataTask resume];
  ```

  ```php PHP
  $curl = curl_init();

  curl_setopt_array($curl, [
    CURLOPT_URL => "https://{yourDomain}/oauth/token",
    CURLOPT_RETURNTRANSFER => true,
    CURLOPT_ENCODING => "",
    CURLOPT_MAXREDIRS => 10,
    CURLOPT_TIMEOUT => 30,
    CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
    CURLOPT_CUSTOMREQUEST => "POST",
    CURLOPT_POSTFIELDS => "grant_type=refresh_token&client_id=%24%7Baccount.clientId%7D&client_secret=%24%7Baccount.clientSecret%7D&refresh_token=YOUR_REFRESH_TOKEN",
    CURLOPT_HTTPHEADER => [
      "content-type: application/x-www-form-urlencoded"
    ],
  ]);

  $response = curl_exec($curl);
  $err = curl_error($curl);

  curl_close($curl);

  if ($err) {
    echo "Erreur cURL no : " . $err;
  } else {
    echo $response;
  }
  ```

  ```python Python
  import http.client

  conn = http.client.HTTPSConnection("")

  payload = "grant_type=refresh_token&client_id=%24%7Baccount.clientId%7D&client_secret=%24%7Baccount.clientSecret%7D&refresh_token=VOTRE_JETON_ACTUALISATION"

  headers = { 'content-type': "application/x-www-form-urlencoded" }

  conn.request("POST", "/{yourDomain}/oauth/token", payload, headers)

  res = conn.getresponse()
  data = res.read()

  print(data.decode("utf-8"))
  ```

  ```ruby Ruby
  require 'uri'
  require 'net/http'
  require 'openssl'

  url = URI("https://{yourDomain}/oauth/token")

  http = Net::HTTP.new(url.host, url.port)
  http.use_ssl = true
  http.verify_mode = OpenSSL::SSL::VERIFY_NONE

  request = Net::HTTP::Post.new(url)
  request["content-type"] = 'application/x-www-form-urlencoded'
  request.body = "grant_type=refresh_token&client_id=%24%7Baccount.clientId%7D&client_secret=%24%7Baccount.clientSecret%7D&refresh_token=YOUR_REFRESH_TOKEN"

  response = http.request(request)
  puts response.read_body
  ```

  ```swift Swift
  import Foundation

  let headers = ["content-type": "application/x-www-form-urlencoded"]

  let postData = NSMutableData(data: "grant_type=refresh_token".data(using: String.Encoding.utf8)!)
  postData.append("&client_id={yourClientId}".data(using: String.Encoding.utf8)!)
  postData.append("&client_secret={yourClientSecret}".data(using: String.Encoding.utf8)!)
  postData.append("&refresh_token=YOUR_REFRESH_TOKEN".data(using: String.Encoding.utf8)!)

  let request = NSMutableURLRequest(url: NSURL(string: "https://{yourDomain}/oauth/token")! as URL,
                                          cachePolicy: .useProtocolCachePolicy,
                                      timeoutInterval: 10.0)
  request.httpMethod = "POST"
  request.allHTTPHeaderFields = headers
  request.httpBody = postData as Data

  let session = URLSession.shared
  let dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in
    if (error != nil) {
      print(error)
    } else {
      let httpResponse = response as? HTTPURLResponse
      print(httpResponse)
    }
  })

  dataTask.resume()
  ```
</AuthCodeGroup>

<div id="refresh-token-request-parameters">
  #### Paramètres de la requête de Jeton d’actualisation
</div>

<table class="table">
  <thead>
    <tr>
      <th>Nom du paramètre</th>
      <th>Description</th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td><code>grant&#95;type</code></td>
      <td>Définissez ce paramètre sur « refresh&#95;token ».</td>
    </tr>

    <tr>
      <td><code>client&#95;id</code></td>
      <td>L’ID client de votre application. Vous pouvez trouver cette valeur dans vos <a href="https://manage.auth0.com/#/Applications/{yourClientId}/settings">paramètres d’Application</a>.</td>
    </tr>

    <tr>
      <td><code>client&#95;secret</code></td>
      <td>Le Secret client de votre application. Vous pouvez trouver cette valeur dans vos <a href="https://manage.auth0.com/#/Applications/{yourClientSecret}/settings">paramètres d’Application</a>.</td>
    </tr>

    <tr>
      <td><code>refresh&#95;token</code></td>
      <td>Le Jeton d’actualisation à utiliser.</td>
    </tr>

    <tr>
      <td><code>scope</code></td>
      <td>(Facultatif) Une liste, délimitée par des espaces, des autorisations (scopes) demandées. Si ce paramètre n’est pas envoyé, les scopes d’origine seront utilisés ; sinon, vous pouvez demander un ensemble réduit de scopes. Notez que cette valeur doit être encodée dans l’URL.</td>
    </tr>
  </tbody>
</table>

<div id="refresh-token-response">
  ### Réponse de Jeton d’actualisation
</div>

Si tout se passe bien, vous recevrez une réponse `HTTP 200` avec un corps contenant un nouvel `access_token`, un `id_token` (facultatif), la durée de vie du jeton en secondes (`expires_in`), les valeurs de `scope` accordées et le `token_type` :

```json lines
{
  "access_token": "eyJ...MoQ",
  "expires_in": 86400,
  "scope": "openid offline_access",
  "id_token": "eyJ...0NE",
  "token_type": "Bearer"
}
```

<Warning>
  Vous devez valider vos jetons avant de les stocker. Pour savoir comment faire, consultez [Valider les jetons d’accès](/docs/fr-CA/secure/tokens/access-tokens/validate-access-tokens) et [Valider les jetons ID](/docs/fr-CA/secure/tokens/id-tokens/validate-id-tokens).
</Warning>

<div id="sample-use-cases">
  ## Exemples de cas d’utilisation
</div>

<div id="detect-device-authorization-flow-use">
  ### Détecter l’utilisation du Device Authorization Flow
</div>

Vous pouvez utiliser les [Rules](/docs/fr-CA/customize/rules) pour détecter si la transaction en cours utilise le Device Authorization Flow. Pour ce faire, vérifiez la propriété `protocol` de l’objet `context` :

```javascript lines
function (user, context, callback) {
   if (context.protocol === 'oauth2-device-code') {
      ...
   }
 
   callback(null, user, context);
}
```

<div id="sample-implementations">
  ### Exemples d’implémentation
</div>

* [Device Authorization Playground](https://auth0.github.io/device-flow-playground/)
* [Apple TV (Swift)](https://github.com/pushpabrol/auth0-device-flow-appletv) : Application simple qui montre comment Auth0 peut être utilisé avec le Device Authorization Flow à partir d’une Apple TV.
* [CLI (Node.js)](https://gist.github.com/panva/652c61e7d847e0ed99926c324fa91b36) : Exemple d’implémentation d’un outil CLI qui utilise le Device Authorization Flow plutôt que l’Authorization Code Flow. La principale différence est que votre CLI n’a pas besoin d’héberger un serveur web ni d’être à l’écoute sur un port.

<div id="troubleshooting">
  # Dépannage
</div>

Les [journaux du tenant](/docs/fr-CA/deploy-monitor/logs) sont créés pour toute interaction et peuvent servir à résoudre des problèmes.

<div id="error-codes">
  ## Codes d&#39;erreur
</div>

<table class="table">
  <thead>
    <tr>
      <th>Code</th>
      <th>Nom</th>
      <th>Description</th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td><code>fdeaz</code></td>
      <td>Échec de la demande d&#39;autorisation d&#39;appareil</td>

      <td />
    </tr>

    <tr>
      <td><code>fdeac</code></td>
      <td>Échec de l&#39;activation de l&#39;appareil</td>

      <td />
    </tr>

    <tr>
      <td><code>fdecc</code></td>
      <td>L&#39;utilisateur a annulé la confirmation de l&#39;appareil</td>

      <td />
    </tr>

    <tr>
      <td><code>fede</code></td>
      <td>Échec de l&#39;échange</td>
      <td>Code d&#39;appareil pour jeton d&#39;accès</td>
    </tr>

    <tr>
      <td><code>sede</code></td>
      <td>Échange réussi</td>
      <td>Code d&#39;appareil pour jeton d&#39;accès</td>
    </tr>
  </tbody>
</table>

<div id="limitations">
  ## Limitations
</div>

Pour utiliser le Device Authorization Flow, les appareils doivent :

* Prendre en charge Server Name Indication (SNI)
* Avoir un [type d’Application Auth0](/docs/fr-CA/get-started/applications) de **Native**
* Avoir le paramètre [**Token Endpoint Authentication Method**](/docs/fr-CA/get-started/applications/application-settings) défini sur **None**
* Être conformes à [OIDC](/docs/fr-CA/get-started/applications/application-settings#oauth)
* Ne pas être créés au moyen de la [Dynamic Client Registration](/docs/fr-CA/get-started/applications/dynamic-client-registration)

De plus, le Device Authorization Flow ne permet pas :

* Les [Connexions sociales](/docs/fr-CA/authenticate/identity-providers) utilisant les [clés pour développeurs Auth0](/docs/fr-CA/authenticate/identity-providers/social-identity-providers/devkeys), à moins que vous n’utilisiez la [nouvelle expérience Universal Login](/docs/fr-CA/authenticate/login/auth0-universal-login/universal-login-vs-classic-login/universal-experience).
* L’accès aux paramètres de chaîne de requête à partir de la page de connexion hébergée ou des Rules

Nous prenons en charge l’intégralité du [Draft 15](https://tools.ietf.org/html/draft-ietf-oauth-device-flow-15), sauf pour les Clients confidentiels.

<div id="keep-reading">
  ## Pour aller plus loin
</div>

* [Le protocole OAuth 2.0](/docs/fr-CA/authenticate/protocols/oauth)
* [Le protocole OpenID Connect](/docs/fr-CA/authenticate/protocols/openid-connect-protocol)
* [Jetons](/docs/fr-CA/secure/tokens)
* [Journaux du tenant pour les appareils](/docs/fr-CA/deploy-monitor/logs)

[Modifier sur GitHub](https://github.com/auth0/docs/edit/master/articles/quickstart/native/device/01-login.md)