---
title: Flux d’autorisation de l’appareil

---

import { Recipe, Content, Section, SideMenu, SideMenuSectionItem, SignUpForm } from "/snippets/fr-CA/recipe.jsx";
import { LoggedInForm } from "/snippets/fr-CA/Login.jsx";

import {AuthCodeGroup} from "/snippets/fr-CA/AuthCodeGroup.jsx";

export const sections = [
  { id: "prerequisites", title: "Prérequis" },
  { id: "request-device-code", title: "Demander un code d’appareil" },
  { id: "receive-device-code", title: "Recevoir le code d’appareil" },
  { id: "request-device-activation", title: "Demander l’activation de l’appareil" },
  { id: "poll-the-token-endpoint", title: "Interroger le point de terminaison de jeton" },
  { id: "user-authorization", title: "Autorisation de l’utilisateur" },
  { id: "receive-tokens", title: "Recevoir les jetons" },
  { id: "call-your-api", title: "Appeler votre API" },
  { id: "refresh-tokens", title: "Actualiser les jetons" },
  { id: "troubleshooting", title: "Dépannage" },
  { id: "sample-implementations", title: "Exemples d’implémentation" },
  { id: "limitations", title: "Limitations" }
]

<Recipe isSingleColumn>
  <Content>
    Ce tutoriel montre comment appeler votre API à partir d&#39;un appareil à saisie limitée en utilisant le flux d&#39;autorisation d&#39;appareil (Device Authorization Flow). Nous vous recommandons de vous connecter pour
    suivre ce démarrage rapide avec des exemples configurés pour votre compte.

    Pour une expérience interactive, vous pouvez utiliser le [terrain d&#39;essai Device Flow](https://auth0.github.io/device-flow-playground/).

    <Section id={sections[0].id} title={sections[0].title} stepNumber="1" isSingleColumn>
      * Enregistrez une Application native.
      * Assurez-vous que l’option **OIDC Conformant** est activée. Pour en savoir plus, consultez OIDC-Conformant Authentication.
      * Ajoutez **Device Code** aux types d’octroi de l’Application. Pour en savoir plus, consultez Update Grant Types.
      * Ajoutez **Jeton d’actualisation** aux types d’octroi de l’Application si vous voulez activer les Jetons d’actualisation.
      * Configurez et activez au moins une connexion pour
        l’application.
      * Enregistrez votre API auprès d’Auth0.
      * Activez **Allow Offline Access** si vous utilisez des jetons d’actualisation. Pour en savoir plus, consultez API Settings.
      * Configurez **Device User Code Settings** pour définir l’ensemble de caractères, le format et la longueur de votre code d’utilisateur généré aléatoirement.

      <LoggedInForm />
    </Section>

    <Section id={sections[1].id} title={sections[1].title} stepNumber="2" isSingleColumn>
      Lorsque l&#39;utilisateur démarre l&#39;application de l&#39;appareil et souhaite l&#39;autoriser, votre application doit demander un code d&#39;appareil à l&#39;Authentication API Auth0 pour l&#39;associer à la session de l&#39;utilisateur.

      Pour obtenir le code d&#39;appareil, votre application doit appeler le [point de terminaison Authorize](https://auth0.com/docs/api/authentication#-post-oauth-device-code-) du flux Device Authorization de l&#39;Authentication API :

      <AuthCodeGroup>
        ```bash cURL lines
        curl --request post \
          --url 'https://{yourDomain}/oauth/device/code' \
          --header 'content-type: application/x-www-form-urlencoded'
        ```

        ```csharp C# lines
        var client = new RestClient("https://{yourDomain}/oauth/device/code");
        var request = new RestRequest(Method.POST);
        request.AddHeader("content-type", "application/x-www-form-urlencoded");
        IRestResponse response = client.Execute(request);
        ```

        ```go Go lines 
        package main
        import (
        "fmt"
        "net/http"
        "io/ioutil"
        )
        func main() {
        url := "https://{yourDomain}/oauth/device/code"
        req, _ := http.NewRequest("post", url, nil)
        req.Header.Add("content-type", "application/x-www-form-urlencoded")
        res, _ := http.DefaultClient.Do(req)
        defer res.Body.Close()
        body, _ := ioutil.ReadAll(res.Body)
        fmt.Println(res)
        fmt.Println(string(body))
        }
        ```

        ```java Java lines
        HttpResponse<String> response = Unirest.post("https://{yourDomain}/oauth/device/code")
          .header("content-type", "application/x-www-form-urlencoded")
          .asString();
        ```

        ```javascript Node.JS lines
        var axios = require("axios").default;
        var options = {
        method: 'post',
        url: 'https://{yourDomain}/oauth/device/code',
        headers: {'content-type': 'application/x-www-form-urlencoded'}
        };
        axios.request(options).then(function (response) {
        console.log(response.data);
        }).catch(function (error) {
        console.error(error);
        });
        ```

        ```objc Obj-C lines 
        #import <Foundation/Foundation.h>
        NSDictionary *headers = @{ @"content-type": @"application/x-www-form-urlencoded" };
        NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@"https://{yourDomain}/oauth/device/code"]
                                                          cachePolicy:NSURLRequestUseProtocolCachePolicy

                                                      timeoutInterval:10.0];

        [request setHTTPMethod:@"post"];
        [request setAllHTTPHeaderFields:headers];
        NSURLSession *session = [NSURLSession sharedSession];
        NSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request
                                                completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {

                                                    if (error) {

                                                        NSLog(@&quot;%@&quot;, error);

                                                    } else {

                                                        NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;

                                                        NSLog(@&quot;%@&quot;, httpResponse);

                                                    }

                                                }];

        [dataTask resume];
        ```

        ```php PHP lines 
        $curl = curl_init();
        curl_setopt_array($curl, [
        CURLOPT_URL => "https://{yourDomain}/oauth/device/code",
        CURLOPT_RETURNTRANSFER => true,
        CURLOPT_ENCODING => "",
        CURLOPT_MAXREDIRS => 10,
        CURLOPT_TIMEOUT => 30,
        CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
        CURLOPT_CUSTOMREQUEST => "post",
        CURLOPT_HTTPHEADER => [
        &quot;content-type: application/x-www-form-urlencoded&quot;

        ],
        ]);
        $response = curl_exec($curl);
        $err = curl_error($curl);
        curl_close($curl);
        if ($err) {
        echo "cURL Error #:" . $err;
        } else {
        echo $response;
        }
        ```

        ```python Python lines
        import http.client
        conn = http.client.HTTPSConnection("")
        headers = { 'content-type': "application/x-www-form-urlencoded" }
        conn.request("post", "/{yourDomain}/oauth/device/code", headers=headers)
        res = conn.getresponse()
        data = res.read()
        print(data.decode("utf-8"))
        ```

        ```ruby Ruby lines
        require 'uri'
        require 'net/http'
        require 'openssl'
        url = URI("https://{yourDomain}/oauth/device/code")
        http = Net::HTTP.new(url.host, url.port)
        http.use_ssl = true
        http.verify_mode = OpenSSL::SSL::VERIFY_NONE
        request = Net::HTTP::Post.new(url)
        request["content-type"] = 'application/x-www-form-urlencoded'
        response = http.request(request)
        puts response.read_body
        ```

        ```swift Swift lines 
        import Foundation
        let headers = ["content-type": "application/x-www-form-urlencoded"]
        let request = NSMutableURLRequest(url: NSURL(string: "https://{yourDomain}/oauth/device/code")! as URL,
                                            cachePolicy: .useProtocolCachePolicy,

                                        timeoutInterval: 10.0)

        request.httpMethod = "post"
        request.allHTTPHeaderFields = headers
        let session = URLSession.shared
        let dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in
        if (error != nil) {
        print(error)

        } else {
        let httpResponse = response as? HTTPURLResponse

        print(httpResponse)

        }
        })
        dataTask.resume()
        ```
      </AuthCodeGroup>

      <LoggedInForm />
    </Section>

    <Section id={sections[2].id} title={sections[2].title} stepNumber="3" isSingleColumn>
      L&#39;application sur l&#39;appareil devrait recevoir une réponse HTTP 200 et un corps de réponse semblable à ce qui suit :

      ```json lines
      {
        "device_code": "GmRh...k9eS",
        "user_code": "WDJB-MJHT",
        "verification_uri": "https://my-tenant.auth0.com/device",
        "verification_uri_complete": "https://my-tenant.auth0.com/device?user_code=WDJB-MJHT",
        "expires_in": 900,
        "interval": 5
      }
      ```

      <LoggedInForm />
    </Section>

    <Section id={sections[3].id} title={sections[3].title} stepNumber="4" isSingleColumn>
      Après que votre application sur l’appareil a reçu le `device_code` et le `user_code`, elle doit indiquer à l’utilisateur d’accéder à l’`verification_uri` et d’y saisir le `user_code`.

      <Frame>
        <img src="/docs/images/cdy7uua7fh8z/3Q9q41wocl6SojRoiGefXT/a98582a3c86740aaeb3d957f2dc4afe6/request-device-activation.png" />
      </Frame>

      <Info>
        Le `device_code` n’est pas destiné directement à l’utilisateur et ne doit pas être affiché pendant l’interaction afin d’éviter de le confondre.
      </Info>

      <Info>
        Lorsque vous créez une interface de ligne de commande (CLI), vous pouvez ignorer cette étape et ouvrir immédiatement le navigateur avec `verification_uri_complete`.
      </Info>

      <LoggedInForm />
    </Section>

    <Section id={sections[4].id} title={sections[4].title} stepNumber="5" isSingleColumn>
      Pendant que votre application sur l’appareil attend que l’utilisateur l’active, elle doit appeler l’Authentication API [point de terminaison POST /oauth/token](https://auth0.com/docs/api/authentication#-post-oauth-token-) à intervalles réguliers
      et traiter la réponse en conséquence.

      <Info>
        Assurez-vous que votre application sur l’appareil attend pendant toute la durée de `interval` (en secondes) ou jusqu’à
        ce qu’elle reçoive une réponse indiquant un succès, selon la plus longue des deux, afin d’éviter les problèmes de latence réseau.
      </Info>

      ```bash
      curl --request POST \ 
        --url 'https://{yourDomain}/oauth/token' \
        --header 'content-type: application/x-www-form-urlencoded' \
        --data grant_type=urn:ietf:params:oauth:grant-type:device_code \
        --data device_code=AUTH0_SCOPES \
        --data 'client_id={yourClientId}'
      ```

      <LoggedInForm />
    </Section>

    <Section id={sections[5].id} title={sections[5].title} stepNumber="6" isSingleColumn>
      L&#39;utilisateur peut soit scanner le code QR, soit ouvrir la page d’activation et entrer le code utilisateur :

      <Frame>
        <img src="/docs/images/cdy7uua7fh8z/7IwrVX4s5a36CvfY95rKCo/dfc962ecde65502945741b1dc8b5c879/Device_Activation_-_English.png" />
      </Frame>

      Une page de confirmation s’affichera pour permettre à l’utilisateur de confirmer qu’il s’agit du bon appareil :

      <Frame>
        <img src="/docs/images/cdy7uua7fh8z/5dwhOyM1HRNwfV3Co4Da2o/424a2bc1a1bb44a54c587a0bcddd8222/Device_Confirmation_-_English.png" />
      </Frame>

      L’utilisateur terminera la transaction en ouvrant une session. Cette étape peut inclure un ou plusieurs des
      processus suivants :

      * Authentifier l’utilisateur
      * Rediriger l’utilisateur vers un fournisseur d&#39;identité pour gérer l’authentification
      * Vérifier la présence de sessions SSO actives
      * Obtenir le consentement de l’utilisateur pour l’appareil, à moins que le consentement n’ait déjà été donné

      <Frame>
        <img src="/docs/images/cdy7uua7fh8z/3GqqaNB7sjcAYTQiTnEEsn/7199a9b319283686057ca32c853f7a05/Login_screen_-_English.png" />
      </Frame>

      Une fois l’authentification et le consentement effectués, l’invite de confirmation s’affichera :

      <Frame>
        <img src="/docs/images/cdy7uua7fh8z/2TsQpMa8fzifiojuEXLvDo/484a49b775ec5a6b3522983a425599fe/Success_message_-_English.png" />
      </Frame>

      À ce stade, l’utilisateur s’est authentifié et l’appareil a été autorisé.

      <LoggedInForm />
    </Section>

    <Section id={sections[6].id} title={sections[6].title} stepNumber="7" isSingleColumn>
      Après que l’utilisateur a autorisé l’application sur l’appareil, celle-ci reçoit une réponse HTTP 200 et le corps de réponse suivant :

      ```json lines
      {
        "access_token": "eyJz93a...k4laUWw",
        "refresh_token": "GEbRxBN...edjnXbL",
        "id_token": "eyJ0XAi...4faeEoQ",
        "token_type": "Bearer",
        "expires_in": 86400
      }
      ```

      <Info>
        Vous devez valider vos jetons avant de les enregistrer. Pour savoir comment faire, consultez les pages Valider les jetons d’accès et Valider les jetons d&#39;identité.
      </Info>

      Les jetons d’accès sont utilisés pour appeler le point de terminaison [Get User Info](https://auth0.com/docs/api/authentication#get-user-info) de l’Authentication API (si votre application de l’appareil a demandé la portée `openid`) ou l’API qui a été spécifiée par le paramètre `audience`. Si vous appelez votre propre API, votre application de l’appareil doit vérifier le jeton d’accès avant de l’utiliser.

      Les jetons d&#39;identité contiennent des informations sur l’utilisateur qui doivent être [décodées et extraites](/docs/fr-CA/secure/tokens/id-tokens#id-token-payload). L’Authentication API ne retourne un `id_token` que si votre application de l’appareil a demandé la portée `openid`.

      Les jetons d’actualisation sont utilisés pour obtenir un nouveau jeton d’accès ou un
      jeton ID après l’expiration du précédent. L’Authentication API ne retourne un `refresh_token` que si le paramètre **Allow Offline Access** est activé pour l’API spécifiée par le paramètre `audience`,
      et si votre application de l’appareil a demandé la portée `offline_access`.

      <LoggedInForm />
    </Section>

    <Section id={sections[7].id} title={sections[7].title} stepNumber="8" isSingleColumn>
      Pour appeler votre API, l’application sur votre appareil doit envoyer le jeton d’accès en tant que jeton Bearer dans l’en‑tête `Authorization` de votre requête HTTP.

      ```bash lines
      curl --request GET \
        --url https://myapi.com/api \
        --header 'authorization: Bearer AUTH0_API_ACCESS_TOKEN' \
        --header 'content-type: application/json'
      ```

      <LoggedInForm />
    </Section>

    <Section id={sections[8].id} title={sections[8].title} stepNumber="9" isSingleColumn>
      Pour obtenir un nouveau jeton d’accès pour un utilisateur, votre application sur l’appareil peut appeler le point de terminaison [POST /oauth/token de l’Authentication API](https://auth0.com/docs/api/authentication#-post-oauth-token-) avec le paramètre `refresh_token`.

      ```bash lines
      curl --request POST \
        --url 'https://{yourDomain}/oauth/token' \
        --header 'content-type: application/x-www-form-urlencoded' \
        --data grant_type=refresh_token \
        --data 'client_id={yourClientId}' \
        --data 'client_secret={yourClientSecret}' \
        --data refresh_token=AUTH0_REFRESH_TOKEN
      ```

      Si la requête a réussi, votre application sur l’appareil reçoit une réponse HTTP 200 avec le corps de réponse suivant :

      ```json lines
      {
        "access_token": "eyJ...MoQ",
        "expires_in": 86400,
        "scope": "openid offline_access",
        "id_token": "eyJ...0NE",
        "token_type": "Bearer"
      }
      ```

      Pour en savoir plus sur les Jetons d’actualisation, consultez la section [Jetons d’actualisation](https://auth0.com/docs/secure/tokens/refresh-tokens).

      <LoggedInForm />
    </Section>

    <Section id={sections[9].id} title={sections[9].title} stepNumber="10" isSingleColumn>
      Les journaux du tenant sont créés pour toute interaction qui se produit et peuvent être utilisés pour résoudre des problèmes.

      ### Réponses de jetons

      Pendant que vous attendez que l&#39;utilisateur autorise l&#39;appareil, vous pouvez recevoir différentes réponses HTTP 4xx.

      #### Autorisation en attente

      Vous verrez cette erreur pendant que vous attendez que l&#39;utilisateur agisse. Continuez le sondage en utilisant la valeur `interval` suggérée, récupérée à l&#39;étape précédente de ce tutoriel.

      ```json lines
      `HTTP 403`
      {
      "error": "authorization_pending",
      "error_description": "..."
      }
      ```

      #### Ralentissez

      Vous interrogez le serveur trop fréquemment. Ralentissez et utilisez l’intervalle suggéré, récupéré à l’étape précédente de ce
      tutoriel. Pour éviter de recevoir cette erreur en raison de la latence réseau, commencez à compter chaque intervalle après
      la réception de la réponse à la dernière requête de sondage.

      ```json lines
      `HTTP 429`
      {
      "error": "slow_down",
      "error_description": "..."
      }
      ```

      #### Jeton expiré

      L&#39;utilisateur n&#39;a pas autorisé l&#39;appareil assez rapidement, donc le `device_code` a expiré. Votre
      application doit informer l&#39;utilisateur que le flux a expiré et l&#39;inviter à relancer le flux.

      <Info>
        L&#39;erreur `expired_token` est renvoyée exactement une seule fois. Par la suite, le point de terminaison renvoie
        l&#39;erreur `invalid_grant`.
      </Info>

      ```json lines
      `HTTP 403`
      {
      "error": "expired_token",
      "error_description": "..."
      }
      ```

      #### Accès refusé

      Si l&#39;accès est refusé, vous recevrez :

      ```json lines
      `HTTP 403`
      {
      "error": "access_denied",
      "error_description": "..."
      }
      ```

      Cela peut se produire pour diverses raisons, notamment :

      * L’utilisateur a refusé d’autoriser l’appareil.
      * Le Serveur d’autorisation a refusé la transaction.
      * Une Action configurée a refusé l’accès.

      <LoggedInForm />
    </Section>

    <Section id={sections[10].id} title={sections[10].title} stepNumber="11" isSingleColumn>
      Consultez les exemples ci-dessous pour apprendre à implémenter ce flux dans des applications réelles.

      * [Device
        Authorization Playground](https://auth0.github.io/device-flow-playground/)
      * [AppleTV (Swift)](https://github.com/pushpabrol/auth0-device-flow-appletv) : Application simple qui montre comment Auth0 peut être utilisé avec le
        Device Authorization Flow sur un Apple TV.
      * [CLI (Node.js)](https://gist.github.com/panva/652c61e7d847e0ed99926c324fa91b36) : Exemple d’implémentation d’un CLI qui utilise le Device
        Authorization Flow au lieu de l’Authorization Code Flow. La principale différence est que votre CLI n’a pas besoin
        d’héberger un serveur Web ni d’écouter sur un port.

      <LoggedInForm />
    </Section>

    <Section id={sections[11].id} title={sections[11].title} stepNumber="12" isSingleColumn>
      Pour utiliser le flux d’autorisation de périphérique (Device Authorization Flow), une application sur appareil doit :

      * Prendre en charge SNI (Server Name Indication)
      * Être une Application native
      * Avoir la [méthode d’authentification](/docs/fr-CA/secure/application-credentials#application-authentication-methods) définie sur **Aucune**
      * Être [conforme à OIDC](/docs/fr-CA/get-started/applications/application-settings#oauth)
      * Ne pas être créée au moyen de l’enregistrement dynamique de clients (Dynamic Client Registration)

      De plus, le flux d’autorisation de périphérique ne permet pas :

      * Les Connexions sociales utilisant des clés de développeur Auth0, sauf si vous utilisez la nouvelle expérience Universal Login
      * Que des paramètres de requête (query string) soient accessibles à partir d’une page de connexion hébergée ou d’Actions.

      <LoggedInForm />
    </Section>

    ## Prochaines étapes

    Excellent travail! Si vous vous êtes rendu jusqu&#39;ici, vous devriez maintenant avoir la connexion, la déconnexion et les informations de profil utilisateur qui fonctionnent dans votre application.

    Ce tutoriel de démarrage rapide est maintenant terminé, mais il reste encore beaucoup à découvrir. Pour en savoir plus sur ce que vous pouvez faire avec Auth0, consultez :

    * [Auth0 Dashboard](https://manage.auth0.com/dashboard/us/dev-gja8kxz4ndtex3rq) - Découvrez comment configurer et gérer votre tenant Auth0 et vos Applications
    * [Auth0 Marketplace](https://marketplace.auth0.com/) - Découvrez des intégrations que vous pouvez activer pour étendre les fonctionnalités d’Auth0
  </Content>
</Recipe>