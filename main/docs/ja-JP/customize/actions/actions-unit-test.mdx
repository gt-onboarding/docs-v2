---
description: "**Actions NPM パッケージ（`@auth0/actions`）** を使用すると、外部プロジェクトで TypeScript による開発を行い、TypeScript 定義に基づくベストプラクティスに従って **ユニットテスト** を強化できます。"
'og:image': https://cdn2.auth0.com/docs/1.14553.0/img/share-image.png
'og:title': "Actions のユニットテスト"
'og:url': https://auth0.com/docs/
permalink: actions-unit-test
title: "Actions のユニットテスト"
'twitter:description': "**Actions NPM パッケージ（`@auth0/actions`）** を使用すると、外部プロジェクトで TypeScript による開発を行い、TypeScript 定義に基づくベストプラクティスに従って **ユニットテスト** を強化できます。"
'twitter:title': "Actions のユニットテスト"
---

<div id="auth0-actions-unit-test">
  # Auth0 Actions ユニットテスト
</div>

**Actions NPM (`@auth0/actions`)** パッケージを使用すると、外部プロジェクトで TypeScript を用いた開発が可能になり、TypeScript の定義に基づいてベストプラクティスに沿ったユニットテストを行えるようになります。

***

<div id="how-it-works">
  ## 仕組み
</div>

[Actions NPM の仕組み](/docs/ja-JP/customize/actions/actions-npm#how-it-works) で説明されているインストールおよびインポートのガイドラインに従ってください。

Action をユニットテストするには、Action 関数が受け取る `event` と `api` オブジェクトをモックする必要があります。これらのモックは、`auth0/actions` に含まれる TypeScript 定義を使用して作成でき、テストが本番環境を正確に反映することを保証します。Jest のようなテストフレームワークは、モックおよび動作の管理に適しています。

ユニットテストはローカル環境、バージョン管理システム、または CI/CD プロセスで実行でき、Auth0 テナントに反映される前に、全体的な品質保証と検証を向上させることができます。

***

<div id="examples">
  ## 例
</div>

次の例では、必要なオブジェクトをモックして、さまざまなシナリオを検証します。

<Note>
  これらの例では **Jest** (`https://www.npmjs.com/package/jest`) を使用していますが、任意のテストライブラリを使用できます。
</Note>

<div id="configuration">
  ### 設定
</div>

`package.json` 内で、Action を作成する際に IntelliSense による補完が効くよう、開発時の依存関係を定義します。

<Tabs>
  <Tab title="Javascript">
    ```javascript
    {
      "name": "actions-js",
      "version": "1.0.0",
      "description": "Actions JS",
      "main": "example.js",
      "scripts": {
        "test": "jest"
      },
      "author": "John Doe",
      "license": "ISC",
      "devDependencies": {
        "@auth0/actions": "^0.7.1",
        "jest": "^29.7.0"
      }
    }
    ```
  </Tab>

  <Tab title="TypeScript">
    ```typescript
    {
      "name": "actions-ts",
      "version": "1.0.0",
      "description": "Actions TS",
      "main": "example.ts",
      "scripts": {
        "test": "jest"
      },
      "author": "John Doe",
      "license": "ISC",
      "devDependencies": {
        "@auth0/actions": "^0.7.1",
        "@types/jest": "^29.5.12",
        "@types/node": "22.14.0",
        "jest": "^29.7.0",
        "ts-jest": "^29.1.2",
        "typescript": "^5.9.2"
      }
    }
    ```

    `tsconfig.json` ファイルで、TypeScript コンパイラの動作を定義します。

    ```typescript
    {
      "compilerOptions": {
        "target": "ES2020",
        "module": "NodeNext",
        "moduleResolution": "nodenext",
        "esModuleInterop": true,
        "allowSyntheticDefaultImports": true,
        "strict": true,
        "outDir": "dist",
        "declaration": true,
        "sourceMap": true,
        "allowJs": true,
        "checkJs": false,
        "resolveJsonModule": true,
        "skipLibCheck": true,
        "forceConsistentCasingInFileNames": true,
        "isolatedModules": true
      },
      "include": [
        "**/*.ts"
      ],
      "exclude": [
        "node_modules",
        "dist"
      ]
    }
    ```

    `jest.config.js` では、Jest の環境プリセットを定義します。

    ```typescript
    module.exports = {
      preset: 'ts-jest',
      testEnvironment: 'node',
    };
    ```
  </Tab>
</Tabs>

<div id="pre-user-registration-access-control-and-user-metadata-setup">
  ## Pre-user registration のアクセス制御と user&#95;metadata のセットアップ
</div>

次の Action の例では、ユーザーのメールアドレスが禁止されているメールドメインかどうかを確認し、一致した場合は `api.access.deny()` を呼び出します。それ以外の場合は、Custom Prompts の追加フィールド経由で氏名が提供されているかを確認し、提供されていればユーザープロファイルの `user_metadata` に氏名を設定し、そうでなければ Universal Login に検証エラーを送信します。

<Tabs>
  <Tab title="Javascript">
    ```javascript
    /** @import {Event, PreUserRegistrationAPI} from "@auth0/actions/pre-user-registration/v2" */

    /**
    * PreUserRegistration フローの実行中に呼び出されるハンドラーです。
    *
    * @param {Event} event - 登録を試行しているユーザーおよびコンテキストに関する詳細。
    * @param {PreUserRegistrationAPI} api - サインアップの動作を変更するために使用できるメソッドを持つインターフェース。
    */
    exports.onExecutePreUserRegistration = async (event, api) => {
      const user = event.user;

      if (user.email?.endsWith('@example.com')) {
        api.access.deny('forbidden', 'Forbidden email domain')
        return;
      }

      const fullName = event.request.body['ulp-fullName'];

      if (fullName === undefined) {
        api.validation.error('invalid_payload', 'Missing full name');
        return;
      }

      api.user.setUserMetadata('full_name', fullName);
    }
    ```
  </Tab>

  <Tab title="TypeScript">
    ```typescript
    import type { Event, PreUserRegistrationAPI } from '@auth0/actions/pre-user-registration/v2';

    /**
    * PreUserRegistration フローの実行中に呼び出されるハンドラーです。
    *
    * @param {Event} event - 登録を試行しているユーザーおよびコンテキストに関する詳細。
    * @param {PreUserRegistrationAPI} api - サインアップの動作を変更するために使用できるメソッドを持つインターフェース。
    */
    exports.onExecutePreUserRegistration = async (event: Event, api: PreUserRegistrationAPI) => {
      const user = event.user;

      if (user.email?.endsWith('@example.com')) {
        api.access.deny('forbidden', 'Forbidden email domain')
        return;
      }

      const fullName = event.request.body['ulp-fullName'];

      if (fullName === undefined) {
        api.validation.error('invalid_payload', 'Missing full name');
        return;
      }

      api.user.setUserMetadata('full_name', fullName);
    };
    ```
  </Tab>
</Tabs>

Unit Test では、`event` オブジェクトと `api` オブジェクトをモックし、コードカバレッジを最大化するためのいくつかの検証を実行します。

<Tabs>
  <Tab title="Javascript">
    ```javascript
    const { onExecutePreUserRegistration } = require('./preUserRegistration');

    describe('onExecutePreUserRegistration', () => {
      const mockApi = {
        access: {
          deny: jest.fn(),
        },
        user: {
          setUserMetadata: jest.fn(),
        },
        validation: {
          error: jest.fn(),
        },
      };

      beforeEach(() => {
        jest.resetAllMocks();
      });

      afterEach(() => {
        jest.resetAllMocks();
      });

      it('forbids email domain', async () => {
        const mockEvent = {
          user: {
            email: 'johndoe@example.com',
          }
        };

        await onExecutePreUserRegistration(mockEvent, mockApi);

        expect(mockApi.access.deny).toHaveBeenCalledWith('forbidden', 'Forbidden email domain');
        expect(mockApi.validation.error).not.toHaveBeenCalled();
        expect(mockApi.user.setUserMetadata).not.toHaveBeenCalled();
      });

      it('allows email domain without full name', async () => {
        const mockEvent = {
          request: {
            body: {},
          },
          user: {
            email: 'johndoe@test.com',
          },
        };

        await onExecutePreUserRegistration(mockEvent, mockApi);

        expect(mockApi.access.deny).not.toHaveBeenCalled();
        expect(mockApi.validation.error).toHaveBeenCalledWith('invalid_payload', 'Missing full name');
        expect(mockApi.user.setUserMetadata).not.toHaveBeenCalled();
      });

      it('allows email domain with full name', async () => {
        const mockEvent = {
          request: {
            body: {
              'ulp-fullName': 'John Doe'
            },
          },
          user: {
            email: 'johndoe@test.com',
          },
        };

        await onExecutePreUserRegistration(mockEvent, mockApi);

        expect(mockApi.access.deny).not.toHaveBeenCalled();
        expect(mockApi.validation.error).not.toHaveBeenCalled();
        expect(mockApi.user.setUserMetadata).toHaveBeenCalledWith('full_name', 'John Doe');
      });
    });
    ```
  </Tab>

  <Tab title="TypeScript">
    ```typescript
    const { onExecutePreUserRegistration } = require('./preUserRegistration');

    describe('onExecutePreUserRegistration', () => {
      const mockApi = {
        access: {
          deny: jest.fn(),
        },
        user: {
          setUserMetadata: jest.fn(),
        },
        validation: {
          error: jest.fn(),
        },
      };

      beforeEach(() => {
        jest.resetAllMocks();
      });

      afterEach(() => {
        jest.resetAllMocks();
      });

      it('forbids email domain', async () => {
        const mockEvent = {
          user: {
            email: 'johndoe@example.com',
          }
        };

        await onExecutePreUserRegistration(mockEvent, mockApi);

        expect(mockApi.access.deny).toHaveBeenCalledWith('forbidden', 'Forbidden email domain');
        expect(mockApi.validation.error).not.toHaveBeenCalled();
        expect(mockApi.user.setUserMetadata).not.toHaveBeenCalled();
      });

      it('allows email domain without full name', async () => {
        const mockEvent = {
          request: {
            body: {},
          },
          user: {
            email: 'johndoe@test.com',
          },
        };

        await onExecutePreUserRegistration(mockEvent, mockApi);

        expect(mockApi.access.deny).not.toHaveBeenCalled();
        expect(mockApi.validation.error).toHaveBeenCalledWith('invalid_payload', 'Missing full name');
        expect(mockApi.user.setUserMetadata).not.toHaveBeenCalled();
      });

      it('allows email domain with full name', async () => {
        const mockEvent = {
          request: {
            body: {
              'ulp-fullName': 'John Doe'
            },
          },
          user: {
            email: 'johndoe@test.com',
          },
        };

        await onExecutePreUserRegistration(mockEvent, mockApi);

        expect(mockApi.access.deny).not.toHaveBeenCalled();
        expect(mockApi.validation.error).not.toHaveBeenCalled();
        expect(mockApi.user.setUserMetadata).toHaveBeenCalledWith('full_name', 'John Doe');
      });
    });
    ```
  </Tab>
</Tabs>

<div id="custom-email-provider-and-http-request">
  ## カスタムメールプロバイダーと HTTP リクエスト
</div>

次の例の Action は、HTTP リクエストを介して外部サービスにメッセージ送信を試み、リクエストエラーが発生した場合には通知を破棄します。外部サービスの URL と認証用 API キーはシークレットとして使用します。

<Tabs>
  <Tab title="JavaScript">
    ```javascript
    /** @import {Event, CustomEmailProviderAPI} from "@auth0/actions/custom-email-provider/v1" */

    /**
    * メール通知の送信時に実行されるハンドラー
    *
    * @param {Event} event - ユーザーおよびログインしているコンテキストに関する詳細。
    * @param {CustomEmailProviderAPI} api - メール通知の送信方法を変更するためのメソッドやユーティリティ。
    */
    exports.onExecuteCustomEmailProvider = async (event, api) => {
      const notification = event.notification;
      const message = {
        body: notification.html
      };

      try {
        await fetch(event.secrets.URL, {
          method: 'POST',
          headers: {
            'X-API-Key': event.secrets.API_KEY,
          },
          body: JSON.stringify(message),
        });
      } catch (err) {
        api.notification.drop('External service failure');
      }
    }

    ```
  </Tab>

  <Tab title="TypeScript">
    ```typescript
    /** @import {Event, CustomEmailProviderAPI} from "@auth0/actions/custom-email-provider/v1" */

    /**
    * メール通知の送信時に実行されるハンドラー
    *
    * @param {Event} event - ユーザーおよびログインしているコンテキストに関する詳細。
    * @param {CustomEmailProviderAPI} api - メール通知の送信方法を変更するためのメソッドやユーティリティ。
    */
    exports.onExecuteCustomEmailProvider = async (event, api) => {
      const notification = event.notification;
      const message = {
        body: notification.html
      };

      try {
        await fetch(event.secrets.URL, {
          method: 'POST',
          headers: {
            'X-API-Key': event.secrets.API_KEY,
          },
          body: JSON.stringify(message),
        });
      } catch (err) {
        api.notification.drop('External service failure');
      }
    }

    ```
  </Tab>
</Tabs>

Unit Test では、コードカバレッジを最大化するために、`event` と `api` オブジェクトに加え、`fetch` 関数もモック化して各種検証を実行します。

<Tabs>
  <Tab title="JavaScript">
    ```javascript
    const { onExecuteCustomEmailProvider } = require('./customEmailProvider');

    describe('onExecuteCustomEmailProvider', () => {
      const mockApi = {
        notification: {
          drop: jest.fn(),
        },
      };

      const mockEvent = {
        notification: {
          html: '<h1>Hello world</h1>',
        },
        secrets: {
          URL: 'https://example.com/service',
          API_KEY: 'ApiKeySecret1234.',
        },
        user: {
          email: 'johndoe@example.com',
        },
      };

      beforeEach(() => {
        jest.resetAllMocks();
      });

      afterEach(() => {
        jest.resetAllMocks();
      });

      it('succeeds on external service request', async () => {
        jest.spyOn(global, 'fetch').mockImplementationOnce(() => Promise.resolve({
          ok: true,
          status: 200,
          json: async () => ({ message: 'Success!' }),
        }));

        await onExecuteCustomEmailProvider(mockEvent, mockApi);

        expect(global.fetch).toHaveBeenCalled();
        expect(mockApi.notification.drop).not.toHaveBeenCalled();
      });

      it('fails on external service request', async () => {
        jest.spyOn(global, 'fetch').mockImplementationOnce(() => Promise.reject({
          ok: false,
          status: 500,
          json: async () => ({ error: 'Server Error' }),
        }));

        await onExecuteCustomEmailProvider(mockEvent, mockApi);

        expect(mockApi.notification.drop).toHaveBeenCalledWith('External service failure');
      });
    });

    ```
  </Tab>

  <Tab title="TypeScript">
    ```typescript
    const { onExecuteCustomEmailProvider } = require('./customEmailProvider');

    describe('onExecuteCustomEmailProvider', () => {
      const mockApi = {
        notification: {
          drop: jest.fn(),
        },
      };

      const mockEvent = {
        notification: {
          html: '<h1>Hello world</h1>',
        },
        secrets: {
          URL: 'https://example.com/service',
          API_KEY: 'ApiKeySecret1234.',
        },
        user: {
          email: 'johndoe@example.com',
        },
      };

      beforeEach(() => {
        jest.resetAllMocks();
      });

      afterEach(() => {
        jest.resetAllMocks();
      });

      it('succeeds on external service request', async () => {
        jest.spyOn(global, 'fetch').mockImplementationOnce(() => Promise.resolve({
          ok: true,
          status: 200,
          json: async () => ({ message: 'Success!' }),
        } as Response));

        await onExecuteCustomEmailProvider(mockEvent, mockApi);

        expect(global.fetch).toHaveBeenCalled();
        expect(mockApi.notification.drop).not.toHaveBeenCalled();
      });

      it('fails on external service request', async () => {
        jest.spyOn(global, 'fetch').mockImplementationOnce(() => Promise.reject({
          ok: false,
          status: 500,
          json: async () => ({ error: 'Server Error' }),
        } as Response));

        await onExecuteCustomEmailProvider(mockEvent, mockApi);

        expect(mockApi.notification.drop).toHaveBeenCalledWith('External service failure');
      });
    });

    ```
  </Tab>
</Tabs>

`@auth0/actions` の詳細については、https://www.npmjs.com/package/@auth0/actions を参照してください。

Actions の作成方法について詳しくは、[Write Your First Action](/customize/actions/write-your-first-action) を参照してください。