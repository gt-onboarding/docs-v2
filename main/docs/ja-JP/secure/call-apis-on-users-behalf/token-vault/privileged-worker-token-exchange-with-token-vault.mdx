---
description: アプリケーションが Token Vault にアクセスして、JWT Bearer トークンを外部 API を呼び出すためのアクセス トークンまたはリフレッシュトークンと交換する方法を説明します。
'og:image': https://cdn2.auth0.com/docs/1.14553.0/img/share-image.png
'og:title': Privileged Worker Token Exchange with Token Vault
'og:url': https://auth0.com/docs/
permalink: privileged-worker-token-exchange-with-token-vault
title: Privileged Worker Token Exchange with Token Vault
'twitter:description': アプリケーションが Token Vault にアクセスして、JWT Bearer トークンを外部 API を呼び出すためのアクセス トークンまたはリフレッシュトークンと交換する方法を説明します。
'twitter:title': Privileged Worker Token Exchange with Token Vault
---

<Callout icon="file-lines" color="#0EA5E9" iconType="regular">
  Privileged Worker Token Exchange with Token Vault は現在ベータ版です。Auth0 の製品リリースサイクルについて詳しくは、[Product Release Stages](/docs/ja-JP/troubleshoot/product-lifecycle/product-release-stages) を参照してください。本プログラムに参加するには、[Auth0 Support](https://support.auth0.com/) または担当の Technical Account Manager までお問い合わせください。
</Callout>

Token Vault は Privileged Worker Token Exchange をサポートしており、クライアント アプリケーションが署名付き JWT（subject トークン）を外部プロバイダのアクセス トークンまたはリフレッシュトークン（要求されたトークン）と交換できるようにします。

ユーザーの認証と認可が正常に完了した後、クライアント アプリケーションは通常、ユーザーの id、権限、セッション状態を含むユーザー コンテキストを、Token Vault とのトークン交換を実行するためのアクセス トークンまたはリフレッシュトークンとして渡します。サービス間フローでは、バックエンド アプリケーションやサービス ワーカーなどのクライアント アプリケーションがユーザーに代わってリソースへアクセスする必要がある場合がありますが、「ユーザーがインタラクティブなセッションに存在しない」ため、クライアント アプリケーションはユーザー コンテキストにアクセスできません。

このようなサービス間シナリオでは、クライアント アプリケーションは署名付き JWT Bearer トークンを生成し、それを subject トークンとして使用してトークン交換を実行し、外部 API を呼び出すために必要なトークンを受け取ることができます。これにより、クライアント アプリケーションはアクティブなユーザー操作やセッションがなくても、ユーザーに代わって処理を実行できます。

Privileged Worker Token Exchange with Token Vault を使用するには、クライアント アプリケーションは Token Vault 経由で外部プロバイダからリフレッシュトークンを要求できる、高い権限を持つクライアントである必要があります。Token Vault には、[Private Key JWT](/docs/ja-JP/get-started/authentication-and-authorization-flow/authenticate-with-private-key-jwt) アサーションや [mutual TLS authentication](/docs/ja-JP/get-started/authentication-and-authorization-flow/authenticate-with-mtls) などの非対称暗号方式を使用して認証する必要があります。

<div id="prerequisites">
  ## 前提条件
</div>

Privileged Worker Token Exchange と Token Vault を利用できるクライアントのタイプには制限があります。

* クライアントはファーストパーティクライアントである必要があります。つまり、`is_first_party property` が `true` である必要があります。
* クライアントは有効な認証方式を持つ機密クライアントである必要があります。つまり、`token_endpoint_auth_method` プロパティが `none` に設定されていてはなりません。
* クライアントは OIDC 準拠である必要があります。つまり、`oidc_conformant` プロパティが `true` である必要があります。

クライアントアプリケーションに対して Privileged Worker Token Exchange を構成する前に、次の操作を行ってください。

1. クライアントアプリケーションに対して [Token Vault グラントタイプを有効にします](/docs/ja-JP/secure/tokens/token-vault/configure-token-vault#configure-application)。
2. クライアントアプリケーションに対して [Private Key JWT](/docs/ja-JP/get-started/authentication-and-authorization-flow/authenticate-with-private-key-jwt) または [相互 TLS 認証](/docs/ja-JP/get-started/authentication-and-authorization-flow/authenticate-with-mtls) を構成します。

<div id="configure-client-application">
  ## クライアント アプリケーションを構成する
</div>

クライアント アプリケーションから Token Vault への特権アクセスを構成するには、署名付き JWT をサブジェクトトークンとして検証するために使用される公開鍵を指定する必要があります。

[JWT による認可リクエスト (JAR) の構成](/docs/ja-JP/get-started/applications/configure-jar#configure-jwt-secured-authorization-requests-jar) と同様に、新しいクライアントを作成する際に、Token Vault の特権アクセス用公開鍵を設定できます。

```bash lines
POST https://{yourDomain}.auth0.com/api/v2/clients
Authorization: Bearer <YOUR_MANAGEMENT_API_ACCESS_TOKEN>
Content-Type: application/json
{
  "name": "My App using JAR",
   “grant_types”: [“urn:auth0:params:oauth:grant-type:token-exchange:federated-connection-access-token”],
     “oidc_conformant”: true,
           “is_first_party”: true,
           “jwt_configuration”: {
             “alg”: 'RS256',
           },

  "token_vault_privileged_access": {
"credentials": [{
        "name": "Token Vault特権アクセス用の認証情報",
        "credential_type": "public_key",
        "pem": "<YOUR PEM FILE CONTENT>",
        "alg": "RS256"
}]
  },
}
```

Token Vault 特権アクセスの公開鍵を使用して、既存のクライアントを更新することもできます。

```bash lines
PATCH https://{yourDomain}.auth0.com/api/v2/clients/{yourClientId}
Authorization: Bearer <YOUR_MANAGEMENT_API_ACCESS_TOKEN>
Content-Type: application/json
{
  "token_vault_privileged_access": {
    "credentials": [{"id": "<YOUR CREDENTIAL ID>"}]
  }
}
```

<div id="create-signed-jwt-subject-token">
  ## 署名付き JWT サブジェクトトークンを作成する
</div>

[クライアントアプリケーションに公開鍵を設定](#configure-client-application)した後、外部 API 用のアクセストークンと交換されるサブジェクトトークンを作成する必要があります。サブジェクトトークンは、必要なクレームを含む JSON Web Token (JWT) です。これは秘密鍵で署名されます。

JWT は標準的な形式とクレームを持ち、次のようになります。

* ヘッダーの `typ` は `token-vault-req+jwt`
* 公開鍵が 1 つだけ設定されている場合、ヘッダーの `kid` は省略可能です
* ペイロードの `sub` は、トークンを取得したいユーザーの ID
* ペイロードの `aud` は、テナントのホスト
* ペイロードの `iss` は、リクエストを行っているクライアントID

以下は JWT の例です。

```json lines
{
    alg: "RS256"  
    typ: "token-vault-req+jwt"
}
.
{
    sub: "auth0|000012030101231",
    aud: "https://{yourDomain}.auth0.com/",
    iss: "<YOUR_CLIENT_ID>",
    iat: 1758799540,
    exp: 1758800540,
    nbf: 1758799540
}
```

次のコード例は、署名付きの JWT の subject トークンを生成するスクリプトです。

```tsx lines
import * as jwt from 'jsonwebtoken';
   const privateKey = ‘-----BEGIN RSA PRIVATE KEY-----........’;
   const subjectToken = jwt.sign(
     {
       iss: CLIENT_ID,
       aud: 'https://' + TENANT_DOMAIN + '/',
       sub: USER_ID,
     },
     privateKey,
     {
       algorithm: 'RS256',
       header: {
         typ: 'token-vault-req+jwt',
       },
     }
   );
```

<div id="request-token-for-external-api">
  ## 外部 API 用アクセストークンをリクエストする
</div>

署名済みの JWT を取得したら、外部 API 用のアクセストークンをリクエストできます。

```bash lines
curl --request POST 'https://{yourDomain}/oauth/token' \
--header 'Content-Type: application/json' \
--data '{
  "client_id": "<YOUR_CLIENT_ID>",
  "client_secret": "<YOUR_CLIENT_SECRET>",
  "subject_token": "<YOUR_SIGNED_JWT_BEARER>",
  "grant_type": "urn:auth0:params:oauth:grant-type:token-exchange:federated-connection-access-token",
  "subject_token_type": "urn:ietf:params:oauth:token-type:jwt",
  "requested_token_type": "http://auth0.com/oauth/token-type/token-vault-access-token",
  "connection": "google-oauth2"
}'
```

<table class="table">
  <thead>
    <tr>
      <th><strong>パラメーター</strong></th>
      <th><strong>説明</strong></th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td><code>grant&#95;type</code></td>
      <td>グラントタイプ。Token Vault の場合は <code>urn:auth0:params:oauth:grant-type:token-exchange:federated-connection-access-token</code> を設定します。</td>
    </tr>

    <tr>
      <td><code>client&#95;id</code></td>
      <td>クライアントアプリケーションの ID。</td>
    </tr>

    <tr>
      <td><code>client&#95;secret</code></td>
      <td>クライアントシークレット。<strong>注意:</strong> Privileged Worker Token Exchange では、Private Key JWT または mTLS 認証の使用を推奨します。</td>
    </tr>

    <tr>
      <td><code>subject&#95;token&#95;type</code></td>
      <td>サブジェクトトークンのタイプ。Privileged Worker Token Exchange の場合は、JWT を指定します: <code>urn:ietf:params:oauth:token-type:jwt</code></td>
    </tr>

    <tr>
      <td><code>subject&#95;token</code></td>
      <td>Auth0 認可サーバーがユーザーを特定するために検証する、署名済みの JWT の Bearer トークン。</td>
    </tr>

    <tr>
      <td><code>requested&#95;token&#95;type</code></td>
      <td>要求するトークンタイプ。Privileged Worker Token Exchange では、アクセストークンまたはリフレッシュトークンを要求できます。</td>
    </tr>

    <tr>
      <td><code>connection</code></td>
      <td>接続名。この例では <code>google-oauth2</code> です。</td>
    </tr>
  </tbody>
</table>

Token Vault に保存されているアクセストークンを受け取ることができます。同様に、外部 API 用のリフレッシュトークンも要求できます。

```bash lines
curl --request POST 'https://{yourDomain}/oauth/token' \
--header 'Content-Type: application/json' \
--data '{
  "client_id": "<YOUR_CLIENT_ID>",
  "client_secret": "<YOUR_CLIENT_SECRET>",
  "subject_token": "<YOUR_SIGNED_JWT_BEARER>",
  "grant_type": "urn:auth0:params:oauth:grant-type:token-exchange:federated-connection-access-token",
  "subject_token_type": "urn:ietf:params:oauth:token-type:jwt",
  "requested_token_type": "http://auth0.com/oauth/token-type/token-vault-refresh-token",
  "connection": "google-oauth2"
}'
```
