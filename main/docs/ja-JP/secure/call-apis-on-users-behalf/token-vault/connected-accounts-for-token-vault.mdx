---
description: Token Vault の Connected Accounts の構成と使用方法について学びます。
'og:image': https://cdn2.auth0.com/docs/1.14553.0/img/share-image.png
'og:title': Connected Accounts for Token Vault
'og:url': https://auth0.com/docs/
permalink: connected-accounts-for-token-vault
sidebarTitle: Connected Accounts for Token Vault
title: Connected Accounts for Token Vault
'twitter:description': Token Vault の Connected Accounts の構成と使用方法について学びます。
'twitter:title': Connected Accounts for Token Vault
---

Connected Accounts for Token Vault を使用すると、アプリケーションは [Token Vault](/docs/ja-JP/secure/tokens/token-vault) を通じて、ユーザーに代わって外部 API に安全にアクセスできるようになります。標準的なユーザー認証がソーシャルまたはエンタープライズのアイデンティティ プロバイダーを通じてユーザーのログインを処理するのに対し、Connected Accounts はユーザープロファイルを Google、GitHub、Slack などの外部サービスにリンクし、ユーザーに代わって外部 API への委任アクセスを可能にします。

ユーザーが [サポートされている外部プロバイダー](/docs/ja-JP/secure/tokens/token-vault#supported-external-providers) に正常に接続し、アクセスを許可すると、Auth0 は次を行います。

* そのアカウントを接続済みアカウントとしてユーザーに関連付けます。
* 接続済みアカウント用の外部プロバイダーのアクセストークンおよびリフレッシュトークンを Token Vault に保存します。

Connected Accounts for Token Vault は、複数の外部アカウントにリンクされた一元的な Auth0 ユーザープロファイルを作成および管理し、シームレスな認可を可能にします。その後、アプリケーションは Token Vault に保存されている認証情報を取得し、ユーザーに代わって外部 API と連携します。

<div id="user-authentication-vs-connected-accounts">
  ## ユーザー認証と Connected Accounts の違い
</div>

サポート対象のソーシャルまたはエンタープライズ接続に対して[Connected Accounts を構成](#configure-connected-accounts)すると、Auth0 はソーシャルまたはエンタープライズのログインフロー（`/authorize` エンドポイント）ではなく、Connected Accounts フロー（`/me/v1/connected-accounts` エンドポイント）を使用して、アクセストークンとリフレッシュトークンを Token Vault に取得・保存します。Connected Accounts フローが正常に完了すると、Auth0 はユーザーアカウントをユーザープロファイル上の `connected_accounts` 配列に追加します。これに対し、ソーシャルまたはエンタープライズのログインフローの場合、Auth0 はユーザーアカウントをユーザープロファイル上の `identities` 配列に追加します。

次の表は、ユーザー認証フローと Connected Accounts フローの違いを説明します。

<table class="table">
  <thead>
    <tr>
      <th />

      <th><strong>ユーザー認証</strong></th>
      <th><strong>Connected Accounts</strong></th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>フロー</td>
      <td>`/authorize` エンドポイントを使用するログインフロー</td>
      <td>My Account API の `/me/v1/connected-accounts` エンドポイントを使用する Connected Accounts フロー</td>
    </tr>

    <tr>
      <td>目的</td>
      <td>ソーシャルまたはエンタープライズのアイデンティティ プロバイダーでユーザーを認証する</td>
      <td>サポート対象の外部プロバイダー経由でユーザーがログインし、接続を行い、その接続を承認した際に、接続済みアカウント用のアクセストークンとリフレッシュトークンを Token Vault に保存する</td>
    </tr>
  </tbody>
</table>

サポート対象のソーシャルまたはエンタープライズ接続に対しては、ユーザー認証、Connected Accounts、またはその両方を有効にできます。次の表は、各種 Purpose 設定における動作と、接続にスコープを渡す方法を説明します。

<table class="table">
  <thead>
    <tr>
      <th><strong>Authentication</strong></th>
      <th><strong>Connected Accounts</strong></th>
      <th><strong>動作</strong></th>
      <th><strong>スコープ</strong></th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>Enabled</td>
      <td>Disabled</td>
      <td>この接続は `/authorize` ログインフローを使用して、正当なアイデンティティ プロバイダーとしてユーザーを認証します。</td>
      <td>Auth0 Dashboard または Management API を使用して、接続に必要なスコープを渡します。実行時には、この一覧に、認可リクエストの `connection_scope` パラメーターに含まれる追加のスコープが自動的に補完されます。</td>
    </tr>

    <tr>
      <td>Disabled</td>
      <td>Enabled</td>
      <td>この接続は Connected Accounts フローを使用して、この接続用のトークンを Token Vault に取得・保存します。この接続は `/authorize` ログインフローを使用してユーザーを認証せず、有効なアイデンティティ プロバイダーの一覧には含まれません。</td>
      <td>Auth0 Dashboard または Management API を使用して、接続に必要なスコープを渡します。実行時には、認可リクエストの `scopes` パラメーターに含まれるスコープが、接続で必要とされ Auth0 Dashboard で有効になっている `offline_access` を除き、Auth0 Dashboard で選択されたスコープよりも優先されます。<br /><br /><strong>注意:</strong> 接続で必要な場合、Auth0 は `offline_access` を有効化するよう促し、クライアントアプリケーションが Auth0 からリフレッシュトークンを取得できるようにします。Auth0 Dashboard でその接続に対して `offline_access` を有効にする必要があります。</td>
    </tr>

    <tr>
      <td>Enabled</td>
      <td>Enabled</td>
      <td>この接続は `/authorize` ログインフローを使用して、正当なアイデンティティ プロバイダーとしてユーザーを認証します。また、Connected Accounts フローも使用して、この接続のアクセストークンを Token Vault に取得・保存します。</td>
      <td>Auth0 Dashboard および Management API を使用して、接続に必要なスコープを渡します。実行時には、`scopes` パラメーターに含まれるスコープが、接続で必要とされ Auth0 Dashboard で有効になっている `offline_access` を除き、Auth0 Dashboard で選択されたスコープよりも優先されます。<br /><br /><strong>注意:</strong> 接続で必要な場合、Auth0 は `offline_access` を有効化するよう促し、クライアントアプリケーションが Auth0 からリフレッシュトークンを取得できるようにします。Auth0 Dashboard でその接続に対して `offline_access` を有効にする必要があります。</td>
    </tr>
  </tbody>
</table>

<div id="how-it-works">
  ## 仕組み
</div>

Connected Accounts フローは、[My Account API](/docs/ja-JP/manage-users/my-account-api) を使用して、サポート対象の外部プロバイダー間でユーザーの接続済みアカウントを作成および管理します。

ユーザーがクライアント アプリケーションから Connected Accounts リクエストを開始できるようにするには、事前にクライアント アプリケーションで、Connected Accounts 用のスコープを含む [アクセストークンを取得](/docs/ja-JP/manage-users/my-account-api#get-an-access-token) し、My Account API にアクセスできるようにしておく必要があります。

次のシーケンス図は、Connected Accounts フローのエンドツーエンドの流れを示しています。

<Frame>![](/docs/images/token-vault/connected_accounts_flow_diagram.png)</Frame>

ユーザーが Auth0 を介してサポート対象の外部プロバイダーでログインすると、クライアント アプリケーションから Connected Accounts リクエストを開始します。

1. クライアント アプリケーションは、My Account API の `/me/v1/connected-accounts` エンドポイントに対して `POST` リクエストを実行し、外部プロバイダーに送信するスコープおよびその他のパラメーターを渡します。詳細は、[Connected Accounts リクエストの開始](#initiate-connected-accounts-request) を参照してください。
2. My Account API は、一意の `auth_session` と、ユーザーを Web ブラウザーにリダイレクトする `ticket` を含む `connect_uri` を作成します。クライアント アプリケーションは、後で検証するために `auth_session` を保存します。[DPoP](/docs/ja-JP/secure/sender-constraining/demonstrating-proof-of-possession-dpop) が構成されている場合、My Account API は DPoP Proof JWT を検証します。
3. クライアント アプリケーションは、ブラウザーでのユーザー認証および認可のために、`ticket` をクエリ パラメーターとして付加した `connect_uri` にユーザーをリダイレクトします。クライアント アプリケーションは、[Authorization Code Flow with PKCE](/docs/ja-JP/get-started/authentication-and-authorization-flow/authorization-code-flow-with-pkce) のように、`code_challenge` や `code_challenge_method` を URL に渡すこともできます。
4. ユーザーは同意画面で、接続のための権限を承認します。
5. ユーザーが接続を正常に承認すると、外部プロバイダーはユーザーを My Account API にリダイレクトし、My Account API は一度きり使用可能な `connect_code` を含む `redirect_uri` を使用してユーザーをクライアント アプリケーションにリダイレクトします。
6. クライアント アプリケーションは、`/me/v1/connected-accounts/complete` エンドポイントに対して `POST` リクエストを送信し、`connect_code`、`code_verifier`（該当する場合）、および元の `auth_session` を My Account API に提示します。詳細は、[Connected Accounts リクエストの完了](#complete-connected-accounts-request) を参照してください。
7. My Account API は、次の点を確認してリクエストを検証します。
   * `auth_session` が、そのユーザーに対して最初に発行された ID と一致していること
   * リクエストが、Connected Accounts フローを開始したものと同じデバイスから送信されていること
   * DPoP Proof JWT（構成されている場合）
   * 一度きり使用可能な `connect_code`
   * `code_verifier`（PKCE フローを使用している場合）
8. 検証が成功すると、Auth0 認可サーバーはアカウントをユーザー プロファイル上の `connected_accounts` 配列に追加し、接続済みアカウントのアクセストークンとリフレッシュトークンを Token Vault に保存します。
9. My Account API は、アカウントが正常に接続されたことを示す `200` ステータスコードをクライアント アプリケーションに返してフローを完了します。

<div id="prerequisites">
  ## 前提条件
</div>

Connected Accounts を設定する前に、次の作業が完了していることを確認してください。

* クライアント アプリケーションで [Token Vault を構成](/docs/ja-JP/secure/tokens/token-vault/configure-token-vault) し、各接続済みアカウントに関連付けられたアクセスおよびリフレッシュトークンを Token Vault に安全に保存できるようにします。
* [My Account API を構成](#configure-my-account-api) します。この API は、認証済みユーザーがアカウントを接続および管理するために使用します。
* [Multi-Resource Refresh Token (MRRT) を構成](#configure-multi-resource-refresh-token) し、My Account API 用のアクセストークンを取得できるようにします。
* （オプション）My Account API とクライアント アプリケーションで [DPoP を構成](/docs/ja-JP/secure/sender-constraining/configure-sender-constraining) し、送信者制約を適用したアクセストークンによってトークンの盗難を防止します。デフォルトでは、My Account API は DPoP にバインドされたアクセストークンを受け付けます。

<div id="configure-my-account-api">
  ### My Account API を構成する
</div>

Connected Accounts を使用するには、Auth0 Dashboard で My Account API を構成します。

1. **Applications &gt; APIs** に移動し、[My Account API を有効化](/docs/ja-JP/manage-users/my-account-api#activate-the-my-account-api)します。
2. 有効化したら、**Auth0 My Account API** を選択し、**Applications** タブを開きます。
3. クライアントアプリケーションのトグルをオンにして、My Account API へのアクセスを許可します。
4. ドロップダウンメニューから、このアプリケーションに対して [Connected Accounts スコープ](/docs/ja-JP/manage-users/my-account-api#scope) を選択します。
5. **Update** を選択します。これにより、クライアントアプリケーションがユーザーに代わって Connected Accounts スコープ付きで My Account API にアクセスできるようにする [クライアントグラント](/docs/ja-JP/get-started/applications/application-access-to-apis-client-grants) が作成されます。
6. [Multi-Resource Refresh Token](/docs/ja-JP/secure/tokens/refresh-tokens/multi-resource-refresh-token#multi-resource-refresh-token) を使用している場合は、**Settings** タブに移動します。**Access Settings** セクションで **Allow Skipping User Consent** を選択します。

<div id="configure-multi-resource-refresh-token">
  ### マルチリソース リフレッシュトークンを設定する
</div>

Multi-Resource Refresh Token (MRRT) を設定して、My Account API アクセストークンおよびその他の API 用に、新しいアクセストークンと交換可能な、長期間有効な単一のリフレッシュトークンを取得します。これにより、ユーザーに再認証を要求する必要がなくなります。

MRRT は [Auth0 Dashboard](https://manage.auth0.com) または [Management API](https://auth0.com/docs/api/management/v2) で設定できます。

<Tabs>
  <Tab title="Auth0 Dashboard">
    Auth0 Dashboard で MRRT を設定するには:

    1. **Applications &gt; Applications** に移動し、対象のアプリケーションを選択します。
    2. **Multi-Resource Refresh Token** の下で、**Edit Configuration** を選択します。
    3. My Account API で MRRT を有効にするには、**My Account API** のトグルをオンにします。
  </Tab>

  <Tab title="Management API">
    クライアント アプリケーションに対して MRRT を設定するには、`PATCH` リクエストを `/api/v2/clients/{clientId}` エンドポイントに送信し、リフレッシュトークン ポリシーに My Account API 識別子と Connected Accounts のスコープを追加します。

    ```bash lines
    curl -X PATCH --location "https://${account.namespace}/api/v2/clients/{clientId}" \
        -H "Authorization: Bearer <YOUR_MANAGEMENT_API_TOKEN>" \
        -H "Content-Type: application/json" \
        -d '{
              "is_first_party": true,
              "refresh_token": {
                "expiration_type": "non-expiring",
                "leeway": 0,
                "infinite_token_lifetime": true,
                "infinite_idle_token_lifetime": true,
                "token_lifetime": 31557600,
                "idle_token_lifetime": 2592000,
                "rotation_type": "non-rotating",
                "policies": [
                  {
                    "audience": "https://'"$DOMAIN"'/me/",
                    "scope": [
                      "create:me:connected_accounts",
                      "read:me:connected_accounts",
                      "delete:me:connected_accounts"
                    ]
                  }
                ]
              }
            }'
    ```
  </Tab>
</Tabs>

<div id="configure-connected-accounts">
  ## Connected Accounts を構成する
</div>

接続に対して Connected Accounts を構成する前に、その接続がクライアントアプリケーションで許可されていることを確認してください。

Auth0 Dashboard で次を実行します。

1. **Authentication &gt; Social Connections** または **Enterprise Connections** に移動し、接続を選択します。
2. **Applications** を選択し、クライアントアプリケーション用の接続をトグルで有効にします。

Connected Accounts は [Auth0 Dashboard](https://manage.auth0.com) または [Management API](https://auth0.com/docs/api/management/v2) を使用して構成できます。

<Tabs>
  <Tab title="Auth0 Dashboard">
    Auth0 Dashboard を使用して Connected Accounts を構成するには、次の手順を実行します。

    1. **Authentication &gt; Social Connections** または **Enterprise Connections** に移動します。
    2. **Create Connection** を選択するか、既存の接続を選択します。
    3. **Purpose** で **Use for Connected Accounts for Token Vault** をトグルで有効にします。**Purpose** の設定によっては、Connected Accounts フロー中にクライアントアプリケーションが外部プロバイダーからリフレッシュトークンを取得できるように、Auth0 Dashboard で `offline_access` を有効にする必要があります。詳細については、[User authentication vs Connected Accounts](#user-authentication-vs-connected-accounts) を参照してください。
    4. **Save** をクリックします。
  </Tab>

  <Tab title="Management API">
    Management API を使用して Connected Accounts を構成するには、`connected_accounts` を `true` に設定するために `/connections/{connectionId}` エンドポイントに `PATCH` リクエストを送信します。

    ```bash lines
    curl -L -X PATCH "https://{yourDomain}/api/v2/connections/{connectionId}" \
    -H 'Content-Type: application/json' \
    -H 'Accept: application/json' \
    -H "Authorization: Bearer <YOUR_MANAGEMENT_API_TOKEN>" \
    -d '{"connected_accounts":{"active":true}}'
    ```
  </Tab>
</Tabs>

<div id="get-access-token-for-connected-accounts">
  ## Connected Accounts 用のアクセストークンを取得する
</div>

Connected Accounts のリクエストを開始する前に、Connected Accounts 向けのスコープを付与した My Account API 用の[アクセストークンを取得](/docs/ja-JP/manage-users/my-account-api#scope)します。

次のセクションでは、My Account API 用のアクセストークンを取得するために [Multi-Resource Refresh Token (MRRT)](/docs/ja-JP/secure/tokens/refresh-tokens/multi-resource-refresh-token) を使用する方法を説明します。

<div id="fetch-a-refresh-token">
  ### リフレッシュトークンを取得する
</div>

クライアントアプリケーションに対して [MRRT を設定](#configure-multi-resource-refresh-token) した後、認可コードフローを開始し、その結果として得られる認可コードをリフレッシュトークンと交換します。

次の例は、機密クライアント用の認可コードフローリクエストで、My Account API 識別子 `https://{yourDomain}/me/` に対するリフレッシュトークンと一度だけ使用できる認可コードを返すために `offline_scope` を含めたものです。

```bash lines
open "https://{yourDomain}/authorize?client_id=<CLIENT_ID>&response_type=code&prompt=login&scope=openid%20profile%20offline_access&redirect_uri=<REDIRECT_URI>&state=<STATE>&audience=https://my-example-api.com"
```

`/token` エンドポイントで、1回限りの認可コードをリフレッシュトークンに交換します。

```bash lines
curl -s --request POST \
  --url "https://{yourDomain}/oauth/token" \
  --header 'Content-Type: application/json' \
  --data-binary @- <<EOF | jq -r '.refresh_token'
{
  "grant_type": "authorization_code",
  "code": "<CONNECT_CODE>",
  "scope": "openid profile offline_access",
  "client_id": "<CLIENT_ID>",
  "client_secret": "<CLIENT_SECRET>",
  "audience": "https://{yourDomain}/me/",
  "redirect_uri": "<REDIRECT_URI>"
}
EOF
```

<div id="exchange-refresh-token-for-my-account-api-access-token">
  ### リフレッシュトークンを My Account API アクセストークンに交換する
</div>

リフレッシュトークンを取得したら、`refresh_token` グラントタイプを使用して、Connected Accounts のスコープを持つ My Account API のアクセストークンに交換します。

```bash lines
curl -s -X POST "https://{yourDomain}/oauth/token" \
  -H "Content-Type: application/x-www-form-urlencoded" \
  --data-urlencode "grant_type=refresh_token" \
  --data-urlencode "client_id=<CLIENT_ID>" \
  --data-urlencode "client_secret=<CLIENT_SECRET>" \
  --data-urlencode "refresh_token=<REFRESH_TOKEN>" \
  --data-urlencode "audience=https://{yourDomain}/me/" \
  --data-urlencode "scope=openid profile offline_access create:me:connected_accounts read:me:connected_accounts delete:me:connected_accounts"
```

<div id="initiate-connected-accounts-request">
  ## Connected Accounts リクエストの開始
</div>

Connected Accounts リクエストを開始するには、My Account API の `/me/v1/connected-accounts/connect` エンドポイントに対して、以下のパラメーターを指定して `POST` リクエストを送信します。

<Callout icon="file-lines" color="#0EA5E9" iconType="regular">
  Google ソーシャル接続の場合、接続を設定する際に Auth0 Dashboard で `offline_access` を必ず選択してください。これは、クライアントアプリケーションが Auth0 認可サーバーからリフレッシュトークンを取得するために必要です。
</Callout>

<table class="table">
  <thead>
    <tr>
      <th><strong>パラメーター</strong></th>
      <th><strong>説明</strong></th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td><code>connection</code></td>
      <td>接続の名前。Google ソーシャル接続の場合は、<code>google-oauth2</code> を指定します。</td>
    </tr>

    <tr>
      <td><code>redirect&#95;uri</code></td>
      <td>クライアントアプリケーションのコールバック URL。</td>
    </tr>

    <tr>
      <td><code>state</code></td>
      <td>攻撃を防ぐためにリクエストに関連付けられた、一意のランダムな文字列。</td>
    </tr>

    <tr>
      <td><code>scopes</code></td>
      <td>(任意) 外部プロバイダーに文字列の配列として渡されるスコープ。<br /><br />Google ソーシャル接続のスコープを渡すために使用する場合は、最低でも `openid` と `profile` を含めてください。実行時には、`scopes` パラメーターに含まれるスコープが、接続で必要とされ Auth0 Dashboard で有効化されている場合の `offline_access` を除き、Auth0 Dashboard で選択されたスコープより優先されます。</td>
    </tr>
  </tbody>
</table>

```bash lines
curl --request POST "https://{yourDomain}/me/v1/connected-accounts/connect" \
--header 'Content-Type: application/json' \
--header "Authorization: Bearer <MY_ACCOUNT_API_TOKEN>" \
--data '{
    "connection": "google-oauth2",
    "redirect_uri": "<REDIRECT_URI>",
    "state": "<STATE>",
    "scopes": ["openid","profile"] // 渡されたスコープは Auth0 Dashboard で選択したスコープを上書きします
}'
```

成功すると、My Account API は次のようなレスポンスを返します。

<table class="table">
  <thead>
    <tr>
      <th><strong>Parameter</strong></th>
      <th><strong>Description</strong></th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td><code>auth&#95;session</code></td>
      <td>プライマリーユーザーの現在の認証済みセッションを表すセッション ID。クライアントアプリケーションは、後で検証するためにこのセッション ID を保存します。</td>
    </tr>

    <tr>
      <td><code>connect&#95;uri</code></td>
      <td>クライアントアプリケーションがユーザーをリダイレクトする URL。外部プロバイダーとの認可を処理するために Web ブラウザーを開きます。</td>
    </tr>

    <tr>
      <td><code>connect&#95;params</code></td>
      <td>connect URI に必要な追加パラメーター。My Account API がリクエストを検証するために使用する一時チケットを含みます。</td>
    </tr>

    <tr>
      <td><code>expires&#95;in</code></td>
      <td>セッションの有効期限（秒）。</td>
    </tr>
  </tbody>
</table>

```json
{
  "auth_session": "PKM-CYkdx2FyLb4Oob4ED91cSE7i_XJ4SVJByik0xKQxz9CgUZ5JlYr-aMPty0Xr",
  "connect_uri": "https://{yourDomain}.us.auth0.com/connect",
  "connect_params": {
    "ticket": "9375f326-5846-4b57-ae8b-8042573f7c1f"
  },
  "expires_in": 300
}
```

Webブラウザーで、クエリパラメーターとして `ticket` を付与した `connect_uri` にアクセスします。コンセント画面で表示されるスコープ一覧を承認し、URLフラグメントに含まれる `connect_code` を抽出して保存します。

```bash lines
open https://{yourDomain}.us.auth0.com/connected-accounts/connect?ticket={tickedId}
```

<div id="complete-connected-accounts-request">
  ## Connected Accounts リクエストの完了
</div>

Connected Accounts リクエストを完了するには、次のパラメーターを指定して `/me/v1/connected-accounts/complete` エンドポイントに `POST` リクエストを送信します。

<table class="table">
  <thead>
    <tr>
      <th><strong>パラメーター</strong></th>
      <th><strong>説明</strong></th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td><code>auth&#95;session</code></td>
      <td>プライマリーユーザーの現在の認証済みセッションを表すセッション ID です。クライアントアプリケーションは、このセッション ID を後で検証するために保存します。</td>
    </tr>

    <tr>
      <td><code>connect&#95;code</code></td>
      <td>外部プロバイダーの認可プロセスから受け取る、1 回限り・短時間のみ有効なコードです。このコードは、外部 API 用の最終的なアクセストークンを取得するために、サーバー側で安全に交換されます。</td>
    </tr>

    <tr>
      <td><code>redirect&#95;uri</code></td>
      <td>外部プロバイダーとの接続を正常に認可した後にユーザーが送られた、アプリケーションの正確なコールバック URL です。この値は、フローを開始する際に使用した `redirect_uri` と一致している必要があります。</td>
    </tr>
  </tbody>
</table>

```bash lines
curl --location "https://{yourDomain}/me/v1/connected-accounts/complete" \
--header 'Content-Type: application/json' \
--header "Authorization: Bearer <MY_ACCOUNT_API_TOKEN>" \
--data '{
    "auth_session": "<AUTH_SESSION>",
    "connect_code": "<CONNECT_CODE>",
    "redirect_uri": "<REDIRECT_URI>"
}'
```

If successful, the My Account API returns a response like the following:

<table class="table">
  <thead>
    <tr>
      <th><strong>パラメーター</strong></th>
      <th><strong>説明</strong></th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td><code>id</code></td>
      <td>接続済みアカウントの一意の識別子。</td>
    </tr>

    <tr>
      <td><code>connection</code></td>
      <td>接続の名前。</td>
    </tr>

    <tr>
      <td><code>created&#95;at</code></td>
      <td>接続済みアカウントが作成され、ユーザープロファイルにリンクされた日時。</td>
    </tr>

    <tr>
      <td><code>scopes</code></td>
      <td>ユーザーが外部プロバイダーへの接続時に、アプリケーションへのアクセスを許可した特定の OAuth スコープ（権限）。これらのスコープによって、アプリケーションが外部 API に対して実行できるアクションが決まります。</td>
    </tr>

    <tr>
      <td><code>access&#95;type</code></td>
      <td>付与されたアクセスの種類を示します。一般的な値は <code>offline</code> で、これはリフレッシュトークンが正常に取得および保存されており、ユーザーがオフラインの場合でもアプリケーションがアクセスを維持できることを意味します。</td>
    </tr>
  </tbody>
</table>

```json
{
  "id": "cac_6ZqSK7Kj1R8LDZJvSb1tAn",
  "connection": "google-oauth2",
  "created_at": "2025-10-13T21:09:04.126Z",
  "scopes": [
    "https://www.googleapis.com/auth/calendar",
    "https://www.googleapis.com/auth/calendar.addons.execute",
    "https://www.googleapis.com/auth/calendar.events",
    "https://www.googleapis.com/auth/calendar.events.readonly",
    "https://www.googleapis.com/auth/calendar.settings.readonly",
    "https://www.googleapis.com/auth/userinfo.profile",
    "openid"
  ],
  "access_type": "offline"
}
```

<div id="manage-connected-accounts">
  ## 連携アカウントを管理する
</div>

ユーザーの連携アカウントを管理するには、`/me/v1/connected-accounts` コレクションを使用します。

`/connected-accounts` コレクションを使用する前に、[Connected Accounts 用のアクセストークンを取得](#get-access-token-for-connected-accounts)してください。

<div id="query-connected-accounts-connections">
  ### 接続済みアカウントの Connection を取得する
</div>

`/me/v1/connected-accounts/connections` エンドポイントに `GET` リクエストを送信して、ユーザープロファイルにリンクされている接続の一覧を取得します。

```bash lines
curl -X GET --location "https://{yourDomain}/me/v1/connected-accounts/connections" \
--header 'Content-Type: application/json' \
--header "Authorization: Bearer <MY_ACCOUNT_API_TOKEN>"
```

成功すると、My Accounts API は次のようなレスポンスを返します。

```json
{
  "connections": [
    {
      "name": "google-oauth2",
      "strategy": "google-oauth2",
      "scopes": [
        "email",
        "profile",
        "https://www.googleapis.com/auth/calendar",
        "https://www.googleapis.com/auth/calendar.events",
        "https://www.googleapis.com/auth/calendar.addons.execute",
        "https://www.googleapis.com/auth/calendar.events.readonly",
        "https://www.googleapis.com/auth/calendar.settings.readonly",
        "openid"
      ]
    },
    {
      "name": "custom",
      "strategy": "oauth2",
      "scopes": [
        "openid"
      ]
    }
  ]
}
```

<div id="query-connected-accounts">
  ### 接続済みアカウントをクエリする
</div>

`/me/v1/connected-accounts/accounts` エンドポイントに `GET` リクエストを送信して、ユーザー プロファイルにリンクされた接続済みアカウントの一覧を取得します。

```bash lines
curl -X GET --location "https://{yourDomain}/me/v1/connected-accounts/accounts" \
--header 'Content-Type: application/json' \
--header "Authorization: Bearer <MY_ACCOUNT_API_TOKEN>"
```

リクエストが成功すると、My Accounts API は次のようなレスポンスを返します。

```json
{
  "accounts": [
    {
      "id": "cac_6ZqSK7Kj1R8LDZJvSb1tAn",
      "connection": "google-oauth2",
      "access_type": "offline",
      "scopes": [
        "https://www.googleapis.com/auth/calendar",
        "https://www.googleapis.com/auth/calendar.addons.execute",
        "https://www.googleapis.com/auth/calendar.events",
        "https://www.googleapis.com/auth/calendar.events.readonly",
        "https://www.googleapis.com/auth/calendar.settings.readonly",
        "https://www.googleapis.com/auth/userinfo.profile",
        "openid"
      ],
      "created_at": "2025-10-13T21:09:04.126Z"
    },
    {
      "id": "cac_fH32E6CWN7HcWZN5w9Vieq",
      "connection": "custom",
      "access_type": "offline",
      "scopes": [
        "offline_access",
        "openid",
        "profile"
      ],
      "created_at": "2025-10-13T18:06:47.216Z"
    }
  ]
}
```

Management API を使用して、`GET` リクエストを `/users/{userId}/connected-accounts` エンドポイントに送信すると、ユーザープロファイルの接続済みアカウント一覧を取得することもできます。

```bash lines
curl -X GET --location "https://{yourDomain}/api/v2/users/{userId}/connected-accounts" \
--header 'Content-Type: application/json' \
--header "Authorization: Bearer <YOUR_MANAGEMENT_API_TOKEN>"
```

成功すると、Management APIは次のようなレスポンスを返します。

```json
{
  "connected_accounts": [
    {
      "id": "cac_6ZqSK7Kj1R8LDZJvSb1tAn",
      "connection": "google-oauth2",
      "connection_id": "con_uBbSbbSpqGqOTvRu",
      "strategy": "google-oauth2",
      "access_type": "offline",
      "scopes": [
        "https://www.googleapis.com/auth/calendar",
        "https://www.googleapis.com/auth/calendar.addons.execute",
        "https://www.googleapis.com/auth/calendar.events",
        "https://www.googleapis.com/auth/calendar.events.readonly",
        "https://www.googleapis.com/auth/calendar.settings.readonly",
        "https://www.googleapis.com/auth/userinfo.profile",
        "openid"
      ],
      "created_at": "2025-10-13T21:09:04.126Z"
    }
  ]
}
```

<div id="query-connected-accounts-for-a-given-connection">
  ### 特定の接続に対する接続済みアカウントのクエリ
</div>

`/me/v1/connected-accounts/accounts` エンドポイントに `GET` リクエストを送信し、クエリパラメータとして接続名を指定して、ユーザープロファイルにリンクされている接続済みアカウントのうち、指定した接続に属するものだけの一覧を取得します。

```bash lines
curl -X GET --location "https://{yourDomain}/me/v1/connected-accounts/accounts?connection={connectionName}" \
--header 'Content-Type: application/json' \
--header "Authorization: Bearer <MY_ACCOUNT_API_TOKEN>"
```

成功すると、My Accounts API は `google-oauth2` 接続でフィルタリングされた次のようなレスポンスを返します。

```json
{
  "accounts": [
    {
      "id": "cac_6ZqSK7Kj1R8LDZJvSb1tAn",
      "connection": "google-oauth2",
      "access_type": "offline",
      "scopes": [
        "https://www.googleapis.com/auth/calendar",
        "https://www.googleapis.com/auth/calendar.addons.execute",
        "https://www.googleapis.com/auth/calendar.events",
        "https://www.googleapis.com/auth/calendar.events.readonly",
        "https://www.googleapis.com/auth/calendar.settings.readonly",
        "https://www.googleapis.com/auth/userinfo.profile",
        "openid"
      ],
      "created_at": "2025-10-13T21:09:04.126Z"
    }
  ]
}
```

<div id="delete-connected-account">
  ### 連携済みアカウントを削除する
</div>

指定した ID の連携済みアカウントを削除するには、`DELETE` リクエストを `/me/v1/connected-accounts/accounts/{connectedAccountId}` エンドポイントに送信します。

```bash lines
curl -X DELETE --location "https://{yourDomain}/me/v1/connected-accounts/accounts/{connectedAccountId}" \
--header 'Content-Type: application/json' \
--header "Authorization: Bearer <MY_ACCOUNT_API_TOKEN>"
```

接続済みアカウントを削除すると、Auth0 は Token Vault から外部プロバイダーのアクセストークンとリフレッシュトークンを削除します。これは外部プロバイダー側のトークンを自動的に失効させるものではなく、リフレッシュトークンは引き続き新しいアクセストークンの取得に使用できる可能性があります。トークンが共有されていたり他の場所にコピーされている場合は、外部プロバイダー側でトークンを手動で失効させる必要があります。

成功すると、My Accounts API は次のようなレスポンスを返します。

```
HTTP/1.1 204 No Content
```
