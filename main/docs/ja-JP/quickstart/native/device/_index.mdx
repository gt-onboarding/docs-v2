---
title: デバイス認可フロー

---

import { Recipe, Content, Section, SideMenu, SideMenuSectionItem, SignUpForm } from "/snippets/ja-JP/recipe.jsx";
import { LoggedInForm } from "/snippets/ja-JP/Login.jsx";

import {AuthCodeGroup} from "/snippets/ja-JP/AuthCodeGroup.jsx";

export const sections = [
  { id: "prerequisites", title: "前提条件" },
  { id: "request-device-code", title: "デバイスコードのリクエスト" },
  { id: "receive-device-code", title: "デバイスコードの受信" },
  { id: "request-device-activation", title: "デバイスの有効化のリクエスト" },
  { id: "poll-the-token-endpoint", title: "トークンエンドポイントのポーリング" },
  { id: "user-authorization", title: "ユーザーによる認可" },
  { id: "receive-tokens", title: "トークンの受信" },
  { id: "call-your-api", title: "API の呼び出し" },
  { id: "refresh-tokens", title: "トークンのリフレッシュ" },
  { id: "troubleshooting", title: "トラブルシューティング" },
  { id: "sample-implementations", title: "サンプル実装" },
  { id: "limitations", title: "制限事項" }
]

<Recipe isSingleColumn>
  <Content>
    このチュートリアルでは、Device Authorization Flowを使用して、入力制約のあるデバイスからAPIを呼び出す方法を説明します。アカウント用に設定された例でこのクイックスタートを進めるために、ログインすることをお勧めします。

    インタラクティブな体験を試すには、[Device Flow Playground](https://auth0.github.io/device-flow-playground/)を使用できます。

    <Section id={sections[0].id} title={sections[0].title} stepNumber="1" isSingleColumn>
      * ネイティブアプリケーションを登録します。
      * **OIDC Conformant** トグルが有効になっていることを確認します。詳細は「OIDC-Conformant Authentication」を参照してください。
      * アプリケーションのグラントタイプに **Device Code** を追加します。詳細は「Update Grant Types」を参照してください。
      * リフレッシュトークンを有効にする場合は、アプリケーションのグラントタイプに **Refresh Token** を追加します。
      * アプリケーション用に少なくとも 1 つの接続を設定して有効にします。
      * Auth0 に API を登録します。
      * リフレッシュトークンを使用する場合は、**Allow Offline Access** を有効にします。詳細は「API Settings」を参照してください。
      * ランダムに生成されるユーザーコードの文字セット、形式、および長さを定義するために、Device User Code Settings を構成します。

      <LoggedInForm />
    </Section>

    <Section id={sections[1].id} title={sections[1].title} stepNumber="2" isSingleColumn>
      ユーザーがデバイスアプリケーションを起動して認可したい場合、アプリケーションはAuth0 Authentication APIからデバイスコードをリクエストし、ユーザーセッションに関連付ける必要があります。

      デバイスコードを取得するには、アプリケーションから Authentication API の Device Authorization Flow [Authorize エンドポイント](https://auth0.com/docs/api/authentication#-post-oauth-device-code-)を呼び出す必要があります:

      <AuthCodeGroup>
        ```bash cURL lines
        curl --request post \
          --url 'https://{yourDomain}/oauth/device/code' \
          --header 'content-type: application/x-www-form-urlencoded'
        ```

        ```csharp C# lines
        var client = new RestClient("https://{yourDomain}/oauth/device/code");
        var request = new RestRequest(Method.POST);
        request.AddHeader("content-type", "application/x-www-form-urlencoded");
        IRestResponse response = client.Execute(request);
        ```

        ```go Go lines 
        package main
        import (
        "fmt"
        "net/http"
        "io/ioutil"
        )
        func main() {
        url := "https://{yourDomain}/oauth/device/code"
        req, _ := http.NewRequest("post", url, nil)
        req.Header.Add("content-type", "application/x-www-form-urlencoded")
        res, _ := http.DefaultClient.Do(req)
        defer res.Body.Close()
        body, _ := ioutil.ReadAll(res.Body)
        fmt.Println(res)
        fmt.Println(string(body))
        }
        ```

        ```java Java lines
        HttpResponse<String> response = Unirest.post("https://{yourDomain}/oauth/device/code")
          .header("content-type", "application/x-www-form-urlencoded")
          .asString();
        ```

        ```javascript Node.JS lines
        var axios = require("axios").default;
        var options = {
        method: 'post',
        url: 'https://{yourDomain}/oauth/device/code',
        headers: {'content-type': 'application/x-www-form-urlencoded'}
        };
        axios.request(options).then(function (response) {
        console.log(response.data);
        }).catch(function (error) {
        console.error(error);
        });
        ```

        ```objc Obj-C lines 
        #import <Foundation/Foundation.h>
        NSDictionary *headers = @{ @"content-type": @"application/x-www-form-urlencoded" };
        NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@"https://{yourDomain}/oauth/device/code"]
                                                          cachePolicy:NSURLRequestUseProtocolCachePolicy

                                                      timeoutInterval:10.0];

        [request setHTTPMethod:@"post"];
        [request setAllHTTPHeaderFields:headers];
        NSURLSession *session = [NSURLSession sharedSession];
        NSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request
                                                completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {

                                                    if (error) {

                                                        NSLog(@&quot;%@&quot;, error);

                                                    } else {

                                                        NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;

                                                        NSLog(@&quot;%@&quot;, httpResponse);

                                                    }

                                                }];

        [dataTask resume];
        ```

        ```php PHP lines 
        $curl = curl_init();
        curl_setopt_array($curl, [
        CURLOPT_URL => "https://{yourDomain}/oauth/device/code",
        CURLOPT_RETURNTRANSFER => true,
        CURLOPT_ENCODING => "",
        CURLOPT_MAXREDIRS => 10,
        CURLOPT_TIMEOUT => 30,
        CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
        CURLOPT_CUSTOMREQUEST => "post",
        CURLOPT_HTTPHEADER => [
        &quot;content-type: application/x-www-form-urlencoded&quot;

        ],
        ]);
        $response = curl_exec($curl);
        $err = curl_error($curl);
        curl_close($curl);
        if ($err) {
        echo "cURL Error #:" . $err;
        } else {
        echo $response;
        }
        ```

        ```python Python lines
        import http.client
        conn = http.client.HTTPSConnection("")
        headers = { 'content-type': "application/x-www-form-urlencoded" }
        conn.request("post", "/{yourDomain}/oauth/device/code", headers=headers)
        res = conn.getresponse()
        data = res.read()
        print(data.decode("utf-8"))
        ```

        ```ruby Ruby lines
        require 'uri'
        require 'net/http'
        require 'openssl'
        url = URI("https://{yourDomain}/oauth/device/code")
        http = Net::HTTP.new(url.host, url.port)
        http.use_ssl = true
        http.verify_mode = OpenSSL::SSL::VERIFY_NONE
        request = Net::HTTP::Post.new(url)
        request["content-type"] = 'application/x-www-form-urlencoded'
        response = http.request(request)
        puts response.read_body
        ```

        ```swift Swift lines 
        import Foundation
        let headers = ["content-type": "application/x-www-form-urlencoded"]
        let request = NSMutableURLRequest(url: NSURL(string: "https://{yourDomain}/oauth/device/code")! as URL,
                                            cachePolicy: .useProtocolCachePolicy,

                                        timeoutInterval: 10.0)

        request.httpMethod = "post"
        request.allHTTPHeaderFields = headers
        let session = URLSession.shared
        let dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in
        if (error != nil) {
        print(error)

        } else {
        let httpResponse = response as? HTTPURLResponse

        print(httpResponse)

        }
        })
        dataTask.resume()
        ```
      </AuthCodeGroup>

      <LoggedInForm />
    </Section>

    <Section id={sections[2].id} title={sections[2].title} stepNumber="3" isSingleColumn>
      デバイス アプリケーションは、HTTP 200 レスポンスと、次のようなペイロードを受信するはずです。

      ```json lines
      {
        "device_code": "GmRh...k9eS",
        "user_code": "WDJB-MJHT",
        "verification_uri": "https://my-tenant.auth0.com/device",
        "verification_uri_complete": "https://my-tenant.auth0.com/device?user_code=WDJB-MJHT",
        "expires_in": 900,
        "interval": 5
      }
      ```

      <LoggedInForm />
    </Section>

    <Section id={sections[3].id} title={sections[3].title} stepNumber="4" isSingleColumn>
      デバイスアプリケーションが `device_code` と `user_code` を受信したら、ユーザーに `verification_uri` へアクセスして `user_code` を入力するよう指示します。

      <Frame>
        <img src="/docs/images/cdy7uua7fh8z/3Q9q41wocl6SojRoiGefXT/a98582a3c86740aaeb3d957f2dc4afe6/request-device-activation.png" />
      </Frame>

      <Info>
        `device_code` はユーザーが直接利用することを想定していないため、ユーザーを混乱させないよう、やり取りの際には表示しないでください。
      </Info>

      <Info>
        CLI を構築する場合は、この手順を省略して、`verification_uri_complete` を使用してすぐにブラウザーを開くこともできます。
      </Info>

      <LoggedInForm />
    </Section>

    <Section id={sections[4].id} title={sections[4].title} stepNumber="5" isSingleColumn>
      デバイスアプリケーションがユーザーによる有効化を待っている間は、一定間隔で Authentication API の [POST /oauth/token エンドポイント](https://auth0.com/docs/api/authentication#-post-oauth-token-) を呼び出し、
      レスポンスを適切に処理する必要があります。

      <Info>
        デバイスアプリケーションは、ネットワーク遅延による問題を回避するため、`interval`（秒）で指定された長さ、または
        正常なレスポンスを受信するまでのいずれか長い方の時間だけ待機するようにしてください。
      </Info>

      ```bash
      curl --request POST \ 
        --url 'https://{yourDomain}/oauth/token' \
        --header 'content-type: application/x-www-form-urlencoded' \
        --data grant_type=urn:ietf:params:oauth:grant-type:device_code \
        --data device_code=AUTH0_SCOPES \
        --data 'client_id={yourClientId}'
      ```

      <LoggedInForm />
    </Section>

    <Section id={sections[5].id} title={sections[5].title} stepNumber="6" isSingleColumn>
      ユーザーは、QR コードをスキャンするか、アクティベーションページを開いてユーザーコードを入力します。

      <Frame>
        <img src="/docs/images/cdy7uua7fh8z/7IwrVX4s5a36CvfY95rKCo/dfc962ecde65502945741b1dc8b5c879/Device_Activation_-_English.png" />
      </Frame>

      正しいデバイスであることをユーザーに確認してもらうための確認ページが表示されます。

      <Frame>
        <img src="/docs/images/cdy7uua7fh8z/5dwhOyM1HRNwfV3Co4Da2o/424a2bc1a1bb44a54c587a0bcddd8222/Device_Confirmation_-_English.png" />
      </Frame>

      ユーザーはサインインしてトランザクションを完了します。このステップには、次の処理が 1 つ以上含まれる場合があります。

      * ユーザーの認証
      * 認証を処理するためにユーザーをアイデンティティ プロバイダーへリダイレクトする
      * アクティブな SSO セッションを確認する
      * 事前にデバイスへの同意が与えられていない場合は、デバイスに対するユーザーの同意を取得する

      <Frame>
        <img src="/docs/images/cdy7uua7fh8z/3GqqaNB7sjcAYTQiTnEEsn/7199a9b319283686057ca32c853f7a05/Login_screen_-_English.png" />
      </Frame>

      認証と同意が正常に完了すると、確認プロンプトが表示されます。

      <Frame>
        <img src="/docs/images/cdy7uua7fh8z/2TsQpMa8fzifiojuEXLvDo/484a49b775ec5a6b3522983a425599fe/Success_message_-_English.png" />
      </Frame>

      この時点で、ユーザーは認証され、デバイスは承認されています。

      <LoggedInForm />
    </Section>

    <Section id={sections[6].id} title={sections[6].title} stepNumber="7" isSingleColumn>
      ユーザーがデバイスアプリケーションを承認すると、HTTP 200 のレスポンスと次のペイロードが返されます。

      ```json lines
      {
        "access_token": "eyJz93a...k4laUWw",
        "refresh_token": "GEbRxBN...edjnXbL",
        "id_token": "eyJ0XAi...4faeEoQ",
        "token_type": "Bearer",
        "expires_in": 86400
      }
      ```

      <Info>
        トークンは保存する前に必ず検証してください。方法については「アクセストークンの検証」と「IDトークンの検証」を参照してください。
      </Info>

      アクセストークンは、Authentication API の [Get User Info エンドポイント](https://auth0.com/docs/api/authentication#get-user-info)（デバイスアプリケーションで `openid` スコープをリクエストした場合）または `audience`
      パラメータで指定された API を呼び出すために使用されます。独自の API を呼び出す場合は、デバイスアプリケーションがアクセストークンを使用する前に、それを検証する必要があります。

      IDトークンには、[デコードおよび抽出する必要がある](/docs/ja-JP/secure/tokens/id-tokens#id-token-payload) ユーザー情報が含まれます。Authentication API は、デバイスアプリケーションが `openid` スコープをリクエストした場合にのみ `id_token` を返します。

      リフレッシュトークンは、前のトークンの有効期限が切れた後に、新しいアクセストークンまたは
      IDトークンを取得するために使用されます。Authentication API は、`audience` パラメータで指定された API に対して **Allow Offline Access** 設定が有効になっており、
      かつデバイスアプリケーションが `offline_access` スコープをリクエストした場合にのみ `refresh_token` を返します。

      <LoggedInForm />
    </Section>

    <Section id={sections[7].id} title={sections[7].title} stepNumber="8" isSingleColumn>
      API を呼び出すには、デバイスアプリケーションは HTTP リクエストの `Authorization` ヘッダーに、アクセストークンを Bearer トークンとして渡す必要があります。

      ```bash lines
      curl --request GET \
        --url https://myapi.com/api \
        --header 'authorization: Bearer AUTH0_API_ACCESS_TOKEN' \
        --header 'content-type: application/json'
      ```

      <LoggedInForm />
    </Section>

    <Section id={sections[8].id} title={sections[8].title} stepNumber="9" isSingleColumn>
      ユーザーの新しいアクセストークンを取得するには、デバイスアプリケーションで `refresh_token` パラメーターを指定して Authentication API の [POST /oauth/token エンドポイント](https://auth0.com/docs/api/authentication#-post-oauth-token-) を呼び出すことができます。

      ```bash lines
      curl --request POST \
        --url 'https://{yourDomain}/oauth/token' \
        --header 'content-type: application/x-www-form-urlencoded' \
        --data grant_type=refresh_token \
        --data 'client_id={yourClientId}' \
        --data 'client_secret={yourClientSecret}' \
        --data refresh_token=AUTH0_REFRESH_TOKEN
      ```

      リクエストが成功すると、デバイスアプリケーションは次のペイロードを含む HTTP 200 応答を受信します。

      ```json lines
      {
        "access_token": "eyJ...MoQ",
        "expires_in": 86400,
        "scope": "openid offline_access",
        "id_token": "eyJ...0NE",
        "token_type": "Bearer"
      }
      ```

      リフレッシュトークンについて詳しくは、[リフレッシュトークン](https://auth0.com/docs/secure/tokens/refresh-tokens)を参照してください。

      <LoggedInForm />
    </Section>

    <Section id={sections[9].id} title={sections[9].title} stepNumber="10" isSingleColumn>
      テナントログは、発生したあらゆるインタラクションに対して作成され、問題のトラブルシューティングに利用できます。

      ### トークンレスポンス

      ユーザーがデバイスを承認するのを待っている間、いくつかの異なる HTTP 4xx レスポンスを受け取ることがあります。

      #### 認可保留中

      ユーザーが操作を行うのを待っている間、このエラーが表示されます。チュートリアルの前の手順で取得した推奨された`interval`を使用してポーリングを続けてください。

      ```json lines
      `HTTP 403`
      {
      "error": "authorization_pending",
      "error_description": "..."
      }
      ```

      #### ポーリング頻度を下げる

      ポーリングの間隔が短すぎます。ポーリングの頻度を下げ、このチュートリアルの前の手順で取得した推奨間隔を使用してください。ネットワーク遅延が原因でこのエラーが発生しないようにするには、直前のポーリングリクエストのレスポンスを受信してから各間隔のカウントを開始してください。

      ```json lines
      `HTTP 429`
      {
      "error": "slow_down",
      "error_description": "..."
      }
      ```

      #### 期限切れトークン

      ユーザーがデバイスを迅速に承認しなかったため、`device_code` の有効期限が切れました。
      アプリケーションは、このフローの有効期限が切れたことをユーザーに通知し、フローを再度開始するよう促す必要があります。

      <Info>
        `expired_token` エラーは 1 回だけ返されます。その後は、エンドポイントは
        `invalid_grant` エラーを返します。
      </Info>

      ```json lines
      `HTTP 403`
      {
      "error": "expired_token",
      "error_description": "..."
      }
      ```

      #### アクセス拒否

      アクセスが拒否された場合、次のような応答が返されます。

      ```json lines
      `HTTP 403`
      {
      "error": "access_denied",
      "error_description": "..."
      }
      ```

      これは、次のような理由で発生する可能性があります。

      * ユーザーがデバイスの認可を拒否した。
      * 認可サーバーがトランザクションを拒否した。
      * 設定されている Action がアクセスを拒否した。

      <LoggedInForm />
    </Section>

    <Section id={sections[10].id} title={sections[10].title} stepNumber="11" isSingleColumn>
      以下のサンプルを参照して、このフローを実際のアプリケーションに実装する方法を学んでください。

      * [Device
        Authorization Playground](https://auth0.github.io/device-flow-playground/)
      * [AppleTV (Swift)](https://github.com/pushpabrol/auth0-device-flow-appletv): AppleTV で Auth0 の Device Authorization Flow を利用する方法を示すシンプルなアプリケーションです。
      * [CLI (Node.js)](https://gist.github.com/panva/652c61e7d847e0ed99926c324fa91b36): Authorization Code Flow の代わりに Device Authorization Flow を使用する CLI のサンプル実装です。主な違いは、CLI が Web サーバーをホストしてポートをリッスンする必要がないことです。

      <LoggedInForm />
    </Section>

    <Section id={sections[11].id} title={sections[11].title} stepNumber="12" isSingleColumn>
      Device Authorization Flow を使用するには、デバイス アプリケーションは次の条件を満たしている必要があります。

      * Server Name Indication (SNI) をサポートしていること
      * ネイティブ アプリケーションであること
      * [Authentication Method](/docs/ja-JP/secure/application-credentials#application-authentication-methods) が **None** に設定されていること
      * [OIDC-conformant](/docs/ja-JP/get-started/applications/application-settings#oauth) であること
      * Dynamic Client Registration を通じて作成されていないこと

      さらに、Device Authorization Flow では次のことは許可されません。

      * New Universal Login Experience を使用している場合を除き、Auth0 の開発者キーを使用するソーシャル接続
      * ホスト型ログイン ページまたは Actions からクエリ文字列パラメータへアクセスすること

      <LoggedInForm />
    </Section>

    ## 次のステップ

    素晴らしい!ここまで進めたなら、アプリケーションでログイン、ログアウト、およびユーザープロファイル情報が実装されているはずです。

    これでクイックスタートチュートリアルは終了ですが、他にも多くの機能があります。Auth0でできることの詳細については、以下をご確認ください:

    * [Auth0 Dashboard](https://manage.auth0.com/dashboard/us/dev-gja8kxz4ndtex3rq) - Auth0 テナントとアプリケーションの設定と管理方法を学ぶ
    * [Auth0 Marketplace](https://marketplace.auth0.com/) - Auth0 の機能を拡張できるインテグレーションを見つける
  </Content>
</Recipe>