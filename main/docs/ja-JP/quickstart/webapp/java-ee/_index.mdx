---
title: Java EE の Webアプリケーションにログイン機能を追加する

sidebarTitle: Java EE
---

import { Recipe, Content, Section, SideMenu, SideMenuSectionItem, SignUpForm } from "/snippets/ja-JP/recipe.jsx";
import { LoggedInForm } from "/snippets/ja-JP/Login.jsx";
import Web from "/snippets/ja-JP/quickstart/webapp/java-ee/web.xml.mdx";
import Auth0authenticationconfig from "/snippets/ja-JP/quickstart/webapp/java-ee/Auth0AuthenticationConfig.java.mdx";
import Loginservlet from "/snippets/ja-JP/quickstart/webapp/java-ee/LoginServlet.java.mdx";
import Homeservlet from "/snippets/ja-JP/quickstart/webapp/java-ee/HomeServlet.java.mdx";
import Logoutservlet from "/snippets/ja-JP/quickstart/webapp/java-ee/LogoutServlet.java.mdx";

import {AuthCodeGroup} from "/snippets/ja-JP/AuthCodeGroup.jsx";

export const sections = [
  { id: "system-requirements", title: "システム要件" },
  { id: "configure-auth0", title: "Auth0 を設定する" },
  { id: "configure-java-ee-to-use-auth0", title: "Auth0 を利用するように Java EE を設定する" },
  { id: "configure-java-ee-security", title: "Java EE のセキュリティを設定する" },
  { id: "trigger-authentication", title: "認証を開始する" },
  { id: "display-user-information", title: "ユーザー情報を表示する" },
  { id: "handle-logout", title: "ログアウトを処理する" },
  { id: "run-the-sample", title: "サンプルを実行する" }
]


<Recipe isSingleColumn>
  <Content>
    このチュートリアルでは、Java EE Webアプリケーションにユーザーログインを追加する方法を説明します。アカウントに合わせて設定された例を使用してこのクイックスタートを進めるため、ログインすることをお勧めします。

    <Section id={sections[0].id} title={sections[0].title} stepNumber="1" isSingleColumn>
      このチュートリアルおよびサンプルプロジェクトは、次の環境でテスト済みです。

      * Java 11

      <LoggedInForm />
    </Section>

    <Section id={sections[1].id} title={sections[1].title} stepNumber="2" isSingleColumn>
      ### アプリケーションキーを取得する

      Auth0 にサインアップすると、新しいアプリケーションが自動的に作成されるか、または自分で新しいアプリケーションを作成しているはずです。
      Auth0 と連携するために、そのアプリケーションに関するいくつかの情報が必要です。これらの情報は Auth0 Dashboard の [Application
      Settings](https://manage.auth0.com/#/applications) セクションから取得できます。

      <Frame>
        <img src="/docs/images/cdy7uua7fh8z/1NtemqhRTHLFgWkGyAVSC6/ae66506a56ffab891e8a36e1344e6376/uwp.png" />
      </Frame>

      次の情報が必要です:

      * **Domain**
      * **Client ID**
      * **Client Secret**

      <Info>
        このページの上部にあるサンプルをダウンロードした場合は、これらの値はすでに設定済みです。
      </Info>

      ### コールバックURLを設定する

      コールバックURLは、ユーザーが認証を完了した後に Auth0 があなたのアプリケーションへリダイレクトする URL です。
      アプリのコールバックURLは、Auth0 Dashboard の [Application
      Settings](https://manage.auth0.com/#/applications) の **Allowed Callback URLs** フィールドに追加する必要があります。このフィールドが設定されていない場合、ユーザーはアプリケーションにログインできず、エラーが発生します。

      <Info>
        このページの上部からダウンロードしたサンプルプロジェクトに沿って進めている場合は、
        **Allowed Callback URLs** フィールドに追加する必要があるコールバックURLは
        `http://localhost:3000/callback` です。
      </Info>

      ### ログアウトURLを設定する

      ログアウトURLは、ユーザーが認可サーバーからログアウトした後に、Auth0 がユーザーを戻すことができる、あなたのアプリケーション内の URL です。
      これは `returnTo` クエリパラメーターで指定されます。アプリのログアウトURLは、Auth0 Dashboard の [Application Settings](https://manage.auth0.com/#/applications) の **Allowed Logout URLs** フィールドに追加する必要があります。このフィールドが設定されていない場合、ユーザーはアプリケーションからログアウトできず、エラーが発生します。

      <Info>
        このページの上部からダウンロードしたサンプルプロジェクトに沿って進めている場合は、
        **Allowed Logout URLs** フィールドに追加する必要があるログアウトURLは `http://localhost:3000/` です。
      </Info>

      <LoggedInForm />
    </Section>

    <Section id={sections[2].id} title={sections[2].title} stepNumber="3" isSingleColumn>
      ### 依存関係を設定する

      Java EE アプリケーションを Auth0 と統合するには、次の依存関係を追加します。

      * **javax.javaee-api**: Java EE 8 を使用してアプリケーションを開発するために必要な Java EE 8 API です。実際の
        実装はアプリケーションコンテナによって提供されるため、WAR ファイルに含める必要はありません。
      * **javax.security.enterprise**: EE アプリケーションでセキュリティ関連の処理を行えるようにする Java EE 8 Security API です。
        `javax.javaee-api` 依存関係と同様に、実装はアプリケーションコンテナによって提供されるため、
        WAR ファイルには含めません。
      * **auth0-java-mvc-commons**: [Auth0 Java MVC SDK](https://github.com/auth0/auth0-java-mvc-common) は、サーバーサイド MVC Web
        アプリケーションから Java を使って Auth0 を利用できるようにします。アプリケーションが Auth0 を使用して
        ユーザーを認証する際に呼び出す必要がある Authorize URL を生成します。

      Maven を使用している場合は、これらの依存関係を `pom.xml` に追加してください。

      ```xml lines
      <!-- pom.xml -->
      <dependency>
      <groupId>com.auth0</groupId>
      <artifactId>mvc-auth-commons</artifactId>
      <version>[1.0, 2.0)</version>
      </dependency>
      <dependency>
      <groupId>javax</groupId>
      <artifactId>javaee-api</artifactId>
      <version>8.0.1</version>
      <scope>provided</scope>
      </dependency>
      <dependency>
      <groupId>javax.security.enterprise</groupId>
      <artifactId>javax.security.enterprise-api</artifactId>
      <version>1.0</version>
      <scope>provided</scope>
      </dependency>
      ```

      Gradle を使用している場合は、`build.gradle` に次を追加します。

      ```java lines
      // build.gradle
      providedCompile 'javax:javaee-api:8.0.1'
      providedCompile 'javax.security.enterprise:javax.security.enterprise-api:1.0'
      implementation 'com.auth0:mvc-auth-commons:1. '
      ```

      ### Java EE アプリケーションを構成する

      <Info>
        このチュートリアルに付属するサンプルは JSP を使用して作成され、[WildFly](https://wildfly.org/) アプリケーションサーバーでテストされています。
        別のアプリケーションコンテナやテクノロジーを使用している場合は、手順を一部調整する必要があるかもしれません。
      </Info>

      Java EE アプリケーションが Auth0 アプリケーションでユーザーを認証するには、いくつかの情報が必要になります。
      デプロイメント記述子 `web.xml` ファイルを使用してこの情報を保存できますが、別の安全な場所に保存してもかまいません。

      この情報は、**auth0-java-mvc-commons** ライブラリを構成して、ユーザーがアプリケーションにログインできるようにするために使用されます。ライブラリおよびそのさまざまな構成オプションの詳細については、ライブラリの [README](https://github.com/auth0/auth0-java-mvc-common/blob/master/README.md) を参照してください。

      <AuthCodeGroup>
        <Web />

        <Auth0authenticationconfig />

        <Loginservlet />

        <Homeservlet />

        <Logoutservlet />
      </AuthCodeGroup>
    </Section>

    <Section id={sections[3].id} title={sections[3].title} stepNumber="4" isSingleColumn>
      Java EE 8 Security APIは、アプリケーションがユーザーの認証情報を取得できるようにする`HttpAuthenticationMechanism`インターフェースを導入しました。Basic認証とフォームベース認証のデフォルト実装が用意されており、カスタム認証戦略を簡単に設定できます。

      Auth0で認証するには、以下のインターフェースのカスタム実装を提供してください。

      * HttpAuthenticationMechanism: Auth0 から戻ってきたユーザーの認証フローを処理する役割を担います。([JavaDoc](https://javaee.github.io/javaee-spec/javadocs/javax/security/enterprise/authentication/mechanism/http/HttpAuthenticationMechanism.html)).
      * IdentityStore: ユーザーの認証情報を検証する責務を持ちます（[JavaDoc](https://javaee.github.io/javaee-spec/javadocs/javax/security/enterprise/identitystore/IdentityStore.html) を参照）。
      * CallerPrincipal: 現在の HTTP リクエストの呼び出し元のプリンシパルを表します（[JavaDoc](https://javaee.github.io/javaee-spec/javadocs/javax/security/enterprise/CallerPrincipal.html)）。
      * Credential: 呼び出し元が認証に使用する資格情報を表します（[JavaDoc](https://javaee.github.io/javaee-spec/javadocs/javax/security/enterprise/credential/Credential.html)）。

      まず、@ApplicationScopedビーンを作成してWebコンテキストから値を取得し、ゲッターで利用できるようにすることで、Auth0の設定をアプリケーションで使用できるようにします。

      次に、現在のリクエストの呼び出し元を表すカスタム `CallerPrincipal` を作成します：

      ```java lines
      // src/main/java/com/auth0/example/security/Auth0JwtPrincipal.java
      public class Auth0JwtPrincipal extends CallerPrincipal {
      private final DecodedJWT idToken;



      Auth0JwtPrincipal(DecodedJWT idToken) {

          super(idToken.getClaim(&quot;name&quot;).asString());

          this.idToken = idToken;

      }



      public DecodedJWT getIdToken() {

          return this.idToken;

      }

      }
      ```

      これで、ユーザーの認証情報を表すカスタム`Credential`を実装できます。これは、プリンシパルに関する情報を保持します:

      ```java lines
      // src/main/java/com/auth0/example/security/Auth0JwtCredential.java
      class Auth0JwtCredential implements Credential {
      private Auth0JwtPrincipal auth0JwtPrincipal;



      Auth0JwtCredential(String token) {

          DecodedJWT decodedJWT = JWT.decode(token);

          this.auth0JwtPrincipal = new Auth0JwtPrincipal(decodedJWT);

      }



      Auth0JwtPrincipal getAuth0JwtPrincipal() {

          return auth0JwtPrincipal;

      }

      }
      ```

      これで、呼び出し元プリンシパルと認証情報を表すクラスを定義しました。次に、`IdentityStore`のカスタム実装を作成します。このクラスは、ユーザーの認証情報を検証する役割を担います:

      ```java lines
      // src/main/java/com/auth0/example/security/Auth0JwtIdentityStore.java
      @ApplicationScoped
      public class Auth0JwtIdentityStore implements IdentityStore {
      @Override

      public CredentialValidationResult validate(final Credential credential) {

          CredentialValidationResult result = CredentialValidationResult.NOT_VALIDATED_RESULT;

          if (credential instanceof Auth0JwtCredential) {

              Auth0JwtCredential auth0JwtCredential = (Auth0JwtCredential) credential;

              result = new CredentialValidationResult(auth0JwtCredential.getAuth0JwtPrincipal());

          }

          return result;

      }

      }
      ```

      `credential` が `Auth0Credential` である場合、呼び出し元のユーザーは認証済みで有効であるため、
      その credential を使用して作成された `CredentialValidationResult` が成功を示すために返されます。`Auth0Credential` でない場合は、`CredentialValidationResult.NOT_VALIDATED_RESULT` を返します。

      これらすべてのコラボレーターを使用する `HttpAuthenticationMechanism` インターフェースを実装する前に、
      Auth0 Java MVC ソフトウェア開発キット (SDK) から設定済みの `AuthenticationController` インスタンスを提供する Bean を作成します。`AuthenticationController` は、ユーザーがログインする認可 URL の構築と、ユーザー認証のためのトークン交換の処理に使用されます。

      * Auth0 Application が **RS256 署名アルゴリズム**（新しい Auth0 Application を作成するときのデフォルト）を使用するように構成されている場合、トークンの署名を検証するために使用される公開鍵を取得するための `JwkProvider` を構成する必要があります。追加の構成オプションについては、[jwks-rsa-java リポジトリ](https://github.com/auth0/jwks-rsa-java) を参照してください。
      * Auth0 Application が **HS256 の署名アルゴリズム** を使用するように構成されている場合は、`JwkProvider` を構成する必要はありません。

      <Info>
        利用可能な署名アルゴリズムについて詳しくは、[ドキュメント](https://auth0.com/docs/tokens/concepts/signing-algorithms)を参照してください。
      </Info>

      以下のサンプルは、**RS256 署名アルゴリズム**を使用するための `AuthenticationController` の設定方法を示しています:

      ```java lines
      // src/main/java/com/auth0/example/security/Auth0AuthenticationProvider.java
      @ApplicationScoped
      public class Auth0AuthenticationProvider {
      @Produces

      public AuthenticationController authenticationController(Auth0AuthenticationConfig config) {

          JwkProvider jwkProvider = new JwkProviderBuilder(config.getDomain()).build();

          return AuthenticationController.newBuilder(config.getDomain(), config.getClientId(), config.getClientSecret())

                  .withJwkProvider(jwkProvider)

                  .build();

      }

      }
      ```

      最後に、カスタム `HttpAuthenticationMechanism` を実装します

      ``

      ```java lines expandable
      // src/main/java/com/auth0/example/security/Auth0AuthenticationMechanism.java
      @ApplicationScoped
      @AutoApplySession
      public class Auth0AuthenticationMechanism implements HttpAuthenticationMechanism {
      private final AuthenticationController authenticationController;

      private final IdentityStoreHandler identityStoreHandler;



      @Inject

      Auth0AuthenticationMechanism(AuthenticationController authenticationController, IdentityStoreHandler identityStoreHandler) {

          this.authenticationController = authenticationController;

          this.identityStoreHandler = identityStoreHandler;

      }



      @Override

      public AuthenticationStatus validateRequest(HttpServletRequest httpServletRequest,

                                                  HttpServletResponse httpServletResponse,

                                                  HttpMessageContext httpMessageContext) throws AuthenticationException {



          // コードをIDトークンと交換し、コンテナに結果を通知します。

          if (isCallbackRequest(httpServletRequest)) {

              try {

                  Tokens tokens = authenticationController.handle(httpServletRequest, httpServletResponse);

                  Auth0JwtCredential auth0JwtCredential = new Auth0JwtCredential(tokens.getIdToken());

                  CredentialValidationResult result = identityStoreHandler.validate(auth0JwtCredential);

                  return httpMessageContext.notifyContainerAboutLogin(result);

              } catch (IdentityVerificationException e) {

                  return httpMessageContext.responseUnauthorized();

              }

          }

          return httpMessageContext.doNothing();

      }



      private boolean isCallbackRequest(HttpServletRequest request) {

          return request.getRequestURI().equals(&quot;/callback&quot;) &amp;&amp; request.getParameter(&quot;code&quot;) != null;

      }

      }
      ```

      このクラスは `validateRequest` メソッドをオーバーライドします。このメソッドはアプリケーションへのすべてのリクエストで呼び出され、認証状態をコンテナに通知する役割を担います。

      このサンプルは[Authorization Code
      Flow](https://auth0.com/docs/flows/concepts/auth-code)を使用して、認証フロー中に認可コードをトークンと交換します。このリクエストが
      `/callback`エンドポイントへのものであり、`code`リクエストパラメータを含む場合、いくつかの重要な処理を実行します:

      * Authorization Code を IDトークンおよびアクセストークンと交換するために、`AuthenticationController` の `handle` メソッドを呼び出します。
      * IDトークンを使用して新しい `Auth0Credential` を作成します。
      * カスタム `IdentityStore` 実装の `validate` メソッドを呼び出して、バリデーション結果を取得します。
      * アプリケーションコンテナにログイン状態を通知します。

      リクエストされたリソースが `/callback` でない場合は、`httpMessageContext.doNothing()` を返して
      リクエスト処理を継続させます。認証のトリガー時やWebビューの表示時に認証情報を使用する方法については、この後すぐに説明します。

      最後に、`@AutoApplySession` アノテーションが追加されており、コンテナが認証済みユーザーのセッションを作成できるようになっている点に注意してください。

      <AuthCodeGroup>
        <Auth0authenticationconfig />

        <Web />

        <Loginservlet />

        <Homeservlet />

        <Logoutservlet />
      </AuthCodeGroup>
    </Section>

    <Section id={sections[4].id} title={sections[4].title} stepNumber="5" isSingleColumn>
      ユーザーがログインできるようにするには、`/login` パスへのリクエストを処理する Servlet を作成します。

      `LoginController` は、リクエストを適切な認可 URL へリダイレクトし、
      ユーザーが Auth0 で認証できるようにする役割を担います。これは Auth0 Java
      MVC ソフトウェア開発キット (SDK) の `AuthenticationController` を使用し、`Auth0AuthenticationConfig` を介して注入された構成値を用いて、正しい認可 URL を構築します。デフォルトでは、このサンプルは `"openid profile email"`
      というスコープをリクエストしており、認証済みユーザーの基本的なプロファイル情報をアプリケーションが取得できるようにしています。これらのスコープの詳細については、[OpenID
      Connect スコープ](https://auth0.com/docs/scopes/current/oidc-scopes) のドキュメントを参照してください。

      ユーザーが資格情報を入力して要求された権限を許可すると、Auth0 は `callbackUrl` へリクエストを送信し、ID トークンとアクセストークンに交換できる `code` クエリパラメータを含めます。前述のとおり、先ほど作成した `Auth0HttpAuthenticationMechanism` がこの交換処理を行い、アプリケーションコンテナに認証状況を通知します。これにより、`/callback` パスへのリクエストを処理する Servlet は、ログイン前に元々要求されていたリソースへ単純にリクエストをフォワードするか、ホームページへリダイレクトするだけで済みます。

      ```java lines
      // src/main/com/auth0/example/web/CallbackServlet.java
      @WebServlet(urlPatterns = {"/callback"})
      public class CallbackServlet extends HttpServlet {
      @Override

      public void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {

          String referer = (String) request.getSession().getAttribute(&quot;Referer&quot;);

          String redirectTo = referer != null ? referer : &quot;/&quot;;



          response.sendRedirect(redirectTo);

      }

      }
      ```

      <AuthCodeGroup>
        <Loginservlet />

        <Web />

        <Auth0authenticationconfig />

        <Homeservlet />

        <Logoutservlet />
      </AuthCodeGroup>
    </Section>

    <Section id={sections[5].id} title={sections[5].title} stepNumber="6" isSingleColumn>
      認証されたユーザーのプロファイル情報を取得するには、`Auth0JwtPrincipal` を使用できます。
      `HomeServlet.java` のコードサンプルでは、[IDトークン](https://auth0.com/docs/tokens/id-token) のクレームを使用して、プロファイルデータをリクエスト属性として設定する方法を示しています。

      その後、そのプロファイル情報をビューで利用して、ユーザーに関する情報を表示できます。

      ```xml lines
      <!-- src/main/webapp/WEB-INF/jsp/fragments/navbar.jspf -->
      <c:choose>
      <c:when test="{empty profile}">
      <li>
      <form action="/login" method="GET">
      <input type="submit" value="ログイン"/>
      </form>
      </li>
      </c:when>
      <c:otherwise>
      <li>
      <a href="#">
      <!-- プロファイル画像はIDトークンのプロファイル画像に設定する必要があります -->
      <img src="{profile.get('picture').asString()}" alt="プロファイル画像"/>
      </a>
      <div>
      <!-- ここにIDトークンからユーザーのフルネームを表示 -->
      <div>"{profile.get('name').asString()}"</div>
      <a href="/docs/profile">プロファイル</a>
      <a href="/docs/logout">ログアウト</a>
      </div>
      </li>
      </c:otherwise>
      </c:choose>
      ```

      <AuthCodeGroup>
        <Homeservlet />

        <Web />

        <Auth0authenticationconfig />

        <Loginservlet />

        <Logoutservlet />
      </AuthCodeGroup>
    </Section>

    <Section id={sections[6].id} title={sections[6].title} stepNumber="7" isSingleColumn>
      ユーザーをログアウトさせるには、アプリケーションのセッションをクリアし、Auth0 からもログアウトさせる必要があります。これは `LogoutServlet` で処理されます。

      まず、`request.getSession().invalidate()` を呼び出してセッションをクリアします。次にログアウト用の URL を構築しますが、その際、ログアウト後にユーザーがリダイレクトされる場所を指定する `returnTo` クエリパラメータを必ず含めてください。最後に、レスポンスをアプリケーションのログアウト URL にリダイレクトします。

      <AuthCodeGroup>
        <Logoutservlet />

        <Web />

        <Auth0authenticationconfig />

        <Loginservlet />

        <Homeservlet />
      </AuthCodeGroup>
    </Section>

    <Section id={sections[7].id} title={sections[7].title} stepNumber="8" isSingleColumn>
      サンプルをビルドして実行するには、`wildfly:run` Maven ゴールを実行して、埋め込み WildFly アプリケーションサーバーを起動し、
      このアプリケーションをそこにデプロイします。詳細については、[WildFly Maven Plugin](https://docs.jboss.org/wildfly/plugins/maven/latest/) のドキュメントを参照してください。

      Linux または macOS を使用している場合:

      ```sh lines
      ./mvnw clean wildfly:run
      ```

      Windows：

      ```sh lines
      mvnw.cmd clean wildfly:run
      ```

      ブラウザーで `http:``//localhost:3000.` を開きます。**Log In** リンクをクリックしてログインするか、
      Auth0 テナントにサインアップします。

      ログインに成功すると、ユーザーのプロフィール画像と、以前 **Log In** リンクがあった場所にドロップダウンメニューが表示されます。
      **Profile** リンクをクリックすると、ユーザーのプロファイルページを表示できます。ドロップダウンメニュー内の
      **Logout** リンクをクリックするとログアウトできます。

      <LoggedInForm />
    </Section>

    ## 次のステップ

    素晴らしい!ここまで進めたなら、アプリケーションでログイン、ログアウト、およびユーザープロファイル情報が実装されているはずです。

    これでクイックスタートチュートリアルは終了ですが、他にも多くの機能があります。Auth0でできることの詳細については、以下をご確認ください:

    * [Auth0 Dashboard](https://manage.auth0.com/dashboard/us/dev-gja8kxz4ndtex3rq) - Auth0 テナントとアプリケーションの設定・管理方法を学ぶ
    * [auth0-java-mvc-common ソフトウェア開発キット (SDK)](https://github.com/auth0/auth0-java-mvc-common) - このチュートリアルで使用しているソフトウェア開発キット (SDK) についてさらに詳しく知る
    * [Auth0 Marketplace](https://marketplace.auth0.com/) - Auth0 の機能を拡張できるインテグレーションを見つける
  </Content>
</Recipe>