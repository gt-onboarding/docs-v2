---
title: "Java EE"
permalink: "01-login"
---

import {AuthCodeBlock} from "/snippets/ja-JP/AuthCodeBlock.jsx";

<div id="by-jim-anderson">
  ##### Jim Anderson による
</div>

このチュートリアルでは、Java EE のウェブアプリケーションにユーザーログイン機能を追加する方法を説明します。ご自身のアカウントに合わせて構成されたサンプルを利用できるよう、このクイックスタートを始める前にログインしておくことをおすすめします。

{/* <Card title="View on Github" href="https://github.com/auth0-samples/auth0-java-ee-sample/tree/master/01-Login" icon="github">
  システム要件：Java 11
  </Card> */}

<Info>
  **認証は初めてですか？** [Auth0 の仕組み](/docs/ja-JP/get-started/auth0-overview)、[一般的な Web アプリケーションとの統合方法](/docs/ja-JP/get-started/architecture-scenarios/sso-for-regular-web-apps)、そして利用している[プロトコル](/docs/ja-JP/get-started/authentication-and-authorization-flow)について学びましょう。
</Info>

<div id="configure-auth0">
  ## Auth0 を設定する
</div>

<div id="get-your-application-keys">
  ### アプリケーションキーを取得する
</div>

Auth0 にサインアップしたときに、新しいアプリケーションが自動的に作成されるか、自分で新しいアプリケーションを作成したはずです。Auth0 と連携するには、そのアプリケーションに関するいくつかの設定情報が必要です。これらの情報は Auth0 Dashboard の [Application Settings](https://manage.auth0.com/#/applications) セクションから取得できます。

<Frame>![アプリケーションダッシュボード](https://cdn2.auth0.com/docs/1.14550.0/media/articles/dashboard/client_settings.png)</Frame>

次の情報が必要です。

* **ドメイン**
* **クライアントID**
* **クライアントシークレット**

<Info>
  このページ上部からサンプルをダウンロードした場合、これらの情報はすでに入力済みです。
</Info>

<div id="configure-callback-urls">
  ### コールバックURLの設定
</div>

コールバックURLは、ユーザーが認証された後に Auth0 がユーザーをリダイレクトする、アプリケーション内の URL です。アプリケーションのコールバックURLは、[Application Settings](https://manage.auth0.com/#/applications) の **Allowed Callback URLs** フィールドに追加する必要があります。このフィールドが設定されていない場合、ユーザーはアプリケーションにログインできず、エラーが表示されます。

<Info>
  このページの上部からダウンロードしたサンプルプロジェクトに従っている場合、**Allowed Callback URLs** フィールドに追加する必要があるコールバックURLは `http://localhost:3000/callback` です。
</Info>

<div id="configure-logout-urls">
  ### ログアウトURLを設定する
</div>

ログアウトURLは、ユーザーが認可サーバーからログアウトされた後に、Auth0 が戻り先としてリダイレクトできるアプリケーション内の URL です。これは `returnTo` クエリパラメーターで指定します。アプリのログアウトURLは、[Application Settings](https://manage.auth0.com/#/applications) 内の **許可されたログアウトURL** フィールドに追加する必要があります。このフィールドが設定されていない場合、ユーザーはアプリケーションからログアウトできず、エラーが発生します。

<Info>
  このページ上部からダウンロードしたサンプルプロジェクトを使用している場合、**許可されたログアウトURL** フィールドに追加する必要があるログアウトURLは `http://localhost:3000/` です。
</Info>

<div id="configure-java-ee-to-use-auth0">
  ## Java EE で Auth0 を利用するよう構成する
</div>

<div id="set-up-dependencies">
  ### 依存関係を設定する
</div>

Java EE アプリケーションを Auth0 と統合するには、次の依存関係を追加します。

* **javax.javaee-api**: Java EE 8 でアプリケーションを開発するために必要な Java EE 8 API です。実際の実装はアプリケーションコンテナによって提供されるため、WAR ファイルに含める必要はありません。
* **javax.security.enterprise**: EE アプリケーション内でセキュリティ関連の処理を行えるようにする Java EE 8 Security API です。`javax.javaee-api` 依存関係と同様に、実装はアプリケーションコンテナによって提供されるため、WAR ファイルには含めません。
* **auth0-java-mvc-commons**: [Auth0 Java MVC SDK](https://github.com/auth0/auth0-java-mvc-common) は、サーバーサイド MVC Web アプリケーションで Java と Auth0 を連携させるための SDK です。Auth0 を用いてユーザーを認証するために、アプリケーションが呼び出す必要のある Authorize URL を生成します。

Maven を使用している場合は、これらの依存関係を `pom.xml` に追加します。

```xml lines
<!-- pom.xml -->

<dependency>
    <groupId>com.auth0</groupId>
    <artifactId>mvc-auth-commons</artifactId>
    <version>[1.0, 2.0)</version>
</dependency>
<dependency>
    <groupId>javax</groupId>
    <artifactId>javaee-api</artifactId>
    <version>8.0.1</version>
    <scope>provided</scope>
</dependency>
<dependency>
    <groupId>javax.security.enterprise</groupId>
    <artifactId>javax.security.enterprise-api</artifactId>
    <version>1.0</version>
    <scope>provided</scope>
</dependency>
```

Gradle を使用している場合は、次を `build.gradle` に追加します。

```gradle lines
// build.gradle

providedCompile 'javax:javaee-api:8.0.1'
providedCompile 'javax.security.enterprise:javax.security.enterprise-api:1.0'
implementation 'com.auth0:mvc-auth-commons:1.+'
```

<div id="configure-your-java-ee-application">
  ### Java EE アプリケーションを構成する
</div>

<Info>
  このチュートリアルに付属しているサンプルは JSP を使用して記述され、[WildFly](https://wildfly.org/) アプリケーションサーバーでテストされています。別のアプリケーションコンテナや技術を使用している場合は、一部の手順を調整する必要があるかもしれません。
</Info>

Java EE アプリケーションで Auth0 アプリケーションを使ってユーザーを認証するには、いくつかの情報が必要になります。デプロイメント記述子である `web.xml` ファイルにこの情報を保存できますが、別の安全な場所に保存してもかまいません。必要な情報は次のとおりです。

export const codeExample = `<!-- \`src/main/webapp/WEB-INF/web.xml\`-->

<env-entry>
    <env-entry-name>auth0.domain</env-entry-name>
    <env-entry-type>java.lang.String</env-entry-type>
    <env-entry-value>{yourDomain}</env-entry-value>
</env-entry>
<env-entry>
    <env-entry-name>auth0.clientId</env-entry-name>
    <env-entry-type>java.lang.String</env-entry-type>
    <env-entry-value>{yourClientId}</env-entry-value>
</env-entry>
<env-entry>
    <env-entry-name>auth0.clientSecret</env-entry-name>
    <env-entry-type>java.lang.String</env-entry-type>
    <env-entry-value>{yourClientSecret}</env-entry-value>
</env-entry>
<env-entry>
    <env-entry-name>auth0.scope</env-entry-name>
    <env-entry-type>java.lang.String</env-entry-type>
    <env-entry-value>openid profile email</env-entry-value>
</env-entry>`;

<AuthCodeBlock children={codeExample} language="xml" />

この情報は、ユーザーがあなたのアプリケーションにログインできるようにするために、**auth0-java-mvc-commons** ライブラリを設定する際に使用します。ライブラリの詳細や各種設定オプションについては、ライブラリの [README](https://github.com/auth0/auth0-java-mvc-common/blob/master/README.md) を参照してください。

<Note>
  ### 設定済み属性の確認

  **Download Sample** ボタンを使用してこのサンプルをダウンロードした場合、`domain`、`clientId`、`clientSecret` 属性には値が自動的に設定されています。特にアカウント内に複数の Auth0 アプリケーションがある場合は、それらの値が正しいかどうかを確認してください。
</Note>

<div id="configure-java-ee-security">
  ## Java EE セキュリティの構成
</div>

Java EE 8 の Security API では、アプリケーションがユーザーの認証情報を取得できるようにするために `HttpAuthenticationMechanism` インターフェースが導入されました。Basic 認証およびフォームベース認証用のデフォルト実装が用意されており、カスタム認証戦略を簡単に構成できます。

Auth0 で認証を行うには、次のインターフェースのカスタム実装を用意します。

* `HttpAuthenticationMechanism`: ユーザーの認証情報を取得し、ログインが成功したかどうかをコンテナに通知する役割を担います（[JavaDoc](https://javaee.github.io/javaee-spec/javadocs/javax/security/enterprise/authentication/mechanism/http/HttpAuthenticationMechanism.html)）。
* `IdentityStore`: ユーザーの認証情報を検証する役割を担います（[JavaDoc](https://javaee.github.io/javaee-spec/javadocs/javax/security/enterprise/identitystore/IdentityStore.html)）。
* `CallerPrincipal`: 現在の HTTP リクエストの呼び出し元プリンシパルを表します（[JavaDoc](https://javaee.github.io/javaee-spec/javadocs/javax/security/enterprise/CallerPrincipal.html)）。
* `Credential`: 呼び出し元が認証に使用する認証情報を表します（[JavaDoc](https://javaee.github.io/javaee-spec/javadocs/javax/security/enterprise/credential/Credential.html)）。

まず、Web コンテキストから値を取得して getter で参照できるようにする `@ApplicationScoped` bean を作成し、Auth0 の設定をアプリケーションから利用できるようにします。

```java lines
// src/main/java/com/auth0/example/security/Auth0AuthenticationConfig.java

@ApplicationScoped
public class Auth0AuthenticationConfig {

    private String domain;
    private String clientId;
    private String clientSecret;
    private String scope;

    @PostConstruct
    public void init() {
        // web.xml の env-entries から認証設定値を取得
        try {
            Context env = (Context)new InitialContext().lookup("java:comp/env");

            this.domain = (String) env.lookup("auth0.domain");
            this.clientId = (String) env.lookup("auth0.clientId");
            this.clientSecret = (String) env.lookup("auth0.clientSecret");
            this.scope = (String) env.lookup("auth0.scope");
        } catch (NamingException ne) {
            throw new IllegalArgumentException("web.xml から Auth0 設定プロパティを検索できません", ne);
        }

        if (this.domain == null || this.clientId == null || this.clientSecret == null || this.scope == null) {
            throw new IllegalArgumentException("domain、clientId、clientSecret、scope は web.xml に設定する必要があります");
        }
    }

    public String getDomain() {
         return domain;
    }

    public String getClientId() {
         return clientId;
    }

    public String getClientSecret() {
         return clientSecret;
    }

    public String getScope() {
        return scope;
    }
}
```

次に、現在のリクエストの呼び出し元を表すカスタム `CallerPrincipal` を作成します。

```java lines
// src/main/java/com/auth0/example/security/Auth0JwtPrincipal.java

public class Auth0JwtPrincipal extends CallerPrincipal {
    private final DecodedJWT idToken;

    Auth0JwtPrincipal(DecodedJWT idToken) {
        super(idToken.getClaim("name").asString());
        this.idToken = idToken;
    }

    public DecodedJWT getIdToken() {
        return this.idToken;
    }
}
```

ここで、ユーザーの認証情報を表すために使用されるカスタム `Credential` を実装できるようになります。これにはプリンシパルに関する情報が保持されます。

```java lines
// src/main/java/com/auth0/example/security/Auth0JwtCredential.java

class Auth0JwtCredential implements Credential {
    private Auth0JwtPrincipal auth0JwtPrincipal;

    Auth0JwtCredential(String token) {
        DecodedJWT decodedJWT = JWT.decode(token);
        this.auth0JwtPrincipal = new Auth0JwtPrincipal(decodedJWT);
    }

    Auth0JwtPrincipal getAuth0JwtPrincipal() {
        return auth0JwtPrincipal;
    }
}
```

これで、呼び出し元プリンシパルとクレデンシャルを表すクラスを定義しました。次に、`IdentityStore` のカスタム実装を作成します。このクラスは、ユーザーのクレデンシャルを検証する役割を担います。

```java lines
// src/main/java/com/auth0/example/security/Auth0JwtIdentityStore.java

@ApplicationScoped
public class Auth0JwtIdentityStore implements IdentityStore {

    @Override
    public CredentialValidationResult validate(final Credential credential) {
        CredentialValidationResult result = CredentialValidationResult.NOT_VALIDATED_RESULT;
        if (credential instanceof Auth0JwtCredential) {
            Auth0JwtCredential auth0JwtCredential = (Auth0JwtCredential) credential;
            result = new CredentialValidationResult(auth0JwtCredential.getAuth0JwtPrincipal());
        }
        return result;
    }
}
```

`credential` が `Auth0Credential` の場合、呼び出し側のユーザーは認証済みかつ有効であるため、その `credential` で作成した `CredentialValidationResult` を返して成功を示します。`Auth0Credential` でない場合は、`CredentialValidationResult.NOT_VALIDATED_RESULT` を返します。

これらすべてのコンポーネントを使用する `HttpAuthenticationMechanism` インターフェースを実装する前に、Auth0 Java MVC ソフトウェア開発キット (SDK) から、設定済みの `AuthenticationController` インスタンスを提供する Bean を作成します。`AuthenticationController` は、ユーザーがログインする認可 URL を構築し、ユーザーを認証するためのトークン交換を処理するために使用されます。

* Auth0 Application が **RS256 署名アルゴリズム** を使用するように構成されている場合 (新しい Auth0 Application を作成するときのデフォルト)、トークンの署名を検証するために使用される公開鍵を取得する `JwkProvider` を構成する必要があります。追加の構成オプションについては、[jwks-rsa-java リポジトリ](https://github.com/auth0/jwks-rsa-java)を参照してください。
* Auth0 Application が **HS256 署名アルゴリズム** を使用するように構成されている場合、`JwkProvider` を構成する必要はありません。

<Info>
  利用可能な署名アルゴリズムの詳細については、[ドキュメント](https://auth0.com/docs/tokens/concepts/signing-algorithms)を参照してください。
</Info>

次のサンプルは、**RS256 署名アルゴリズム** で使用するために `AuthenticationController` を構成する方法を示しています。

```java lines
// src/main/java/com/auth0/example/security/Auth0AuthenticationProvider.java

@ApplicationScoped
public class Auth0AuthenticationProvider {

    @Produces
    public AuthenticationController authenticationController(Auth0AuthenticationConfig config) {
        JwkProvider jwkProvider = new JwkProviderBuilder(config.getDomain()).build();
        return AuthenticationController.newBuilder(config.getDomain(), config.getClientId(), config.getClientSecret())
                .withJwkProvider(jwkProvider)
                .build();
    }
}
```

最後に、カスタム `HttpAuthenticationMechanism` を実装します。

```java lines
// src/main/java/com/auth0/example/security/Auth0AuthenticationMechanism.java

@ApplicationScoped
@AutoApplySession
public class Auth0AuthenticationMechanism implements HttpAuthenticationMechanism {
    private final AuthenticationController authenticationController;
    private final IdentityStoreHandler identityStoreHandler;

    @Inject
    Auth0AuthenticationMechanism(AuthenticationController authenticationController, IdentityStoreHandler identityStoreHandler) {
        this.authenticationController = authenticationController;
        this.identityStoreHandler = identityStoreHandler;
    }

    @Override
    public AuthenticationStatus validateRequest(HttpServletRequest httpServletRequest,
                                                HttpServletResponse httpServletResponse,
                                                HttpMessageContext httpMessageContext) throws AuthenticationException {

        // コードをIDトークンと交換し、結果をコンテナに通知します。
        if (isCallbackRequest(httpServletRequest)) {
            try {
                Tokens tokens = authenticationController.handle(httpServletRequest, httpServletResponse);
                Auth0JwtCredential auth0JwtCredential = new Auth0JwtCredential(tokens.getIdToken());
                CredentialValidationResult result = identityStoreHandler.validate(auth0JwtCredential);
                return httpMessageContext.notifyContainerAboutLogin(result);
            } catch (IdentityVerificationException e) {
                return httpMessageContext.responseUnauthorized();
            }
        }
        return httpMessageContext.doNothing();
    }

    private boolean isCallbackRequest(HttpServletRequest request) {
        return request.getRequestURI().equals("/callback") && request.getParameter("code") != null;
    }
}
```

このクラスでは、アプリケーションへのすべてのリクエストごとに呼び出され、認証ステータスをコンテナに通知する役割を持つ `validateRequest` メソッドをオーバーライドします。

このサンプルでは、認可コードフロー（[Authorization Code Flow](https://auth0.com/docs/get-started/authentication-and-authorization-flow/concepts/auth-code)）を使用して、認証フロー中に Authorization Code をトークンと交換します。このリクエストが `/callback` エンドポイント宛てで、かつ `code` リクエストパラメーターを含んでいる場合、次のような重要な処理を行います。

* `AuthenticationController` の `handle` メソッドを呼び出し、Authorization Code を IDトークンとアクセストークンに交換します。
* IDトークンを使用して、新しい `Auth0Credential` を作成します。
* カスタム `IdentityStore` 実装の `validate` メソッドを呼び出して、検証結果を取得します。
* アプリケーションコンテナにログインステータスを通知します。

要求されたリソースが `/callback` でない場合は、`httpMessageContext.doNothing()` を返して、リクエスト処理を継続できるようにします。認証をトリガーするときや Web ビューを表示するときに認証情報をどのように使用するかは、後ほど説明します。

最後に、`@AutoApplySession` アノテーションが追加されており、コンテナが認証済みユーザーのセッションを作成できるようになっている点に注意してください。

<div id="trigger-authentication">
  ## 認証をトリガーする
</div>

ユーザーがログインできるようにするには、`/login` パスへのリクエストを処理する Servlet を作成します。

```java lines
// src/main/java/com/auth0/example/web/LoginServlet.java

@WebServlet(urlPatterns = "/login")
public class LoginServlet extends HttpServlet {
    private final Auth0AuthenticationConfig config;
    private final AuthenticationController authenticationController;

    @Inject
    LoginServlet(Auth0AuthenticationConfig config, AuthenticationController authenticationController) {
        this.config = config;
        this.authenticationController = authenticationController;
    }

    @Override
    public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        // アプリケーションが認可コードを受け取るURL（例: http://localhost:3000/callback）
        String callbackUrl = String.format(
                "%s://%s:%s/callback",
                request.getScheme(),
                request.getServerName(),
                request.getServerPort()
        );

        // 認証フローを開始するため、ユーザーをリダイレクトする認可URLを作成します。
        String authURL = authenticationController.buildAuthorizeUrl(request, response, callbackUrl)
                .withScope(config.getScope())
                .build();

        response.sendRedirect(authURL);
    }
}
```

`LoginController` は、リクエストを適切な認可 URL にリダイレクトし、そこでユーザーが Auth0 を使って認証できるようにする役割を担います。`AuthenticationController` は Auth0 Java MVC ソフトウェア開発キット (SDK) の一部であり、`Auth0AuthenticationConfig` から注入された構成値を基に、正しい認可 URL を組み立てます。デフォルトでは、このサンプルは `"openid profile email"` というスコープを要求し、認証済みユーザーから基本的なプロファイル情報をアプリケーションが取得できるようにします。これらのスコープの詳細については、[OpenID Connect Scopes](https://auth0.com/docs/scopes/current/oidc-scopes) のドキュメントを参照してください。

ユーザーが認証情報を入力し、要求された権限を許可すると、Auth0 は `callbackUrl` にリクエストを送信し、IDトークンとアクセストークンに交換できる `code` クエリパラメーターを含めます。前述の `Auth0HttpAuthenticationMechanism` がこの交換処理を行い、その結果をアプリケーションコンテナに通知します。これにより、`/callback` パスへのリクエストを処理する Servlet は、ログイン前に要求されていた元のリソースへリクエストをフォワードするか、ホームページへリダイレクトするだけで済みます。

```java lines
// src/main/com/auth0/example/web/CallbackServlet.java

@WebServlet(urlPatterns = {"/callback"})
public class CallbackServlet extends HttpServlet {

    @Override
    public void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {
        String referer = (String) request.getSession().getAttribute("Referer");
        String redirectTo = referer != null ? referer : "/";

        response.sendRedirect(redirectTo);
    }
}
```

<div id="display-user-information">
  ## ユーザー情報を表示する
</div>

認証済みユーザーのプロファイル情報を取得するには、`Auth0JwtPrincipal` を使用できます。次のコード例は、[IDトークン](https://auth0.com/docs/tokens/id-token) に含まれるクレームを使用して、プロファイル情報をリクエスト属性として設定する方法を示しています。

```java lines
// src/main/java/com/auth0/example/web/HomeServlet.java

@WebServlet(urlPatterns = "")
public class HomeServlet extends HttpServlet {

    @Override
    public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        Principal principal = request.getUserPrincipal();

        if (principal instanceof Auth0JwtPrincipal) {
            Auth0JwtPrincipal auth0JwtPrincipal = (Auth0JwtPrincipal) principal;
            request.setAttribute("profile", auth0JwtPrincipal.getIdToken().getClaims());
        }
        request.getRequestDispatcher("/WEB-INF/jsp/home.jsp").forward(request, response);
    }
}
```

その後、ビューでそのプロファイル情報を使用して、ユーザーに関する情報を表示できます。

```jspf lines
<!-- src/main/webapp/WEB-INF/jsp/fragments/navbar.jspf -->

<c:choose>
    <c:when test="${empty profile}">
        <li>
            <form action="/login" method="GET">
                <input type="submit" value="ログイン"/>
            </form>
        </li>
    </c:when>
    <c:otherwise>
        <li>
            <a href="#">
                <!-- プロファイル画像はIDトークンのプロファイル画像に設定する必要があります -->
                <Frame><img src="${profile.get('picture').asString()}" alt="プロファイル画像"/></Frame>
            </a>
            <div>
                <!-- ここにIDトークンからユーザーのフルネームを表示します -->
                <div>"${profile.get('name').asString()}"</div>
                <a href="/docs/profile">プロファイル</a>
                <a href="/docs/logout">ログアウト</a>
            </div>
        </li>
    </c:otherwise>
</c:choose>
```

<div id="handle-logout">
  ## ログアウトを処理する
</div>

ユーザーをログアウトさせるには、アプリケーションのセッションをクリアし、Auth0 からもユーザーをログアウトさせる必要があります。これらの処理は `LogoutServlet` で行います。

まず、`request.getSession().invalidate()` を呼び出してセッションをクリアします。次に、ログアウト用URLを構築します。このとき、`returnTo` クエリパラメータを必ず含めてください。これは、ユーザーがログアウト後にリダイレクトされる場所を指定します。最後に、レスポンスをアプリケーションのログアウト用URLにリダイレクトします。

```java lines
// src/main/java/com/auth0/example/web/LogoutServlet.java

@WebServlet(urlPatterns = "/logout")
public class LogoutServlet extends HttpServlet {
    private final Auth0AuthenticationConfig config;

    @Inject
    LogoutServlet(Auth0AuthenticationConfig config) {
        this.config = config;
    }

    @Override
    protected void doGet(final HttpServletRequest request, final HttpServletResponse response) throws ServletException, IOException {
        clearSession(request);
        response.sendRedirect(getLogoutUrl(request));
    }

    private void clearSession(HttpServletRequest request) {
        if (request.getSession() != null) {
            request.getSession().invalidate();
        }
    }

    private String getLogoutUrl(HttpServletRequest request) {
        String returnUrl = String.format("%s://%s", request.getScheme(), request.getServerName());
        int port = request.getServerPort();
        String scheme = request.getScheme();

        if (("http".equals(scheme) && port != 80) ||
                ("https".equals(scheme) && port != 443)) {
            returnUrl += ":" + port;
        }

        returnUrl += "/";

        // 次のようなログアウトURLを構築:
        // https://{YOUR-DOMAIN}/v2/logout?client_id={YOUR-CLIENT-ID}&returnTo=http://localhost:3000/
        String logoutUrl = String.format(
                "https://%s/v2/logout?client_id=%s&returnTo=%s",
                config.getDomain(),
                config.getClientId(),
                returnUrl
        );

        return logoutUrl;
    }
}
```

<div id="run-the-sample">
  ## サンプルを実行する
</div>

サンプルをビルドして実行するには、`wildfly:run` Maven ゴールを実行して、このアプリケーションがデプロイされた組み込み WildFly アプリケーション サーバーを起動します。詳細については、[WildFly Maven Plugin](https://docs.jboss.org/wildfly/plugins/maven/latest/) のドキュメントを参照してください。

Linux または macOS を使用している場合は、次のようにします。

```bash lines
./mvnw clean wildfly:run
```

Windows の場合:

```sh lines
mvnw.cmd clean wildfly:run
```

ブラウザーで `http://localhost:3000` を開きます。**Log In** リンクをクリックして、Auth0 テナントにログインするかサインアップします。

<Frame>![Auth0 Universal Login](https://cdn2.auth0.com/docs/1.14550.0/media/quickstarts/universal-login.png)</Frame>

ログインに成功すると、ユーザーのプロファイル画像と、以前 **Log In** リンクが表示されていた位置にドロップダウン メニューが表示されます。**Profile** リンクをクリックすると、ユーザーのプロファイル ページを表示できます。ドロップダウン メニュー内の **Logout** リンクをクリックすると、ログアウトできます。

<Note>
  ##### 次にできること

  <table>
    <tr>
      <td><a href="/docs/ja-JP/authenticate/identity-providers">他のアイデンティティ プロバイダーを設定する</a></td>
      <td><a href="/docs/ja-JP/secure/multi-factor-authentication">多要素認証を有効にする</a></td>
    </tr>

    <tr>
      <td><a href="/docs/ja-JP/secure/attack-protection">攻撃対策について学ぶ</a></td>
      <td><a href="/docs/ja-JP/customize/rules">Rules について学ぶ</a></td>
    </tr>
  </table>

  [GitHub で編集](https://github.com/auth0/docs/edit/master/articles/quickstart/native/flutter/01-login.md)
</Note>
