---
title: "Spring Boot API: 認可"
permalink: "01-authorization"
---

import {AuthCodeBlock} from "/snippets/ja-JP/AuthCodeBlock.jsx";

<div id="by-jim-anderson">
  ##### 執筆: Jim Anderson
</div>

このチュートリアルでは、Okta Spring Boot Starter を使用して API に認可を追加する方法を説明します。アカウントに合わせて構成されたサンプルを使ってこのクイックスタートを進められるよう、事前にログインすることをおすすめします。

{/* <Card title="GitHub で表示" href="https://github.com/auth0-samples/auth0-spring-security5-api-sample/tree/master/01-Authorization-MVC" icon="github">
  システム要件: Java 17
  </Card> */}

この例では、次の内容を示します。

* 受信した HTTP リクエストの `Authorization` ヘッダー内に JSON Web Token (JWT) があるかどうかを確認する方法
* Auth0 アカウントの [JSON Web Key Set (JWKS)](/docs/ja-JP/secure/tokens/json-web-tokens/json-web-key-sets) を使用してトークンが有効かどうかを確認する方法。アクセストークンの検証の詳細については、[アクセストークンの検証](/docs/ja-JP/secure/tokens/access-tokens/validate-access-tokens)を参照してください。

<Info>
  **Auth0 を初めてお使いですか？** [Auth0 の仕組み](/docs/ja-JP/get-started/auth0-overview)と、OAuth 2.0 フレームワークを使用した[API 認証と認可の実装](/docs/ja-JP/get-started/authentication-and-authorization-flow)についてご覧ください。
</Info>

<Info>
  このクイックスタートでは Spring MVC を使用します。Spring WebFlux を使用している場合、API を保護するための手順は概ね同じですが、一部の実装の詳細が異なります。Spring WebFlux API と Auth0 を統合する方法については、[Spring Security WebFlux サンプルコード](https://github.com/auth0-samples/auth0-spring-security5-api-sample/tree/master/01-Authorization-WebFlux)を参照してください。
</Info>

<div id="configure-auth0-apis">
  ## Auth0 の API を設定する
</div>

<div id="create-an-api">
  ### API を作成する
</div>

Auth0 Dashboard の [APIs](https://manage.auth0.com/#/apis) セクションで **Create API** をクリックします。API の名前と識別子を入力します（例: `https://quickstarts/api`）。後でアクセストークン検証を設定する際に、この識別子を `audience`（オーディエンス）として使用します。**Signing Algorithm** は **RS256** のままにしておきます。

<Frame>![Create API](https://cdn2.auth0.com/docs/1.14550.0/media/articles/server-apis/create-api.png)</Frame>

デフォルトで、この API のトークン署名アルゴリズムには RS256 が使用されます。RS256 は秘密鍵/公開鍵のペアを使用するため、Auth0 アカウントの公開鍵を使ってトークンを検証します。公開鍵は [JSON Web Key Set (JWKS)](/docs/ja-JP/secure/tokens/json-web-tokens/json-web-key-sets) 形式で提供されており、[ここ](https://\{yourDomain}/.well-known/jwks.json) から取得できます。

<div id="define-permissions">
  ### パーミッションを定義する
</div>

パーミッションを使用すると、特定のアクセストークンを持つユーザーに代わって、リソースにどのようなアクセスを許可するかを定義できます。たとえば、ユーザーがマネージャーのアクセスレベルを持つ場合は `messages` リソースへの読み取りアクセス権を付与し、管理者のアクセスレベルを持つ場合はそのリソースへの書き込みアクセス権を付与できます。

許可するパーミッションは、Auth0 Dashboard の [APIs](https://manage.auth0.com/#/apis) セクションにある **Permissions** ビューで定義できます。

<Frame>![Configure Permissions](https://cdn2.auth0.com/docs/1.14550.0/media/articles/server-apis/configure-permissions.png)</Frame>

<Info>
  この例では `read:messages` というスコープを使用します。
</Info>

<div id="configure-the-sample-project">
  ## サンプル プロジェクトの設定
</div>

サンプル プロジェクトでは `/src/main/resources/application.yml` ファイルを使用して、正しい Auth0 の **ドメイン** と API 用の **API Identifier** を設定します。このページからコードをダウンロードした場合は、自動的に設定されています。GitHub からサンプルをクローンした場合は、これらの値を自分で入力する必要があります。

export const codeExample = `okta:
  oauth2:
    # Auth0 テナントのドメイン名に置き換えてください。
    issuer: https://{yourDomain}/
    # Auth0 API の API Identifier に置き換えてください。
    audience: {yourApiIdentifier}`;

<AuthCodeBlock children={codeExample} language="yml" />

<table class="table">
  <thead>
    <tr>
      <th>属性</th>
      <th>説明</th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td><code>okta.oauth2.audience</code></td>
      <td>API の一意の識別子です。このチュートリアルの手順に従っている場合は、<code>[https://quickstarts/api](https://quickstarts/api)</code> になります。</td>
    </tr>

    <tr>
      <td><code>okta.oauth2.issuer</code></td>
      <td>リソースサーバーの発行者 URI であり、Auth0 によって発行される JWT 内の <code>iss</code> クレームの値になります。Spring Security はこのプロパティを使用して認可サーバーの公開鍵を取得し、JWT 署名を検証します。この値は、先頭に <code>https://</code>、末尾に <code>/</code>（末尾のスラッシュが重要です）を付けた Auth0 のドメインになります。</td>
    </tr>
  </tbody>
</table>

<div id="install-dependencies">
  ## 依存関係をインストールする
</div>

Gradle を使用している場合は、[Spring Boot Gradle Plugin](https://docs.spring.io/spring-boot/docs/current/gradle-plugin/reference/html/) と [Dependency Management Plugin](https://docs.spring.io/dependency-management-plugin/docs/current/reference/html/) を利用して、必要な依存関係を追加し、そのバージョンを管理できます。

```gradle lines
// build.gradle

plugins {
    id 'java'
    id 'org.springframework.boot' version '3.1.5'
    id 'io.spring.dependency-management' version '1.1.3'
}

dependencies {
    implementation 'org.springframework.boot:spring-boot-starter-web'
    implementation 'com.okta.spring:okta-spring-boot-starter:3.0.5'
}
```

Maven を使用している場合は、`pom.xml` ファイルに Spring の依存関係を追加します。

```xml lines
// pom.xml

<parent>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-parent</artifactId>
    <version>3.1.5</version>
    <relativePath/>
</parent>

<dependencies>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-web</artifactId>
    </dependency>
    <dependency>
        <groupId>com.okta</groupId>
        <artifactId>okta-spring-boot-starter</artifactId>
        <version>3.0.5</version>
    </dependency>
</dependencies>
```

<div id="protect-api-endpoints">
  ## API エンドポイントを保護する
</div>

次のルートは、以下のリクエストで利用できます。

* `GET /api/public`: 認証されていないリクエストで利用可能
* `GET /api/private`: 追加のスコープを持たないアクセストークンを含む認証済みリクエストで利用可能
* `GET /api/private-scoped`: `read:messages` スコープが付与されたアクセストークンを含む認証済みリクエストで利用可能

アプリケーションをリソースサーバーとして構成し、JWT を検証するには、[`SecurityFilterChain`](https://docs.spring.io/spring-security/site/docs/current/api/org/springframework/security/web/SecurityFilterChain.html) のインスタンスを登録するクラスを作成し、そのクラスに `@Configuration` アノテーションを追加します。

次の例は、`SecurityConfig` クラスの `filterChain()` メソッドで提供される `HttpSecurity` オブジェクトを使用して API メソッドを保護する方法を示しています。ルートマッチャーを使用して、必要な認可レベルに基づいてアクセスを制限します。

```java Java lines
// src/main/java/com/auth0/example/security/SecurityConfig.java

import org.springframework.context.annotation.Bean;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.web.SecurityFilterChain;

@EnableWebSecurity
public class SecurityConfig {

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http.authorizeRequests()
                .mvcMatchers("/api/public").permitAll()
                .mvcMatchers("/api/private").authenticated()
                .mvcMatchers("/api/private-scoped").hasAuthority("SCOPE_read:messages")
                .and().cors()
                .and().oauth2ResourceServer().jwt();
        return http.build();
    }
}
```

<Info>
  デフォルトでは、Spring Security は JWT の `scope` クレームに含まれる各スコープごとに `GrantedAuthority` を作成します。これにより、`read:messages` スコープを含む有効な JWT を持つ場合にのみアクセスできるように、`hasAuthority("SCOPE_read:messages")` メソッドでアクセスを制限できます。
</Info>

<div id="create-the-api-controller">
  ### API コントローラーの作成
</div>

`Message` という名前の新しいレコードを作成します。これは API が返すドメイン オブジェクトになります。

```java Java lines
// src/main/java/com/auth0/example/model/Message.java

public record Message(String message) {}
```

エンドポイントへのリクエストを処理するための新しいクラス `APIController` を作成します。

```java Java lines
// src/main/java/com/auth0/example/web/APIController.java

import com.auth0.example.model.Message;
import org.springframework.http.MediaType;
import org.springframework.web.bind.annotation.CrossOrigin;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

/**
 * "/api" エンドポイントへのリクエストを処理します。
 * @see com.auth0.example.security.SecurityConfig これらのエンドポイントがどのように保護されているかを確認してください。
 */
@RestController
@RequestMapping(path = "api", produces = MediaType.APPLICATION_JSON_VALUE)
// このサンプルを簡潔にするため、すべてのオリジンを許可しています。実際のアプリケーションでは、ユースケースに応じて CORS を設定する必要があります。
@CrossOrigin(origins = "*")
public class APIController {

    @GetMapping(value = "/public")
    public Message publicEndpoint() {
        return new Message("問題ありません。/api/public を呼び出すために認証は不要です。");
    }

    @GetMapping(value = "/private")
    public Message privateEndpoint() {
        return new Message("問題ありません。認証されているため、これを表示できます。");
    }

    @GetMapping(value = "/private-scoped")
    public Message privateScopedEndpoint() {
        return new Message("問題ありません。'read:messages' スコープが付与されたトークンで認証されているため、これを表示できます。");
    }
}
```

<div id="run-the-application">
  ## アプリケーションを実行する
</div>

サンプルプロジェクトをビルドして実行するには、Gradle タスク `bootRun` を実行します。

Linux または macOS の場合:

```bash lines
./gradlew bootRun
```

Windows:

```bash lines
gradlew.bat bootRun
```

Maven と [Spring Boot Maven Plugin](https://docs.spring.io/spring-boot/docs/current/reference/html/build-tool-plugins-maven-plugin.html) を使用して独自のアプリケーションを設定している場合は、`spring-boot:run` ゴールを実行できます。

Linux または macOS の場合:

```bash lines
mvn spring-boot:run
```

Windows：

```bash lines
mvn.cmd spring-boot:run
```

The sample アプリケーションは `http://localhost:3010/` で利用できます。API をテストして利用する方法については、[Using Your API](/docs/ja-JP/quickstart/backend/java-spring-security5/02-using) の記事を参照してください。

<Info>
  ##### 次にできることは？

  [Part 2: Using Your API](/docs/ja-JP/quickstart/backend/java-spring-security5/02-using)

  [GitHub で編集](https://github.com/auth0/docs/edit/master/articles/quickstart/backend/java-spring-security5/01-authorization.md)
</Info>

***
