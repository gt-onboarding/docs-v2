---
title: Ruby on Rails API に認可を追加する
sidebarTitle: Ruby on Rails API

---

import { Recipe, Content, Section, SideMenu, SideMenuSectionItem, SignUpForm } from "/snippets/ja-JP/recipe.jsx";
import { LoggedInForm } from "/snippets/ja-JP/Login.jsx";
import ApplicationController from "/snippets/ja-JP/quickstart/backend/rails/application_controller.rb.mdx";
import Auth0Client from "/snippets/ja-JP/quickstart/backend/rails/auth0_client.rb.mdx";
import Secured from "/snippets/ja-JP/quickstart/backend/rails/secured.rb.mdx";
import PublicController from "/snippets/ja-JP/quickstart/backend/rails/public_controller.rb.mdx";
import PrivateController from "/snippets/ja-JP/quickstart/backend/rails/private_controller.rb.mdx";

import {AuthCodeGroup} from "/snippets/ja-JP/AuthCodeGroup.jsx";

export const sections = [
  { id: "define-permissions", title: "権限を定義する" },
  { id: "install-dependencies", title: "依存関係をインストールする" },
  { id: "create-an-auth0client-class", title: "Auth0Client クラスを作成する" },
  { id: "define-a-secured-concern", title: "Secured Concern を定義する" },
  { id: "include-the-secure-concern-in-your-applicationcontroller", title: "ApplicationController に Secure Concern をインクルードする" },
  { id: "create-the-public-endpoint", title: "公開エンドポイントを作成する" },
  { id: "create-the-private-endpoints", title: "プライベートエンドポイントを作成する" }
]


<Recipe isSingleColumn>
  <Content>
    このチュートリアルでは、カスタム `Auth0Client` クラス内で [jwt](https://github.com/jwt/ruby-jwt) Gem を使用してアクセストークンの検証を行います。`Secured` という Concern を使用して、受信アクセストークンによる認証を必要とするエンドポイントを認可します。

    Auth0 Dashboard でまだ API を作成していない場合は、インタラクティブセレクターを使用して新しい Auth0 API を作成するか、プロジェクト用の既存の API を選択してください。

    Auth0 Dashboard で最初の API をセットアップするには、[入門ガイド](https://auth0.com/docs/get-started/auth0-overview/set-up-apis)を参照してください。

    各Auth0 APIはAPI識別子を使用します。アプリケーションはアクセストークンを検証する際にこの識別子が必要です。

    <Info>
      **Auth0 を初めて利用しますか？** [Auth0 の仕組み](https://auth0.com/docs/overview) を確認し、OAuth 2.0 フレームワークを使用した [API の認証と認可の実装方法](https://auth0.com/docs/api-auth) について読んでみてください。
    </Info>

    <Section id={sections[0].id} title={sections[0].title} stepNumber="1" isSingleColumn>
      Permissions を使用すると、特定のアクセストークンを持つユーザーに代わって、リソースにどのようなアクセスを許可するかを定義できます。たとえば、ユーザーがマネージャーのアクセスレベルを持っている場合は `messages` リソースへの読み取りアクセスを許可し、管理者のアクセスレベルを持っている場合はそのリソースへの書き込みアクセスを許可するといったことができます。

      許可する権限は、Auth0 Dashboard の [APIs](https://manage.auth0.com/#/apis) セクション内にある **Permissions** ビューで定義できます。

      <Frame>
        <img src="/docs/images/cdy7uua7fh8z/1s3Yp5zqJiKiSWqbPSezNO/e61793a2822d095666002c3f65c71ac2/configure-permissions.png" />
      </Frame>

      <Info>
        この例では `read:messages` スコープを使用します。
      </Info>

      <LoggedInForm />
    </Section>

    <Section id={sections[1].id} title={sections[1].title} stepNumber="2" isSingleColumn>
      **jwt** Gem をインストールします。

      ```bash lines
      gem 'jwt'
      bundle install
      ```

      <LoggedInForm />
    </Section>

    <Section id={sections[2].id} title={sections[2].title} stepNumber="3" isSingleColumn>
      `Auth0Client` というクラスを作成します。このクラスは、リクエストの `Authorization` ヘッダーから取得したアクセストークンをデコードして検証します。

      `Auth0Client` クラスは、Auth0 テナントの公開鍵を取得し、それを使用してアクセストークンの署名を検証します。`Token` 構造体は `validate_permissions` メソッドを定義しており、必要なスコープの配列を渡すことで、アクセストークン内に特定の `scope` が存在するかどうかを、トークンのペイロードを確認してチェックします。

      <AuthCodeGroup>
        <Secured />

        <ApplicationController />

        <Auth0Client />

        <PublicController />

        <PrivateController />
      </AuthCodeGroup>
    </Section>

    <Section id={sections[3].id} title={sections[3].title} stepNumber="4" isSingleColumn>
      `Secured` という Concern を作成し、受信したリクエストの `Authorization`
      ヘッダーからアクセストークンを取得します。

      トークンが存在する場合、`Auth0Client.validate_token` は `jwt` Gem を使用して
      トークンの署名を検証し、トークンのクレームを検証します。

      アクセストークンが有効であることを検証するだけでなく、この Concern には、
      要求されたリソースへアクセスするためにトークンが必要な **スコープ** を持っていることを確認する仕組みも含まれています。この例では、
      ブロックを受け取り、`Auth0Client` クラスの `Token.validate_permissions` メソッドを呼び出して
      パーミッションを確認する `validate_permissions` メソッドを定義しています。

      `/private-scoped` ルートについては、定義されたスコープとペイロードに含まれるスコープを
      突き合わせ、もう一方の配列に含まれる要素が 1 つ以上存在するかどうかを判定します。

      <AuthCodeGroup>
        <Secured />

        <ApplicationController />

        <Auth0Client />

        <PublicController />

        <PrivateController />
      </AuthCodeGroup>
    </Section>

    <Section id={sections[4].id} title={sections[4].title} stepNumber="5" isSingleColumn>
      `Secure` Concern をアプリケーションコントローラに追加すると、認可が必要なコントローラでだけ `before_action` フィルタを使えばよくなります。

      <AuthCodeGroup>
        <ApplicationController />

        <Auth0Client />

        <Secured />

        <PublicController />

        <PrivateController />
      </AuthCodeGroup>
    </Section>

    <Section id={sections[5].id} title={sections[5].title} stepNumber="6" isSingleColumn>
      `/api/public` というパブリックなエンドポイントを処理するコントローラーを作成します。

      `/public` エンドポイントは認可を必要としないため、`before_action` は不要です。

      <AuthCodeGroup>
        <PublicController />

        <ApplicationController />

        <Auth0Client />

        <Secured />

        <PrivateController />
      </AuthCodeGroup>
    </Section>

    <Section id={sections[6].id} title={sections[6].title} stepNumber="7" isSingleColumn>
      プライベートエンドポイント `/api/private` および `/api/private-scoped` を処理するコントローラーを作成します。

      `/api/private` は、追加のスコープを含まないアクセストークンを持つ認証済みリクエストで利用できます。

      `/api/private-scoped` は、`read:messages` スコープが付与されたアクセストークンを含む認証済みリクエストで利用できます

      保護されたエンドポイントは、`Secured` concern の `authorize` メソッドを呼び出す必要があります。そのために `before_action :authorize` を使用します。これにより、`PrivateController` 内のすべてのアクションの前に `Secured.authorize` メソッドが確実に呼び出されます。

      ### APIを呼び出す

      APIを呼び出すには、アクセストークンが必要です。テスト目的のアクセストークンは、[API設定](https://manage.auth0.com/#/apis)の**Test**ビューから取得できます。

      <Frame>
        <img src="/docs/images/cdy7uua7fh8z/6jeVBuypOGX5qMRXeJn5ow/5e79037f6c852d2043789d622bdb9562/Quickstart_Example_App_-_English.png" />
      </Frame>

      リクエストの`Authorization`ヘッダーにアクセストークンを指定してください。

      <AuthCodeGroup>
        ```bash cURL lines
        curl --request get \
        --url 'http:///%7ByourDomain%7D/api_path' \
        --header 'authorization: Bearer YOUR_ACCESS_TOKEN_HERE'
        ```

        ```csharp C# lines
        var client = new RestClient("http:///%7ByourDomain%7D/api_path");
        var request = new RestRequest(Method.GET);
        request.AddHeader("authorization", "Bearer YOUR_ACCESS_TOKEN_HERE");
        IRestResponse response = client.Execute(request);
        ```

        ```go Go lines
        package main
        import (
        "fmt"
        "net/http"
        "io/ioutil"
        )
        func main() {
        url := "http:///%7ByourDomain%7D/api_path"
        req, _ := http.NewRequest("get", url, nil)
        req.Header.Add("authorization", "Bearer YOUR_ACCESS_TOKEN_HERE")
        res, _ := http.DefaultClient.Do(req)
        defer res.Body.Close()
        body, _ := ioutil.ReadAll(res.Body)
        fmt.Println(res)
        fmt.Println(string(body))
        }
        ```

        ```java Java lines
        HttpResponse<String> response = Unirest.get("http:///%7ByourDomain%7D/api_path")
        .header("authorization", "Bearer YOUR_ACCESS_TOKEN")
        .asString();
        ```

        ```javascript Node.JS lines
        var axios = require("axios").default;
        var options = {
        method: 'get',
        url: 'http:///%7ByourDomain%7D/api_path',
        headers: {authorization: 'Bearer ここにアクセストークンを入力'}
        };
        axios.request(options).then(function (response) {
        console.log(response.data);
        }).catch(function (error) {
        console.error(error);
        });
        ```

        ```objc Obj-C lines
        #import <Foundation/Foundation.h>
        NSDictionary *headers = @{ @"authorization": @"Bearer ここにアクセストークンを記述" };
        NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@"http:///%7ByourDomain%7D/api_path"]
                                                        cachePolicy:NSURLRequestUseProtocolCachePolicy

                                                    timeoutInterval:10.0];

        [request setHTTPMethod:@"get"];
        [request setAllHTTPHeaderFields:headers];
        NSURLSession *session = [NSURLSession sharedSession];
        NSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request
                                                completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {

                                                    if (error) {

                                                        NSLog(@&quot;%@&quot;, error);

                                                    } else {

                                                        NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;

                                                        NSLog(@&quot;%@&quot;, httpResponse);

                                                    }

                                                }];

        [dataTask resume];
        ```

        ```php PHP lines
        #import <Foundation/Foundation.h>
        NSDictionary *headers = @{ @"authorization": @"Bearer ここにアクセストークンを記入" };
        NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@"http:///%7ByourDomain%7D/api_path"]
                                                        cachePolicy:NSURLRequestUseProtocolCachePolicy

                                                    timeoutInterval:10.0];

        [request setHTTPMethod:@"get"];
        [request setAllHTTPHeaderFields:headers];
        NSURLSession *session = [NSURLSession sharedSession];
        NSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request
                                                completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {

                                                    if (error) {

                                                        NSLog(@&quot;%@&quot;, error);

                                                    } else {

                                                        NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;

                                                        NSLog(@&quot;%@&quot;, httpResponse);

                                                    }

                                                }];

        [dataTask resume];
        ```

        ```python Python lines
        import http.client
        conn = http.client.HTTPConnection("")
        headers = { 'authorization': "Bearer YOUR_ACCESS_TOKEN" }
        conn.request("get", "/%7ByourDomain%7D/api_path", headers=headers)
        res = conn.getresponse()
        data = res.read()
        print(data.decode("utf-8"))
        ```

        ```ruby Ruby lines
        require 'uri'
        require 'net/http'
        url = URI("http:///%7ByourDomain%7D/api_path")
        http = Net::HTTP.new(url.host, url.port)
        request = Net::HTTP::Get.new(url)
        request["authorization"] = 'Bearer ここにアクセストークンを入力'
        response = http.request(request)
        puts response.read_body
        ```

        ```swift Swift lines
        import Foundation
        let headers = ["authorization": "Bearer YOUR_ACCESS_TOKEN_HERE"]
        let request = NSMutableURLRequest(url: NSURL(string: "http:///%7ByourDomain%7D/api_path")! as URL,
                                            cachePolicy: .useProtocolCachePolicy,

                                        timeoutInterval: 10.0)

        request.httpMethod = "get"
        request.allHTTPHeaderFields = headers
        let session = URLSession.shared
        let dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in
        if (error != nil) {
        print(error)

        } else {
        let httpResponse = response as? HTTPURLResponse

        print(httpResponse)

        }
        })
        dataTask.resume()
        ```
      </AuthCodeGroup>

      <Note>
        ##### チェックポイント

        アプリケーションの設定が完了したら、次の点を確認するためにアプリケーションを実行します。

        * `GET /api/public` が、認証されていないリクエストでも利用できること。
        * `GET /api/private` が、認証されたリクエストで利用できること。
        * `GET /api/private-scoped` が、`read:messages` スコープを持つアクセス トークンを含む認証済みリクエストで利用できること。
      </Note>

      <AuthCodeGroup>
        <PrivateController />

        <ApplicationController />

        <Auth0Client />

        <Secured />

        <PublicController />
      </AuthCodeGroup>
    </Section>

    ## 次のステップ

    素晴らしい!ここまで進めたなら、アプリケーションでログイン、ログアウト、およびユーザープロファイル情報が実装されているはずです。

    これでクイックスタートチュートリアルは終了ですが、他にも多くの機能があります。Auth0でできることの詳細については、以下をご確認ください:

    * [Auth0 Dashboard](https://manage.auth0.com/dashboard/us/dev-gja8kxz4ndtex3rq) - Auth0 テナントおよびアプリケーションの設定と管理方法について学ぶ
    * [omniauth-auth0 SDK](https://github.com/auth0/omniauth-auth0) - このチュートリアルで使用するソフトウェア開発キット (SDK) について、さらに詳しく見てみましょう
    * [Auth0 Marketplace](https://marketplace.auth0.com/) - Auth0 の機能を拡張できる連携機能を見つけましょう
  </Content>
</Recipe>